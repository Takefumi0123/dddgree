/***********************************************************************/
/*                                                                     */
/*  FILE        :Atlas_new_3.c                                         */
/*  DATE        :Mon, Apr 14, 2014                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX62N                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.53).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/
                  
				  
//#include "typedefine.h"
#ifdef __cplusplus
//#include <ios>                        // Remove the comment when you use ios
//_SINT ios_base::Init::init_cnt;       // Remove the comment when you use ios
#endif

#include "iodefine.h"
#include "math.h"
#include "mathf.h"
#include <stdio.h>

void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

//基本設定
#define ON			1
#define OFF			0
#define FRONT 			1
#define BACK 			2
#define CW 				5
#define CCW 				6
#define AUTO					7
#define MANUAL				8
#define RED						9
#define BLUE						10
#define STANDBY				0
#define TASK_SEESAW		1
#define TASK_SWING			2
#define TASK_POLE			3
#define TASK_JUNGLE_GYM	4
#define SELECT_TASK		5
#define RETRY				100
#define M_PI 				3.14159265
#define INTERRUPT_START	CMT.CMSTR0.BIT.STR0 = 1;//カウント開始
#define INTERRUPT_TIME 		10
#define PWM_PERIOD				((48000000/1)/100000)//10000
#define BITRATE_1	115200
#define BITRATE_2	115200
/*#define ADC10U0_MODE			3			//0：シングルモード 1：設定しないでください 2：連続スキャンモード 3：1サイクルスキャンモード
#define ADC10U1_MODE			3			//0：シングルモード 1：設定しないでください 2：連続スキャンモード 3：1サイクルスキャンモード
#define ADC10U0_CH				2			//チャネル選択 ←変換モードによって違う p1709/1974
#define ADC10U1_CH				2			//チャネル選択 ←変換モードによって違う p1709/1974*/

#define TOGGLE_MANUAL_MODE	PORT6.PORT.BIT.B7		//手動モード
#define TOGGLE_DEBUG_MODE		PORT5.PORT.BIT.B1		//デバッグモード

//CADデータ

	#define CAD_SIZE_CENTER_TO_TIRE		442.0	//車体中心からオムニホイールまでの長さ
	#define CAD_SIZE_CENTER_TO_FAN_0		257.39	//車体中心からファン(左、右)までの長さ
	#define CAD_SIZE_CENTER_TO_FAN_1		42.83	//車体前方向からファン(左、右)までの角度
	#define CAD_SIZE_CENTER_TO_FAN_2		38.7		//車体中心からファン(後)までの長さ
	#define CAD_SIZE_CENTER_TO_GRAVITY		73.0	//車体中心から重心位置までの距離
	#define MANUAL_ROBOT_WEIGHT			29.0		//手動ロボットの重量	単位：ｋｇ
	#define FAN_POWER_MAX_WEIGHT			3.0		//一つのファンでMax時にプラスされる重量　単位：ｋｇ
	
	//上アーム
	#define CAD_SIZE_TOP_ARM_1		55.25	//①	車体中心から支柱角管前までの長さ
	#define CAD_SIZE_TOP_ARM_2		969.0	//②	地面から支柱角管上までの高さ
	#define CAD_SIZE_TOP_ARM_3		214.0	//③	支柱角管上から上アームスライド角管最高部までの高さ
	#define CAD_SIZE_TOP_ARM_4		60.0		//④	上アームスライド角管からリミットスイッチまでの長さ
	#define CAD_SIZE_TOP_ARM_5		79.5		//⑤	上アームの初期長さから傾き支点までの長さ
	#define CAD_SIZE_TOP_ARM_6		60.0		//⑥	上アームスライド角管上から傾き支点までの高さ
	#define CAD_SIZE_TOP_ARM_7		126.4	//⑦	傾き支点から自動保持まで
	//シーソーアーム
	#define CAD_SIZE_SEESAW_ARM_1		55.25	//①　車体中心から支柱角管までの長さ
	#define CAD_SIZE_SEESAW_ARM_2		807.5	//②　地面からスライド角管上までの高さ
	#define CAD_SIZE_SEESAW_ARM_3		94.919	//③	スライド角管上からシーソーカタカタ板下までの高さ
	#define CAD_SIZE_SEESAW_ARM_4		84.012	//④　スライド角管上からシーソーカタカタ板上までの高さ
	#define CAD_SIZE_SEESAW_ARM_5		22.5		//⑤　支柱からアーム機構限界までの長さ
	#define CAD_SIZE_SEESAW_ARM_6		30.0		//⑥　アーム機構限界からカタカタ板支点までの長さ
	
	//各アーム初期値
	#define INIT_TOP_ARM_LENGTH	 			111.5	//上アームの車体中心からの長さ
	#define INIT_TOP_ARM_DEGREE 				0.0	//上アームの角度
	#define INIT_TOP_ARM_TILT_DEGREE		0.0	//下アームの車体中心からの長さ
	#define INIT_SEESAW_ARM_LENGTH		0.0	//シーソーアームの車体中心からの長さ
	
	//アーム高さ一番下に下がった時
	#define INIT_TOP_ARM_HIGH				383.0	//389.0//373.0//上アーム(自動保持板部分)
	#define INIT_SEESAW_ARM_HIGH			220.0	//シーソーアーム(カタカタ板中心部分)
	#define INIT_SWING_ARM_HIGH			327.0	//ブランコアーム(保持下部分)

	//上アーム回転の機構限界角度
	#define LIMIT_TOP_ARM_DEGREE			135.0





/*********************************システム**********************************************/
			//コート選択
			#define COLOR				BLUE				//赤コート：RED		青コート：BLUE

			#define ENCODER_CALIBRATION_MODE		OFF	//エンコーダのキャリブレーションモード
			#define BLUETOOTH_MODE							OFF	//BluetoothでUART通信
			#define MODE_SEND_TO_MBED					ON	//mbedにデータ送信
			#define MODE_FAKE_AUTO_ROBOT				OFF	//仮自動機練習モード(本番機よりも20mm高い)
			#define MODE_ALL_FAN_STOP						OFF	//全ファン停止モード
			#define MODE_ARM_TEST								OFF	//アーム指定角度、高さ、長さtest
						
/***************************************************************************************/


	//自動機高さ
	#if MODE_FAKE_AUTO_ROBOT == OFF
		//本番機
		#define AUTO_ROBOT_HIGH_PARALLEL		401.0	//408.5	//462.0	//自動ロボットの平行状態の高さ
		#define AUTO_ROBOT_HIGH_TILT					409.0	//470.0			//自動ロボットの傾いた時の最大高さ
		#define AUTO_ROBOT_WEIGHT						9.8		//自動ロボットの重量　単位：kg
	#else
		//偽自動機
		#define AUTO_ROBOT_HIGH_PARALLEL		408.5	//428.5	//462.0	//自動ロボットの平行状態の高さ
		#define AUTO_ROBOT_HIGH_TILT					416.5	//436.5	//470.0			//自動ロボットの傾いた時の最大高さ
		#define AUTO_ROBOT_WEIGHT						9.8		//自動ロボットの重量　単位：kg
	#endif
	
	//#define FRONT_TO_CENTER_DISTANCE		271.24//244.925//車体前から中心までの距離




//アームの順送りの目標値
	//上アーム長さ
	/*#define TARGET_TOP_ARM_LENGTH_1		250.0	//初期状態、タスク間移動中
	#define TARGET_TOP_ARM_LENGTH_2		450.0	//シーソー置く、回収する
	#define TARGET_TOP_ARM_LENGTH_3		400.0	//ジャングルジム
	#define TARGET_TOP_ARM_LENGTH_4		150.0	//シーソー、ブランコ押す
	#define TARGET_TOP_ARM_LENGTH_5		580.0	//その他*/
	//上アーム回転角度
	/*#if COLOR == RED
			#define TARGET_TOP_ARM_DEGREE_1		0.0			//その他
			#define TARGET_TOP_ARM_DEGREE_2		90.0			//シーソーから回収、ポールに置く
			#define TARGET_TOP_ARM_DEGREE_3		(-90.0)		//シーソー置く
			#define TARGET_TOP_ARM_DEGREE_4		60.0			//ポールから回収
			
	#elif COLOR == BLUE
			#define TARGET_TOP_ARM_DEGREE_1		0.0			//その他
			#define TARGET_TOP_ARM_DEGREE_2		(-90.0)		//シーソーから回収、ポールに置く
			#define TARGET_TOP_ARM_DEGREE_3		90.0			//シーソー置く
			#define TARGET_TOP_ARM_DEGREE_4		(-60.0)		//ポールから回収
	#endif
	*/
	//上アーム傾き角度
	/*#define TARGET_TOP_ARM_TILT_DEGREE_1		90.0		//ジャングルジムに置く
	#define TARGET_TOP_ARM_TILT_DEGREE_2		0.0		//その他*/
	//シーソーアーム長さ
	/*#define TARGET_SEESAW_ARM_LENGTH_1		100.0	//シーソー押す
	#define TARGET_SEESAW_ARM_LENGTH_2		0.0	//その他*/
	
//リフトアーム
	//上アーム高さ
	#define TARGET_TOP_ARM_LIFT_1	(AUTO_ROBOT_HIGH_PARALLEL + 168.0 + 0.0)	//シーソー置く、回収する
	#define TARGET_TOP_ARM_LIFT_2	(AUTO_ROBOT_HIGH_TILT + 460.0)	//ブランコ上侵入、持ち上げる
	#define TARGET_TOP_ARM_LIFT_3	(AUTO_ROBOT_HIGH_TILT + 460.0)	//シーソー・ポール上侵入、ポールから持ち上げる
	#define TARGET_TOP_ARM_LIFT_4	(AUTO_ROBOT_HIGH_PARALLEL + 390.0)	//ポールに置く、回収
	#define TARGET_TOP_ARM_LIFT_5	(AUTO_ROBOT_HIGH_TILT + 220.0)	//ジャングルジムに置く
	#define TARGET_TOP_ARM_LIFT_6	(AUTO_ROBOT_HIGH_TILT + 170.0)	//初期状態
	#define TARGET_TOP_ARM_LIFT_7 	(AUTO_ROBOT_HIGH_PARALLEL + 420.0)	//ブランコ置く・回収
	//シーソーアーム高さ
	#define TARGET_SEESAW_ARM_LIFT_1		570.0	//シーソー押す上にセット
	#define TARGET_SEESAW_ARM_LIFT_2		540.0	//シーソー引く高さ
	#define TARGET_SEESAW_ARM_LIFT_3		355.0	//シーソー押す高さ
	//ブランコアーム高さ
	#define TARGET_SWING_ARM_LIFT_1		410	//400.0	//380.0	//ブランコ掴む高さ
	#define TARGET_SWING_ARM_LIFT_2		920.93	//936.27	//917.88	//913.31	//898	//860		//875.0	//901.0//943.57//898.17//928.59//898.17	//897.45//904.95//875.2//920.03	//ブランコ放す高さ



//シーソー中心座標
#define SEESAW_CENTER_X		4243.0
#define SEESAW_CENTER_Y		0.0

//足回り自動における目標値設定+各アーム長さ、高さ

	/****************************************************************************/
	//																																						//
	//																赤コート																			//
	//																																						//
	/****************************************************************************/
	#if COLOR == RED			
	
			/*************スタート角度、座標(赤コート)****************************************/
			#define START_X 					(-92.157)		//-90.0//4243
			#define START_Y 					92.157			//50.0//1544.925
			#define START_DEGREE 			(-45.0)			
	
			/************スタートゾーン→シーソー押す位置(赤コート)*******************************/
			#define TARGET_TO_SEESAW_DIRECTION_1	(-20.0)		//一つ目の曲線スタート方向角度
			#define TARGET_TO_SEESAW_DIRECTION_2	55.0			//60.0//2つ目の曲線スタート方向角度
			#define TARGET_MIDDLE_X		1500		//曲線の軌跡変更座標
			#define TARGET_MIDDLE_Y		500
			#define TARGET_TO_SEESAW_X			4243.0		//(4143 - 150.0)//最終目標座標
			#define TARGET_TO_SEESAW_Y			1550		//1650//1800
			#define TARGET_TO_SEESAW_DEGREE		(-90.0)
			#define A_UP_TO_SEESAW				3000	//加速度
			#define A_DOWN_TO_SEESAW			1800	//減速度
			#define MAX_VELOCITY_TO_SEESAW		2500	//最高速度
			#define A_UP_OMEGA				600	//角加速度
			#define A_DOWN_OMEGA				600	//角減速度
			#define MAX_OMEGA					400	//最高角速度
			#define ARM_CHANGE_POSITION_0		1000	//上アーム角度変更ｘ座標
			#define ARM_CHANGE_POSITION_1		1750	//アーム高さ、長さ変更ｘ座標
			#define DEGREE_CHANGE_POSITION_0	700	//車体角度変更ｘ座標
			
			
	
			/************シーソー置く→押す→回収(赤コート)****************************************/
			#define TARGET_SEESAW_X_0					4243.0		//①シーソーに置く地点
			#define TARGET_SEESAW_Y_0					1650			//1650.0
			#define TARGET_SEESAW_DEGREE_0		(-90.0)
			#define TARGET_SEESAW_X_1					4243.0		//②円弧走行の終点(置く→押す)
			#define TARGET_SEESAW_Y_1					(-1650.0)		//-1650.0
			#define TARGET_SEESAW_DEGREE_1		90.0
			#define TARGET_SEESAW_X_2					4243.0		//③押す地点
			#define TARGET_SEESAW_Y_2					(-1650.0)	//-1650.0
			#define TARGET_SEESAW_DEGREE_2		90.0
			#define TARGET_SEESAW_X_3					4243.0		//④円弧走行の終点(押す→回収)
			#define TARGET_SEESAW_Y_3					1650	//1650.0
			#define TARGET_SEESAW_DEGREE_3		(-90.0)
			#define TARGET_SEESAW_CENTER_DEGREE_0		(-175.0)		//円弧走行での回る中心角
			#define TARGET_SEESAW_CENTER_DEGREE_1		(-175.0)
			//シーソー周りの加速度、最高速度調整
			#define SEESAW_CURVE_A_UP			2500		//シーソー周りの加速度
			#define SEESAW_CURVE_A_DOWN		2500	//シーソー周りの減速度
			#define SEESAW_CURVE_MAX_VELOCITY		3000	//シーソー周りの最高速度
			#define ARM_CHANGE_POSITION_2		1000		//シーソーアーム伸ばし始めｙ座標
			#define ARM_CHANGE_POSITION_3		(-1200)	//シーソーアーム引きはじめy座標
			#define ARM_CHANGE_POSITION_4		0.0		//上アーム回転、高さ変更ｙ座標
	
	
	
			/***********シーソー→ブランコ(赤コート)**************************************/
			#define TARGET_TO_SWING_X_0		4243	//スタート座標
			#define TARGET_TO_SWING_Y_0		1650
			#define TARGET_TO_SWING_X_1		7743	//目標座標
			#define TARGET_TO_SWING_Y_1		3000	//2900	//3150
			#define TARGET_TO_SWING_DIRECTION_DEGREE		60.0	//曲線スタート方向角度
			#define TARGET_TO_SWING_DEGREE_0	(-90.0)		//スタート角度
			#define TARGET_TO_SWING_DEGREE_1	180.0			//目標角度①
			#define TARGET_TO_SWING_DEGREE_2	90.0			//目標角度②
			#define A_UP_TO_SWING						1000	//1500		//加速度
			#define A_DOWN_TO_SWING				500	//減速度
			#define MAX_VELOCITY_TO_SWING		1500	//最高速度
			#define A_UP_OMEGA_TO_SWING_0		150		//角加速度①
			#define A_DOWN_OMEGA_TO_SWING_0		150	//角減速度①
			#define MAX_OMEGA_TO_SWING_0		100	//最高角速度①
			#define A_UP_OMEGA_TO_SWING_1		300	//角加速度②
			#define A_DOWN_OMEGA_TO_SWING_1	300	//角減速度②
			#define MAX_OMEGA_TO_SWING_1		200	//最高角速度②
			#define ARM_CHANGE_POSITION_5		5000		//アーム微調整リセット時ｘ座標
			#define ARM_CHANGE_POSITION_6		6500		//上アーム高さ変更時ｘ座標
			#define DEGREE_CHANGE_POSITION_1	4243	//車体回転し始めｘ座標①
			#define DEGREE_CHANGE_POSITION_2	5300	//車体回転し始めｘ座標②
	
	
	
			/*************ブランコ引く(赤コート)*****************************************/
			#define TARGET_SWING_X_0		7911.0
			#define TARGET_SWING_Y_0		3360.5
			#define TARGET_SWING_X_1		7911.0
			#define TARGET_SWING_Y_1		2820.5 //2760.5		//2713.11//2597.8//2646.93//2597.8
			#define TARGET_SWING_DEGREE		90.0
			#define A_UP_SWING					350
			#define A_DOWN_SWING			350
			#define MAX_VELOCITY_SWING		400
			#define TARGET_TOP_ARM_LOCK_X		7911		//上アームロック解除x座標
			#define TARGET_TOP_ARM_LOCK_Y		4000		//上アームロック解除ｙ座標
	
	
			/****************ブランコ→ポール(赤コート)*********************************/
			#define TARGET_TO_POLE_X_0			7911
			#define TARGET_TO_POLE_Y_0			3450
			#define TARGET_TO_POLE_X_1			6800
			#define TARGET_TO_POLE_Y_1			2000			//2000	//1500
			#define TARGET_TO_POLE_X_2			6800
			#define TARGET_TO_POLE_Y_2			(-3000)
			#define TARGET_TO_POLE_DIRECTION_DEGREE_0		(-90)
			#define TARGET_TO_POLE_DIRECTION_DEGREE_1		(-120)
			#define A_UP_TO_POLE						1800
			#define A_DOWN_TO_POLE				1400
			#define MAX_VELOCITY_TO_POLE		2000
			#define TARGET_TO_POLE_DEGREE_0		90.0
			#define TARGET_TO_POLE_DEGREE_1		(-20.0)
			#define A_UP_OMEGA_TO_POLE			200
			#define A_DOWN_OMEGA_TO_POLE		200
			#define MAX_OMEGA_TO_POLE				250
			#define ARM_CHANGE_POSITION_7		2500			//アーム高さ変更y座標①
			#define ARM_CHANGE_POSITION_8		(-1500)		//アーム高さ変更y座標②
			#define DEGREE_CHANGE_POSITION_3	500.0
	
			/*************ポール→ジャングルジム(赤コート)****************/
			#define TARGET_TO_JUNGLE_X		6300
			#define TARGET_TO_JUNGLE_Y		0.0
			#define TARGET_TO_JUNGLE_DIRECTION_DEGREE		110
			#define A_UP_TO_JUNGLE		1500
			#define A_DOWN_TO_JUNGLE		1500
			#define MAX_VELOCITY_TO_JUNGLE		2000
			#define TARGET_TO_JUNGLE_DEGREE		0.0
			#define A_UP_OMEGA_TO_JUNGLE		80
			#define A_DOWN_OMEGA_TO_JUNGLE		80
			#define MAX_OMEGA_TO_JUNGLE		120
			#define ARM_CHANGE_POSITION_9		(-4000)
			#define ARM_CHANGE_POSITION_10	(-2500)
			#define DEGREE_CHANGE_POSITION_4	(-3000)
			
			
		//アーム目標長さ、高さ（赤コート）
			//		OPERATE_ARM_(ステップ)_(アーム動作番号)
			//		アーム動作番号　1:上アーム長さ	2：上アーム回転	3：上アームピッチ回転		4:シーソーアーム長さ	5：アーム高さ
			//		追加はさらに後ろにアンダーバーを入れて番号0から
		
			//step 0	初期状態(赤コート)
			//アームはすべて初期状態
			#define OPERATE_ARM_0_5_0		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_0_5_1		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_0_5_2		(AUTO_ROBOT_HIGH_TILT + 170 + 100)
			#define OPERATE_ARM_0_5_3		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_0_5_4		(AUTO_ROBOT_HIGH_TILT + 170 + 100)
			
			//step 1		子供ロボット保持用意(赤コート)
			//step 2		子供ロボット保持（step  1と同じ）
			#define OPERATE_ARM_1_1		285.0
			#define OPERATE_ARM_1_2		0.0
			#define OPERATE_ARM_1_3		0.0
			#define OPERATE_ARM_1_4		0.0
			#define OPERATE_ARM_1_5_0		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_1_5_1		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_1_5_2		(AUTO_ROBOT_HIGH_TILT + 170 + 100)
			#define OPERATE_ARM_1_5_3		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_1_5_4		(AUTO_ROBOT_HIGH_TILT + 170 + 100)
			
			//step 3		スタートからシーソーに向かう(赤コート)
			#define OPERATE_ARM_3_1_0		285.0
			#define OPERATE_ARM_3_1_1		480.0
			#define OPERATE_ARM_3_2_0		0.0
			#define OPERATE_ARM_3_2_1		(-90.0)
			#define OPERATE_ARM_3_3			0.0
			#define OPERATE_ARM_3_4			0.0
			#define OPERATE_ARM_3_5_0		(AUTO_ROBOT_HIGH_TILT + 170 + 30)
			#define OPERATE_ARM_3_5_1		(AUTO_ROBOT_HIGH_TILT + 420 + 10)
			//step 4		シーソーに置く(赤コート)
			#define OPERATE_ARM_4_1			480.0
			#define OPERATE_ARM_4_2			(-90.0)
			#define OPERATE_ARM_4_3			10.0
			#define OPERATE_ARM_4_4			0.0
			#define OPERATE_ARM_4_5			(AUTO_ROBOT_HIGH_PARALLEL + 208)
			//step 5		シーソー押す位置まで移動(赤コート)
			#define OPERATE_ARM_5_1_0		480.0
			#define OPERATE_ARM_5_1_1		610.0
			#define OPERATE_ARM_5_2			(-90.0)
			#define OPERATE_ARM_5_3_0		10.0
			#define OPERATE_ARM_5_3_1		0.0
			#define OPERATE_ARM_5_4_0		0.0
			#define OPERATE_ARM_5_4_1		470.0
			#define OPERATE_ARM_5_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 208)
			#define OPERATE_ARM_5_5_1		(TARGET_SEESAW_ARM_LIFT_1 + 40)
			//step 6　	シーソー押す(赤コート)
			//step 8
			//step 10
			#define OPERATE_ARM_6_1			610
			#define OPERATE_ARM_6_2			(-90.0)
			#define OPERATE_ARM_6_3			0.0
			#define OPERATE_ARM_6_4			470
			#define OPERATE_ARM_6_5			TARGET_SEESAW_ARM_LIFT_3
			//step 7		シーソー引く(赤コート)
			//step 9		
			#define OPERATE_ARM_7_1			610
			#define OPERATE_ARM_7_2			(-90.0)
			#define OPERATE_ARM_7_3			0.0
			#define OPERATE_ARM_7_4			470.0
			#define OPERATE_ARM_7_5			(TARGET_SEESAW_ARM_LIFT_2 + 40)
			//step 11		シーソーから回収位置まで移動(赤コート)
			#define OPERATE_ARM_11_1_0		610.0
			#define OPERATE_ARM_11_1_1		480.0
			#define OPERATE_ARM_11_2_0		(-90.0)
			#define OPERATE_ARM_11_2_1		90.0
			#define OPERATE_ARM_11_3			10.0
			#define OPERATE_ARM_11_4_0		470.0
			#define OPERATE_ARM_11_4_1		0.0
			#define OPERATE_ARM_11_5_0		(TARGET_SEESAW_ARM_LIFT_1 + 40)
			#define OPERATE_ARM_11_5_1		(AUTO_ROBOT_HIGH_PARALLEL + 208 + 10)
			
			//step 12		子供ロボット回収＋ブランコに向かう(赤コート)
			#define OPERATE_ARM_12_1_0		480.0
			#define OPERATE_ARM_12_1_1		350.0
			#define OPERATE_ARM_12_2_0		90.0
			#define OPERATE_ARM_12_2_1		0.0
			#define OPERATE_ARM_12_3_0		10.0
			#define OPERATE_ARM_12_3_1		0.0
			#define OPERATE_ARM_12_4			0.0
			#define OPERATE_ARM_12_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 208 + 10)
			#define OPERATE_ARM_12_5_1		(AUTO_ROBOT_HIGH_PARALLEL + 238 + 10 + 10)
			#define OPERATE_ARM_12_5_2		(AUTO_ROBOT_HIGH_TILT + 460)
			
			//step 13		ブランコ上空侵入(赤コート)
			#define OPERATE_ARM_13_1			610.0
			#define OPERATE_ARM_13_2			0.0
			#define OPERATE_ARM_13_3			0.0
			#define OPERATE_ARM_13_4			0.0
			#define OPERATE_ARM_13_5			(AUTO_ROBOT_HIGH_TILT + 485)
			//step 14		ブランコにおろす(赤コート)
			//step 20		子供ロボット保持
			#define OPERATE_ARM_14_1			610.0
			#define OPERATE_ARM_14_2			0.0
			#define OPERATE_ARM_14_3			0.0
			#define OPERATE_ARM_14_4			0.0
			#define OPERATE_ARM_14_5			(AUTO_ROBOT_HIGH_PARALLEL + 400)
			//step 15		アーム放す(赤コート)
			//step 19		子供ロボット保持高さ調整
			#define OPERATE_ARM_15_1_0			610.0
			#define OPERATE_ARM_15_1_1		200
			#define OPERATE_ARM_15_2			0.0
			#define OPERATE_ARM_15_3			0.0
			#define OPERATE_ARM_15_4			0.0
			#define OPERATE_ARM_15_5			(AUTO_ROBOT_HIGH_PARALLEL + 400)
			//step 16		上アーム引く＋ブランコアームのばす(赤コート)
			#define OPERATE_ARM_16_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_16_2			0.0
			#define OPERATE_ARM_16_3			0.0
			#define OPERATE_ARM_16_4_0		0.0
			#define OPERATE_ARM_16_4_1		460	//430.0
			#define OPERATE_ARM_16_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 400)
			#define OPERATE_ARM_16_5_1		(TARGET_SWING_ARM_LIFT_1 - 10)
			//step 17		ブランコつかむ + ブランコ引く(赤コート)
			#define OPERATE_ARM_17_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_17_2			0.0
			#define OPERATE_ARM_17_3			0.0
			#define OPERATE_ARM_17_4_0		460	//430
			#define OPERATE_ARM_17_4_1		(182)
			#define OPERATE_ARM_17_5_0		(TARGET_SWING_ARM_LIFT_1 - 10)
			#define OPERATE_ARM_17_5_1		TARGET_SWING_ARM_LIFT_2               
			//step 18		ブランコ放す(赤コート)
			#define OPERATE_ARM_18_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_18_2			0.0
			#define OPERATE_ARM_18_3			0.0
			#define OPERATE_ARM_18_4			(182)
			#define OPERATE_ARM_18_5			TARGET_SWING_ARM_LIFT_2
			
			//step 21		ブランコからポールに向かう(赤コート)
			#define OPERATE_ARM_21_1			350
			#define OPERATE_ARM_21_2_0			0.0
			#define OPERATE_ARM_21_2_1		95.0
			#define OPERATE_ARM_21_3			0.0
			#define OPERATE_ARM_21_4			0.0
			#define OPERATE_ARM_21_5_0		(AUTO_ROBOT_HIGH_TILT + 460)
			#define OPERATE_ARM_21_5_1		(AUTO_ROBOT_HIGH_TILT + 300)
			#define OPERATE_ARM_21_5_2		(AUTO_ROBOT_HIGH_PARALLEL + 370)
			
			//step 22		ディスクつかむ高さ調整(赤コート)
			#define OPERATE_ARM_22_1			580
			#define OPERATE_ARM_22_2			95.0
			#define OPERATE_ARM_22_3			0.0
			#define OPERATE_ARM_22_4			0.0
			#define OPERATE_ARM_22_5			(AUTO_ROBOT_HIGH_PARALLEL + 370 )
						//step 23		アーム離す
			//step 24		回収高さ調整
			//step 25		子供ロボット回収
			#define OPERATE_ARM_23_1_0			580.0
			#define OPERATE_ARM_23_1_1		580
			#define OPERATE_ARM_23_2_0		95.0
			#define OPERATE_ARM_23_2_1		60.0
			#define OPERATE_ARM_23_3			0.0
			#define OPERATE_ARM_23_4			0.0
			#define OPERATE_ARM_23_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 370.0)		//未使用
			#define OPERATE_ARM_23_5_1		(AUTO_ROBOT_HIGH_PARALLEL + 370.0 - 5 - 10)		//
			#define OPERATE_ARM_23_5_2		(AUTO_ROBOT_HIGH_PARALLEL + 280.0)		//
			
			//step 26		アーム引く(赤コート)
			#define OPERATE_ARM_26_1_0		350.0
			#define OPERATE_ARM_26_1_1		INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_26_2_0		60.0
			#define OPERATE_ARM_26_2_1		0.0
			#define OPERATE_ARM_26_3_0		0.0
			#define OPERATE_ARM_26_3_1		88	//90.0	//85.0
			#define OPERATE_ARM_26_4			0.0
			#define OPERATE_ARM_26_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 280.0)
			#define OPERATE_ARM_26_5_1		(600 - 20 - 30 -20 - 10)
			
			//step 28		ジャングルジム角度調整(赤コート)
			/*#define OPERATE_ARM_28_1_0		350.0
			#define OPERATE_ARM_28_1_1		150.0
			#define OPERATE_ARM_28_2			0.0
			#define OPERATE_ARM_28_3			85.0
			#define OPERATE_ARM_28_4			0.0
			#define OPERATE_ARM_28_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 250.0)
			#define OPERATE_ARM_28_5_1		(600 - 20 - 30)
			*/
			
			//step 28		ジャングルジムにおろす(赤コート)
			/*#define OPERATE_ARM_28_1			150.0
			#define OPERATE_ARM_28_2			0.0
			#define OPERATE_ARM_28_3			85.0
			#define OPERATE_ARM_28_4			0.0
			#define OPERATE_ARM_28_5			(501.2 - 20 - 30)*/
			//step 30		アーム離す(赤コート)
			#define OPERATE_ARM_27_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_27_2			0.0
			#define OPERATE_ARM_27_3			88	//90.0	//85.0	//77.0	//73.0
			#define OPERATE_ARM_27_4			0.0
			#define OPERATE_ARM_27_5			(600 - 20 -30 - 20 -10)	//(501.2 - 20 -30 )
			
			#define OPERATE_ARM_28_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_28_2			0.0
			#define OPERATE_ARM_28_3			45	//73.0
			#define OPERATE_ARM_28_4			0.0
			#define OPERATE_ARM_28_5			INIT_TOP_ARM_HIGH	//(600 - 20 - 20 - 30 - 47.8)
			
						
	/*************************************************************************/
	/*************************************************************************/
	
	
	
	
	
	
	
	
	
	/************************************************************************/
	//																																				//
	//																青コート																	//
	//																																				//
	/************************************************************************/
	
	#elif COLOR == BLUE
	
			/*************スタート角度、座標(青コート)****************************************/
			#define START_X 		(-92.157)	//-90.0//4243
			#define START_Y 		(-92.157)		//50.0//1544.925
			#define START_DEGREE 		45.0	//-90.0
			
			/************スタートゾーン→シーソー押す位置(青コート)*******************************/
			#define TARGET_TO_SEESAW_DIRECTION_1	20.0			//一つ目の曲線スタート方向角度
			#define TARGET_TO_SEESAW_DIRECTION_2	-55.0		//2つ目の曲線スタート方向角度
			#define TARGET_MIDDLE_X		1500		//曲線の軌跡変更座標
			#define TARGET_MIDDLE_Y		-500
			#define TARGET_TO_SEESAW_X				4243.0		//(4143 - 150.0)//最終目標座標
			#define TARGET_TO_SEESAW_Y				-1550		//1650//1800
			#define TARGET_TO_SEESAW_DEGREE	 	90.0
			#define A_UP_TO_SEESAW				3000	//1800	//加速度
			#define A_DOWN_TO_SEESAW			1800	//1000	//1800	//1500	//減速度
			#define MAX_VELOCITY_TO_SEESAW		2500	//2000	//最高速度
			#define A_UP_OMEGA				600	//角加速度
			#define A_DOWN_OMEGA				600	//角減速度
			#define MAX_OMEGA					400	//最高角速度
			#define ARM_CHANGE_POSITION_0		1000	//上アーム角度変更ｘ座標
			#define ARM_CHANGE_POSITION_1		1750	//アーム高さ、長さ変更ｘ座標
			#define DEGREE_CHANGE_POSITION_0	700	//車体角度変更ｘ座標
			
			/************シーソー置く→押す→回収(青コート)****************************************/
			#define TARGET_SEESAW_X_0					4243.0		//①シーソーに置く地点
			#define TARGET_SEESAW_Y_0					-1650		//1650.0
			#define TARGET_SEESAW_DEGREE_0		90.0
			#define TARGET_SEESAW_X_1					4243.0		//②円弧走行の終点(置く→押す)
			#define TARGET_SEESAW_Y_1					1650		//-1650.0
			#define TARGET_SEESAW_DEGREE_1		-90.0
			#define TARGET_SEESAW_X_2					4243.0		//③押す地点
			#define TARGET_SEESAW_Y_2					1650		//-1650.0
			#define TARGET_SEESAW_DEGREE_2		-90.0
			#define TARGET_SEESAW_X_3					4243.0		//④円弧走行の終点(押す→回収)
			#define TARGET_SEESAW_Y_3					-1650		//1650.0
			#define TARGET_SEESAW_DEGREE_3		90.0
			#define TARGET_SEESAW_CENTER_DEGREE_0		180.0		//円弧走行での回る中心角(行き)
			#define TARGET_SEESAW_CENTER_DEGREE_1		175.0		//円弧走行での回る中心角(帰り)
			//シーソー周りの加速度、最高速度調整
			#define SEESAW_CURVE_A_UP						2500			//シーソー周りの加速度
			#define SEESAW_CURVE_A_DOWN				2500		//シーソー周りの減速度
			#define SEESAW_CURVE_MAX_VELOCITY		3000	//シーソー周りの最高速度
			#define ARM_CHANGE_POSITION_2				-1000		//シーソーアーム伸ばし始めｙ座標
			#define ARM_CHANGE_POSITION_3				1200	//シーソーアーム引きはじめy座標
			#define ARM_CHANGE_POSITION_4				0.0		//上アーム回転、高さ変更ｙ座標
			
			/***********シーソー→ブランコ(青コート)**************************************/
			#define TARGET_TO_SWING_X_0		4243	//スタート座標
			#define TARGET_TO_SWING_Y_0		(-1650)
			#define TARGET_TO_SWING_X_1		7743	//目標座標
			#define TARGET_TO_SWING_Y_1		(-3000)
			#define TARGET_TO_SWING_DIRECTION_DEGREE	(-60.0)		//0.0	//曲線スタート方向角度
			#define TARGET_TO_SWING_DEGREE_0		90.0		//スタート角度
			#define TARGET_TO_SWING_DEGREE_1		(-180.0)			//目標角度①
			#define TARGET_TO_SWING_DEGREE_2	(-90.0)			//目標角度②
			#define A_UP_TO_SWING						1500		//加速度
			#define A_DOWN_TO_SWING				500	//減速度
			#define MAX_VELOCITY_TO_SWING		1500	//最高速度
			#define A_UP_OMEGA_TO_SWING_0		150		//角加速度①			//未使用
			#define A_DOWN_OMEGA_TO_SWING_0		150	//角減速度①
			#define MAX_OMEGA_TO_SWING_0		100	//最高角速度①
			#define A_UP_OMEGA_TO_SWING_1		300	//角加速度②				//未使用
			#define A_DOWN_OMEGA_TO_SWING_1	300	//角減速度②
			#define MAX_OMEGA_TO_SWING_1		200	//最高角速度②
			#define ARM_CHANGE_POSITION_5			5000	//4500		//アーム微調整リセット時ｘ座標
			#define ARM_CHANGE_POSITION_6			6500		//上アーム高さ変更時ｘ座標
			#define DEGREE_CHANGE_POSITION_1	4243	//車体回転し始めｘ座標①
			#define DEGREE_CHANGE_POSITION_2	5300	//車体回転し始めｘ座標②
			
			/*************ブランコ引く(青コート)*****************************************/
			#define TARGET_SWING_X_0		7911.0
			#define TARGET_SWING_Y_0		(-3360.5)
			#define TARGET_SWING_X_1		7911.0
			#define TARGET_SWING_Y_1		(-2820.5)		//(-2760.5)		//2713.11//2597.8//2646.93//2597.8
			#define TARGET_SWING_DEGREE		(-90.0)
			#define A_UP_SWING					350
			#define A_DOWN_SWING			350
			#define MAX_VELOCITY_SWING		400
			#define TARGET_TOP_ARM_LOCK_X		7911		//上アームロック解除x座標
			#define TARGET_TOP_ARM_LOCK_Y		(-4000)	//上アームロック解除ｙ座標
			
			/****************ブランコ→ポール(青コート)*********************************/
			#define TARGET_TO_POLE_X_0			7911
			#define TARGET_TO_POLE_Y_0			(-3450)
			#define TARGET_TO_POLE_X_1			6800	//7000
			#define TARGET_TO_POLE_Y_1			(-2000)	//(-1750)
			#define TARGET_TO_POLE_X_2			6800
			#define TARGET_TO_POLE_Y_2			3000
			#define TARGET_TO_POLE_DIRECTION_DEGREE_0		90
			#define TARGET_TO_POLE_DIRECTION_DEGREE_1		120
			#define A_UP_TO_POLE						1800
			#define A_DOWN_TO_POLE				1400
			#define MAX_VELOCITY_TO_POLE		2000
			#define TARGET_TO_POLE_DEGREE_0		-90.0
			#define TARGET_TO_POLE_DEGREE_1		20.0
			#define A_UP_OMEGA_TO_POLE			200
			#define A_DOWN_OMEGA_TO_POLE		200
			#define MAX_OMEGA_TO_POLE				250
			#define ARM_CHANGE_POSITION_7		(-2500)
			#define ARM_CHANGE_POSITION_8		1500
			#define DEGREE_CHANGE_POSITION_3	(-500.0)
			
			/*************ポール→ジャングルジム(青コート)****************/
			#define TARGET_TO_JUNGLE_X		6300
			#define TARGET_TO_JUNGLE_Y		0.0
			#define TARGET_TO_JUNGLE_DIRECTION_DEGREE		(-110)
			#define A_UP_TO_JUNGLE		1500
			#define A_DOWN_TO_JUNGLE		1500
			#define MAX_VELOCITY_TO_JUNGLE		2000
			#define TARGET_TO_JUNGLE_DEGREE		0.0
			#define A_UP_OMEGA_TO_JUNGLE		80
			#define A_DOWN_OMEGA_TO_JUNGLE		80
			#define MAX_OMEGA_TO_JUNGLE		120
			#define ARM_CHANGE_POSITION_9			4000	//上アーム回転し始めｙ座標	
			#define ARM_CHANGE_POSITION_10		2500	//上アームピッチ回転し始めｙ座標
			#define DEGREE_CHANGE_POSITION_4	3000	//車体回転し始めｙ座標
			
			
			/********アーム目標長さ、高さ（青コート）*****************/
			//		①OPERATE_ARM_(ステップ)_(アーム動作番号)
			
			//		②アーム動作番号　1:上アーム長さ	2：上アーム回転	3：上アームピッチ回転		4:シーソーアーム長さ	5：アーム高さ
			
			//		③追加はさらに後ろにアンダーバーを入れて番号0から
		
		
			//step 0	初期状態(青コート)
			//アームはすべて初期状態
			#define OPERATE_ARM_0_5_0		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_0_5_1		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_0_5_2		(TARGET_TOP_ARM_LIFT_6 + 100)	//ブランコ時にリトライ
			#define OPERATE_ARM_0_5_3		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_0_5_4		(TARGET_TOP_ARM_LIFT_6 + 100)	//ジャングルジム時にリトライ
			
			//step 1		子供ロボット保持用意(青コート)
			//step 2		子供ロボット保持（step  1と同じ）
			#define OPERATE_ARM_1_1			285.0
			#define OPERATE_ARM_1_2			0.0
			#define OPERATE_ARM_1_3			0.0
			#define OPERATE_ARM_1_4			0.0
			#define OPERATE_ARM_1_5_0		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_1_5_1		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_1_5_2		(TARGET_TOP_ARM_LIFT_6 + 100)
			#define OPERATE_ARM_1_5_3		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_1_5_4		(TARGET_TOP_ARM_LIFT_6 + 100)
			
			//step 3		スタートからシーソーに向かう(青コート)
			#define OPERATE_ARM_3_1_0		285.0
			#define OPERATE_ARM_3_1_1		480.0
			#define OPERATE_ARM_3_2_0		0.0
			#define OPERATE_ARM_3_2_1		90.0
			#define OPERATE_ARM_3_3			0.0
			#define OPERATE_ARM_3_4			0.0
			#define OPERATE_ARM_3_5_0		(TARGET_TOP_ARM_LIFT_6 + 30)
			#define OPERATE_ARM_3_5_1		(TARGET_TOP_ARM_LIFT_2 - 40)
			//step 4		シーソーに置く(青コート)
			#define OPERATE_ARM_4_1			480.0
			#define OPERATE_ARM_4_2			90.0
			#define OPERATE_ARM_4_3			10.0
			#define OPERATE_ARM_4_4			0.0
			#define OPERATE_ARM_4_5			(TARGET_TOP_ARM_LIFT_1 + 30 + 10)
			//step 5		シーソー押す位置まで移動(青コート)
			#define OPERATE_ARM_5_1_0		480.0
			#define OPERATE_ARM_5_1_1		580.0
			#define OPERATE_ARM_5_2			90.0
			#define OPERATE_ARM_5_3_0		10.0
			#define OPERATE_ARM_5_3_1		0.0
			#define OPERATE_ARM_5_4_0		0.0
			#define OPERATE_ARM_5_4_1		470	//420.0
			#define OPERATE_ARM_5_5_0		(TARGET_TOP_ARM_LIFT_1 + 30 + 10)
			#define OPERATE_ARM_5_5_1		(TARGET_SEESAW_ARM_LIFT_1 + 50)
			//step 6　	シーソー押す(青コート)
			//step 8
			//step 10
			#define OPERATE_ARM_6_1			580
			#define OPERATE_ARM_6_2			90.0
			#define OPERATE_ARM_6_3			0.0
			#define OPERATE_ARM_6_4			470	//420
			#define OPERATE_ARM_6_5			(TARGET_SEESAW_ARM_LIFT_3 - 50)
			//step 7		シーソー引く(青コート)
			//step 9		
			#define OPERATE_ARM_7_1			580
			#define OPERATE_ARM_7_2			90.0
			#define OPERATE_ARM_7_3			0.0
			#define OPERATE_ARM_7_4			470	//420.0
			#define OPERATE_ARM_7_5			(TARGET_SEESAW_ARM_LIFT_2 + 40)
			//step 11		シーソーから回収位置まで移動(青コート)
			#define OPERATE_ARM_11_1_0		580.0
			#define OPERATE_ARM_11_1_1		480.0
			#define OPERATE_ARM_11_2_0		90.0
			#define OPERATE_ARM_11_2_1		(-90.0)		//-80
			#define OPERATE_ARM_11_3			10.0
			#define OPERATE_ARM_11_4_0		470	//420.0
			#define OPERATE_ARM_11_4_1		0.0
			#define OPERATE_ARM_11_5_0		(TARGET_SEESAW_ARM_LIFT_1 + 50)
			#define OPERATE_ARM_11_5_1		(TARGET_TOP_ARM_LIFT_1 + 30.0 + 10)
			
			//step 12		子供ロボット回収＋ブランコに向かう(青コート)
			#define OPERATE_ARM_12_1_0		480.0
			#define OPERATE_ARM_12_1_1		300.0		//350
			#define OPERATE_ARM_12_2_0		(-90.0)		//-80
			#define OPERATE_ARM_12_2_1		0.0
			#define OPERATE_ARM_12_3_0		10.0
			#define OPERATE_ARM_12_3_1		0.0
			#define OPERATE_ARM_12_4			0.0
			#define OPERATE_ARM_12_5_0		(TARGET_TOP_ARM_LIFT_1 + 30.0 + 10)
			#define OPERATE_ARM_12_5_1		(TARGET_TOP_ARM_LIFT_1 + 70.0 + 10)
			#define OPERATE_ARM_12_5_2		TARGET_TOP_ARM_LIFT_2
			
			//step 13		ブランコ上空侵入(青コート)
			#define OPERATE_ARM_13_1			610.0
			#define OPERATE_ARM_13_2			0.0
			#define OPERATE_ARM_13_3			0.0
			#define OPERATE_ARM_13_4			0.0
			#define OPERATE_ARM_13_5			(TARGET_TOP_ARM_LIFT_2 + 25)
			//step 14		ブランコにおろす(青コート)
			//step 20		子供ロボット保持
			#define OPERATE_ARM_14_1			610.0
			#define OPERATE_ARM_14_2			0.0
			#define OPERATE_ARM_14_3			0.0
			#define OPERATE_ARM_14_4			0.0
			#define OPERATE_ARM_14_5			(TARGET_TOP_ARM_LIFT_7 - 10)
			//step 15		アーム放す(青コート)
			//step 19		子供ロボット保持高さ調整
			#define OPERATE_ARM_15_1_0			610.0
			#define OPERATE_ARM_15_1_1			610
			#define OPERATE_ARM_15_2			0.0
			#define OPERATE_ARM_15_3			0.0
			#define OPERATE_ARM_15_4			0.0
			#define OPERATE_ARM_15_5			(TARGET_TOP_ARM_LIFT_7 - 10)
			//step 16		上アーム引く＋ブランコアームのばす(青コート)
			#define OPERATE_ARM_16_1			120.0
			#define OPERATE_ARM_16_2			0.0
			#define OPERATE_ARM_16_3			0.0
			#define OPERATE_ARM_16_4_0		0.0
			#define OPERATE_ARM_16_4_1		460	//430
			#define OPERATE_ARM_16_5_0		(TARGET_TOP_ARM_LIFT_7 - 10)
			#define OPERATE_ARM_16_5_1		(TARGET_SWING_ARM_LIFT_1 -10)
			//step 17		ブランコつかむ + ブランコ引く(青コート)
			#define OPERATE_ARM_17_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_17_2			0.0
			#define OPERATE_ARM_17_3			0.0
			#define OPERATE_ARM_17_4_0		460	//430
			#define OPERATE_ARM_17_4_1		(190)
			#define OPERATE_ARM_17_5_0		(TARGET_SWING_ARM_LIFT_1 -10)
			#define OPERATE_ARM_17_5_1		TARGET_SWING_ARM_LIFT_2
			//step 18		ブランコ放す(青コート)
			#define OPERATE_ARM_18_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_18_2			0.0
			#define OPERATE_ARM_18_3			0.0
			#define OPERATE_ARM_18_4			(190)
			#define OPERATE_ARM_18_5			TARGET_SWING_ARM_LIFT_2
			
			//step 21		ブランコからポールに向かう(青コート)
			#define OPERATE_ARM_21_1			350
			#define OPERATE_ARM_21_2_0		0.0
			#define OPERATE_ARM_21_2_1		60.0
			#define OPERATE_ARM_21_3			0.0
			#define OPERATE_ARM_21_4			0.0
			#define OPERATE_ARM_21_5_0		(TARGET_TOP_ARM_LIFT_2)
			#define OPERATE_ARM_21_5_1		(TARGET_TOP_ARM_LIFT_6 + 30 + 100)
			#define OPERATE_ARM_21_5_2		(TARGET_TOP_ARM_LIFT_4 - 20)
			
			//step 22		ディスクつかむ高さ調整(青コート)
			#define OPERATE_ARM_22_1			(610 - 70)	//(610 - 100)
			#define OPERATE_ARM_22_2			60.0	//(-90.0)
			#define OPERATE_ARM_22_3			0.0
			#define OPERATE_ARM_22_4			0.0
			#define OPERATE_ARM_22_5			(TARGET_TOP_ARM_LIFT_4 - 20.0 - 30)
			
			//step 23		子供ロボット平衡状態(青コート)
			//step 24		アーム離す
			//step 25		回収高さ調整
			//step 26		子供ロボット回収
			#define OPERATE_ARM_23_1_0		(610 - 70)	//(610.0 - 100)
			#define OPERATE_ARM_23_1_1			610
			#define OPERATE_ARM_23_2_0		60.0	//(-90.0)
			#define OPERATE_ARM_23_2_1		100.0
			#define OPERATE_ARM_23_3			0.0
			#define OPERATE_ARM_23_4			0.0
			#define OPERATE_ARM_23_5_0		(TARGET_TOP_ARM_LIFT_4 - 20.0 - 30)	//未使用
			#define OPERATE_ARM_23_5_1		(TARGET_TOP_ARM_LIFT_4 - 20.0 - 30 - 5)	//(AUTO_ROBOT_HIGH_PARALLEL + 325.0)
			#define OPERATE_ARM_23_5_2		(AUTO_ROBOT_HIGH_PARALLEL + 280.0)
			
			//step 27		アーム引く(青コート)
			#define OPERATE_ARM_26_1_0		350.0
			#define OPERATE_ARM_26_1_1		INIT_TOP_ARM_LENGTH		//120.0
			#define OPERATE_ARM_26_2_0		100.0
			#define OPERATE_ARM_26_2_1		0.0
			#define OPERATE_ARM_26_3_0		0.0
			#define OPERATE_ARM_26_3_1		88	//90	//86	//85.0	//82.0	//85.0
			#define OPERATE_ARM_26_4			0.0
			#define OPERATE_ARM_26_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 280.0)
			#define OPERATE_ARM_26_5_1		(600 - 20 - 30 -20 - 10)
			
			//step 28		ジャングルジム角度調整(青コート)
			/*#define OPERATE_ARM_28_1_0		350.0
			#define OPERATE_ARM_28_1_1		150.0
			#define OPERATE_ARM_28_2			0.0
			#define OPERATE_ARM_28_3			85.0
			#define OPERATE_ARM_28_4			0.0
			#define OPERATE_ARM_28_5_0		(AUTO_ROBOT_HIGH_PARALLEL + 250.0)
			#define OPERATE_ARM_28_5_1		(600 - 20 - 30)*/
			
			//step 28		ジャングルジムにおろす(青コート)
			/*#define OPERATE_ARM_28_1			150.0
			#define OPERATE_ARM_28_2			0.0
			#define OPERATE_ARM_28_3			85.0
			#define OPERATE_ARM_28_4			0.0
			#define OPERATE_ARM_28_5			(501.2 - 20 - 30)*/
			
			//step 28		アーム離す(青コート)
			#define OPERATE_ARM_27_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_27_2			0.0
			#define OPERATE_ARM_27_3			88	//90	//86	//77	//76	//82.0		//85.0
			#define OPERATE_ARM_27_4			0.0
			#define OPERATE_ARM_27_5			(600 - 20 -30 -20 - 10)
			
			#define OPERATE_ARM_28_1			INIT_TOP_ARM_LENGTH
			#define OPERATE_ARM_28_2			0.0
			#define OPERATE_ARM_28_3			45	//73.0
			#define OPERATE_ARM_28_4			0.0
			#define OPERATE_ARM_28_5			INIT_TOP_ARM_HIGH	//(600 - 20 - 20 - 30 - 47.8)
			
	#endif
	
	
//足回り角度ロックゲイン
#if ENCODER_CALIBRATION_MODE == ON
	#define KP_DEGREE_LOCK			10.0	//5.0//0.7//5.0//10.0//7.0		//足回りの角度ロックｐゲイン
	#define KD_DEGREE_LOCK			45.0	//20.0//3.6//20//45.0//36.0		//足回りの角度ロックｄゲイン
#else
	#define KP_DEGREE_LOCK			5.0	//0.7//5.0//10.0//7.0		//足回りの角度ロックｐゲイン
	#define KD_DEGREE_LOCK			20.0	//3.6//20//45.0//36.0		//足回りの角度ロックｄゲイン
#endif
//シーソー周りのゲイン調整
	#define KP_SEESAW_RADIUS_LOCK		4.0	//シーソー周りの半径ロックｐゲイン
	#define KD_SEESAW_RADIUS_LOCK		20.0	//シーソー周りの半径ロックｄゲイン
	#define KP_SEESAW_PHASE_VELOCITY 	0.3	//シーソー周りの位相速度のｐゲイン
	#define KP_SEESAW_CURVE_DEGREE		30.0	//15.0//35.0	//シーソー中心方向角度ロックpゲイン
	#define KD_SEESAW_CURVE_DEGREE		80.0	//40.0//150.0//シーソー中心方向角度ロックdゲイン
#define KP_OMEGA					0.6	//角速度
#define KD_OMEGA					2.0

//アームゲイン調整
#define KP_LIFT_ARM_UP 				3.50		//リフトアーム上方向ｐゲイン
#define KD_LIFT_ARM_UP 				10.0		//リフトアーム上方向ｄゲイン
#define KP_LIFT_ARM_DOWN 		1.5		//リフトアーム下方向ｐゲイン
#define KD_LIFT_ARM_DOWN 		5.0		//リフトアーム下方向ｄゲイン
#define KP_LIFT_ARM_LOCK 			2.5		//リフトアームポジションロックｐゲイン
#define KD_LIFT_ARM_LOCK 		9.0		//リフトアームポジションロックｄゲイン
#define KP_TOP_ARM_LENGTH 		0.3		//上アーム長さｐゲイン
#define KD_TOP_ARM_LENGTH 	2.0		//上アーム長さｄゲイン
#define KP_TOP_ARM_LENGTH_LOCK 		0.07		//上アーム長さロックｐゲイン
#define KD_TOP_ARM_LENGTH_LOCK 		3.0		//上アーム長さロックｄゲイン
#define KP_TOP_ARM_TURN 			1.0		//上アーム回転ｐゲイン
#define KD_TOP_ARM_TURN 		4.0		//上アーム回転ｄゲイン
#define KP_SEESAW_ARM_LENGTH 			2.0		//シーソーアーム長さｐゲイン
#define KD_SEESAW_ARM_LENGTH 			10.0		//シーソーアーム長さｄゲイン
#define KP_TOP_ARM_TILT 	20	//15.0			//上アーム傾きｐゲイン
#define KD_TOP_ARM_TILT 	50.0			//上アーム傾きｄゲイン

#define LIMIT_TOP_ARM_GAP 	3	//上アームの許容範囲
#define LIMIT_SEESAW_ARM_GAP		3	//シーソーアーム許容範囲
	
//マニュアル操作のときの各アーム出力(±は必要なし)
#define MANUAL_TOP_ARM_FRONT	60
#define MANUAL_TOP_ARM_BACK	60
#define MANUAL_TOP_ARM_CW		30
#define MANUAL_TOP_ARM_CCW	30
#define MANUAL_SEESAW_ARM_PUSH		70
#define MANUAL_SEESAW_ARM_PULL		70
#define MANUAL_LIFT_ARM_UP		95
#define MANUAL_LIFT_ARM_DOWN	95

#define STICK_NO_MOVE_RANGE		64.0		//足回りが動かないスティックの値の範囲

#define HIGH_MANUAL_PERCENTAGE		60.0		//足回り操作最大パーセンテージ	
#define LOW_MANUAL_PERCENTAGE		40.0		//足回り操作最小パーセンテージ
#define HIGH_MANUAL_PERCENTAGE_TURN	30.0		//足回り操作回転最大パーセンテージ
#define LOW_MANUAL_PERCENTAGE_TURN		15.0		//足回り操作回転最小パーセンテージ

//エンコーダ
#define ENCORDER_DISTANCE 			237	//345.11	//中心からエンコーダまでの距離
#define ENCORDER_DIVISION 			2000		//エンコーダの一周カウント数
#define FRONT_ENCORDER_DIAMETER 	(51.10099)		//51.09329			//51.10193		//51.10099		//51.1236	
#define LEFT_ENCORDER_DIAMETER		(49.85768666)	//49.94239666		//49.97312666	//49.85768666			
#define RIGHT_ENCORDER_DIAMETER 	(50.08606333)	//50.06361333		//50.08606333	//50.09424333	
#define FRONT_ENCORDER_CIRCUMFERENCE		(FRONT_ENCORDER_DIAMETER * M_PI)
#define LEFT_ENCORDER_CIRCUMFERENCE 		(LEFT_ENCORDER_DIAMETER * M_PI)	//左エンコーダ円周
#define RIGHT_ENCORDER_CIRCUMFERENCE 		(RIGHT_ENCORDER_DIAMETER * M_PI)	//右エンコーダ円周
#define VERTEX_CENTER_DISTANCE		(ENCORDER_DISTANCE * 2.0)		//中心から三角形の頂点までの距離
#define LIFT_ARM_ENCORDER_DIVISION		400		//リフトアームのエンコーダ1周カウント数
#define LIFT_ARM_ENCORDER_DIAMETER	30.32		//リフトアームのエンコーダのギアの直径
#define LIFT_ARM_ENCORDER_CIRCUMFERENCE		(LIFT_ARM_ENCORDER_DIAMETER * M_PI) //リフトアームのエンコーダギアの円周
#define MTU1_ENCODER_VALUE		MTU1.TCNT
#define MTU2_ENCODER_VALUE		MTU2.TCNT
#define MTU7_ENCODER_VALUE		MTU7.TCNT
#define MTU8_ENCODER_VALUE		MTU8.TCNT

//モータ
#define BRAKE 	1000
	//足回り関係
	#define LIMIT_MOTOR_DUTY_TIRE 	99	//足回りの最大出力
	#define LEFT_TIRE_CW				PORT9.DR.BIT.B2	//PORT9.DR.BIT.B3
	#define LEFT_TIRE_CCW			PORT9.DR.BIT.B1	//PORT9.DR.BIT.B0
	#define LEFT_TIRE_DUTY			MTU10.TGRD				//MTU10.TGRB
	#define RIGHT_TIRE_CW			PORT9.DR.BIT.B3	//PORT9.DR.BIT.B1
	#define RIGHT_TIRE_CCW			PORT9.DR.BIT.B0	//PORT9.DR.BIT.B2
	#define RIGHT_TIRE_DUTY		MTU10.TGRB	//MTU10.TGRD
	#define BACK_TIRE_CW 			PORT7.DR.BIT.B0
	#define BACK_TIRE_CCW			PORT7.DR.BIT.B2
	#define BACK_TIRE_DUTY			MTU6.TGRB
	//アーム関係
	#define LIMIT_MOTOR_DUTY_ARM	70	//アームの最大出力
	#define LIFT_ARM_UP					PORT7.DR.BIT.B3
	#define LIFT_ARM_DOWN			PORT7.DR.BIT.B1
	#define LIFT_ARM_DUTY			MTU6.TGRD
	#define SEESAW_ARM_PUSH		PORT7.DR.BIT.B5	//PORTB.DR.BIT.B3
	#define SEESAW_ARM_PULL		PORT7.DR.BIT.B7	//PORTB.DR.BIT.B7
	#define SEESAW_ARM_DUTY		MTU4.TGRD	//MTU9.TGRD
	#define TOP_ARM_TILT				PORTB.DR.BIT.B7
	#define TOP_ARM_PARALLEL		PORTB.DR.BIT.B3
	#define TOP_ARM_TILT_DUTY	MTU9.TGRD
	#define TOP_ARM_PUSH			PORT7.DR.BIT.B6	//PORTB.DR.BIT.B6
	#define TOP_ARM_PULL				PORT7.DR.BIT.B4	//PORTB.DR.BIT.B2
	#define TOP_ARM_DUTY			MTU4.TGRB	//MTU9.TGRB
	#define TOP_ARM_CW				PORTB.DR.BIT.B2
	#define TOP_ARM_CCW				PORTB.DR.BIT.B6
	#define TOP_ARM_TURN_DUTY		MTU9.TGRB

//AD変換関係
#define POTENTIO_TOP_ARM_LENGTH_CH		6
#define POTENTIO_TOP_ARM_DEGREE_CH		0
#define POTENTIO_TOP_ARM_TILT_CH				2
#define POTENTIO_SEESAW_ARM_CH				4

#define POTENTIO_DIRECTION_TOP_ARM_LENGTH 			FRONT	//上アームのポテンショの向き
#define POTENTIO_DIRECTION_TOP_ARM_DEGREE				FRONT	//上アームの回転のポテンショの向き	
#define POTENTIO_DIRECTION_TOP_ARM_TILT					FRONT	//上アームの傾きポテンショの向き	
#define POTENTIO_DIRECTION_SEESAW_ARM_LENGTH		FRONT	//シーソーアームのポテンショの向き
#define TOP_ARM_MOVABLE_AD							653	//359//325//798//347//798//707
#define TOP_ARM_MOVABLE_MM							503.5	//613.5
#define TOP_ARM_MOVABLE_TURN_AD				808	//807//817//780//625//600//748//780//793//608//793//791//758
#define TOP_ARM_MOVABLE_TURN_DEGREE		270.0	//180.0
#define TOP_ARM_MOVABLE_TILT_AD					403	//394//230.0
#define TOP_ARM_MOVABLE_TILT_DEGREE			90.0
#define SEESAW_ARM_MOVABLE_AD					317	//680//388//386//663//384//663
#define SEESAW_ARM_MOVABLE_MM					438

#define LED_RED		PORT2.DR.BIT.B2
#define LED_BLUE		PORT1.DR.BIT.B7		
#define LED_GREEN	PORT2.DR.BIT.B4

//電磁弁
#define AR_SEESAW_PUSH        	PORT5.DR.BIT.B6	//シーソー押す
#define AR_SWING_CATCH			PORT6.DR.BIT.B0	//ブランコつかむ
#define AR_TOP_ARM_LOCK			PORT3.DR.BIT.B2	//上アームロック解除
#define AR_TOP_CATCH					PORT1.DR.BIT.B4	//子供ロボット保持（OFF:閉じる	ON:開く）
//リミットスイッチ
#define LIMIT_SW_LIFT_ARM_HIGH 				PORTD.PORT.BIT.B0
#define LIMIT_SW_LIFT_ARM_LOW 				PORTD.PORT.BIT.B3
#define LIMIT_SW_TOP_ARM_FRONT			PORTD.PORT.BIT.B6
#define LIMIT_SW_TOP_ARM_BACK				PORTD.PORT.BIT.B2
#define LIMIT_SW_SEESAW_ARM_FRONT		PORTD.PORT.BIT.B5
#define LIMIT_SW_SEESAW_ARM_BACK		PORTD.PORT.BIT.B7
//ブザー
#define BUZZER		PORT5.DR.BIT.B0
//シリアル通信
#define MODE_SCIDATA_BOX 	6
	#if MODE_SCIDATA_BOX != OFF
	float	g_sci1 = 0.0,g_sci2 = 0.0,g_sci3 = 0.0,g_sci4 = 0.0,
		g_sci5 = 0.0,g_sci6 = 0.0,g_sci7 = 0.0,g_sci8 = 0.0;
	#endif
/*#define END '#'						//データの終端文字
#define CHECK '@'					//チェックモード指令
#define SAFETY '^'					//緊急停止
#define RECEIVE_STR_ROW_SUB 3		//サブマイコンから定周期で受信する予定のデータ数
#define RECEIVE_STR_ROW_PC 1		//PCから定周期で受信する予定のデータ数
#define RECEIVE_STR_COLUMN 10		//1データあたりの最大文字数		例: a123# (6文字)

float g_atoz_value[26] = {0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 
                                0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 
                                0.00, 0.00, 0.00, 0.00, 0.00, 0.00};
float g_AtoZ_value[26] = {0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 
                                0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 
                                0.00, 0.00, 0.00, 0.00, 0.00, 0.00};
char g_receive_str_sub[RECEIVE_STR_ROW_SUB][RECEIVE_STR_COLUMN],
	g_receive_str_pc[RECEIVE_STR_ROW_PC][RECEIVE_STR_COLUMN];*/
	
//グローバル変数
int	g_interrupt_timer_count = 0,	
		g_timer_all = 0,
		g_over_under_flow_count_MTU1 = 0,
		g_over_under_flow_count_MTU2 = 0,
		g_over_under_flow_count_MTU7 = 0,
		g_over_under_flow_count_MTU8 = 0,
		g_left_motor_timer_count = 0,
		g_right_motor_timer_count = 0,
		g_back_motor_timer_count = 0,
 		g_flag_safety = 0,
		g_flag_catch_from_swing = 0,
		g_buzzer_io = 0;
float	g_init_ad[4] = {0},
		g_now_ad[4] = {0},
		g_ad_att[8] ={0}, 
		/*g_velocity_x = 0.0,	g_velocity_y = 0.0,*/
		g_velocity = 0.0,
		g_omega = 0.0,
		g_accele = 0.0,
		g_x_start = START_X,		g_y_start = START_Y,
		g_x_c = 0.0,				g_y_c = 0.0,
		g_radian = 0.0,			g_degree = 0.0,/*	g_direction_degree = 0.0,*/
		g_vertex_b_x = 0.0,	g_vertex_b_y = 0.0,
		g_vertex_l_x = 0.0,		g_vertex_l_y = 0.0,
		g_vertex_r_x = 0.0,	g_vertex_r_y = 0.0,
		g_x_c_top_arm = 0.0,	g_y_c_top_arm = 0.0,	g_z_c_top_arm = INIT_TOP_ARM_HIGH,
		g_top_arm_length = INIT_TOP_ARM_LENGTH,
		g_top_arm_degree = 0.0,
		g_top_arm_tilt_degree = 0.0,
		/*g_x_c_seesaw_arm = 0.0,	g_y_c_seesaw_arm = 0.0,*/
		g_z_c_seesaw_arm = INIT_SEESAW_ARM_HIGH,	g_seesaw_arm_length = 0.0,
		/*g_x_c_swing_arm = 0.0,	g_y_c_swing_arm = 0.0,*/
		g_z_c_swing_arm = INIT_SWING_ARM_HIGH,
		g_motor_output_l = 0.0,
		g_motor_output_r = 0.0,
		g_motor_output_b = 0.0,
		g_top_arm_velocity = 0.0,
		g_top_arm_turn_omega = 0.0,
		g_top_arm_velocity_z = 0,
		g_seesaw_arm_velocity_z = 0,
		g_swing_arm_velocity_z = 0.0,
		g_x_c_fan_l = 0.0,		g_y_c_fan_l = 0.0,
		g_x_c_fan_r = 0.0,		g_y_c_fan_r = 0.0,
		g_x_c_fan_b = 0.0,		g_y_c_fan_b = 0.0,
		g_x_c_fulcrum = 0.0,	g_y_c_fulcrum = 0.0;
		
#if COLOR == RED
const float g_target_seesaw_x_2 = 4243,
				g_target_seesaw_y_2 = -1650,
				g_target_seesaw_degree_2 = 90.0;
#elif COLOR == BLUE
const float g_target_seesaw_x_2 = 4243,
				g_target_seesaw_y_2 = 1650,
				g_target_seesaw_degree_2 = -90.0;
#endif
		
	
	union psdate1{
		unsigned long dword;
		struct{
			unsigned char byte1;
			unsigned char model_number;
			unsigned char byte3;
			unsigned char select_sw:1;
			unsigned char l3_sw:1;
			unsigned char r3_sw:1;
			unsigned char start_sw:1;
			unsigned char up_sw:1;
			unsigned char right_sw:1;
			unsigned char down_sw:1;
			unsigned char left_sw:1;
		}byte;
	};
	union psdate2{
		unsigned long dword;
		struct{
			unsigned char l2_sw:1;
			unsigned char r2_sw:1;
			unsigned char l1_sw:1;
			unsigned char r1_sw:1;
			unsigned char triangle_sw:1;
			unsigned char circle_sw:1;
			unsigned char cross_sw:1;
			unsigned char square_sw:1;
			unsigned char right_stick_wide;
			unsigned char right_stick_high;
			unsigned char left_stick_wide;
		}byte;
	};
	union psdate3{
		unsigned long dword;
		struct{
			unsigned char left_stick_high;
		}byte;
	};
volatile unsigned long	g_controller_receive_1st	= 0;	//コントローラから帰ってくるデータの格納フォルダ1stは不定でよい。
volatile unsigned long	g_controller_receive_2nd	= 0;
volatile unsigned long	g_controller_receive_3rd	= 0;
int 	getdate1 = 0, getdate2 = 0, getdate3 = 0;

/******************************************************************************
*	タイトル ： システムクロック、周辺クロックの周波数選択
*	  関数名 ： init_clock
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
void init_clock(void)
{
	SYSTEM.SCKCR.BIT.ICK = 0;//システムクロック  96MHz
	SYSTEM.SCKCR.BIT.PCK = 1;//周辺クロック  48MHz
}
/******************************************************************************
*	タイトル ： CMT0の設定
*	  関数名 ： init_CMT0
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
void init_CMT0(void)
{
	SYSTEM.MSTPCRA.BIT.MSTPA15 = 0;//CMT0のモジュールストップ状態を解除
	CMT.CMSTR0.BIT.STR0 = 0;//カウント停止
	
	CMT0.CMCR.BIT.CKS = 2;//PCLK/128
	CMT0.CMCOR = 375;//48000000/128/1000 = 375
	CMT0.CMCNT = 0;
	CMT0.CMCR.BIT.CMIE = 1;
	IEN(CMT0,CMI0) = 1;//割り込み許可
	IPR(CMT0,CMI0) = 14;//割り込み優先度を最大に
}
void init_CMT1(void)
{
	SYSTEM.MSTPCRA.BIT.MSTPA15 = 0;//CMT0のモジュールストップ状態を解除
	CMT.CMSTR0.BIT.STR1 = 0;//カウント停止
	
	CMT1.CMCR.BIT.CKS = 2;//PCLK/128
	CMT1.CMCOR = 375;//48000000/128/1000 = 375
	CMT1.CMCNT = 0;
	CMT1.CMCR.BIT.CMIE = 1;
	IEN(CMT1,CMI1) = 1;//割り込み許可
	IPR(CMT1,CMI1) = 14;//割り込み優先度を最大に
}

/******************************************************************************
*	タイトル ： IO初期設定
*	  関数名 ： init_Io
*	  戻り値 ： void型 
*	    引数 ： なし
******************************************************************************/
void init_Io(void)
{
    PORT2.DDR.BIT.B2 = ON;			//LED赤
	PORT1.DDR.BIT.B7 = ON;			//LED青
	PORT2.DDR.BIT.B4 = ON;			//LED緑
	PORT0.DDR.BIT.B7 = ON;			//
	PORT5.DDR.BIT.B4 = ON;			//
	
	PORT5.DDR.BIT.B0 = ON;			//Buzzer
	PORT5.DDR.BIT.B1 = OFF;			//
	PORT5.DDR.BIT.B2 = OFF;			//デバッグモード(トグルスイッチ)
	PORT2.DDR.BIT.B3 = ON;			//
	PORT6.DDR.BIT.B5 = OFF;			//
	PORT6.DDR.BIT.B6 = OFF; 		//
	PORT6.DDR.BIT.B7 = OFF;			//完全手動モード(トグルスイッチ)
	PORT5.DDR.BIT.B3 = OFF;			//
	
	PORT0.DDR.BIT.B0 = OFF;			//
	PORT0.DDR.BIT.B1 = OFF;			//
	PORT0.DDR.BIT.B2 = OFF;			//
	PORT0.DDR.BIT.B3 = OFF;			//
	PORT0.DDR.BIT.B5 = OFF;			//
	
	PORT6.DDR.BIT.B2 = OFF;			//
	PORT6.DDR.BIT.B1 = OFF;			//
	PORTC.DDR.BIT.B4 = OFF;			//
	PORTC.DDR.BIT.B5 = OFF;			//
	
	PORT1.DDR.BIT.B4 = ON;			//電磁弁
	PORT2.DDR.BIT.B5 = ON;			//
	PORT3.DDR.BIT.B3 = ON;			//
	PORT3.DDR.BIT.B2 = ON;			//電磁弁
	PORT5.DDR.BIT.B6 = ON;			//電磁弁
	PORT6.DDR.BIT.B0 = ON;			//電磁弁
	
	PORTD.DDR.BIT.B0 = OFF;			//リミットスイッチ
	PORTD.DDR.BIT.B1 = OFF;			//リミットスイッチ
	PORTD.DDR.BIT.B2 = OFF;			//リミットスイッチ
	PORTD.DDR.BIT.B3 = OFF;			//リミットスイッチ
	PORTD.DDR.BIT.B4 = OFF;			//リミットスイッチ
	PORTD.DDR.BIT.B5 = OFF;			//リミットスイッチ
	PORTD.DDR.BIT.B6 = OFF;			//リミットスイッチ
	
	PORTC.DDR.BIT.B0 = OFF;			//Encorder_value
	PORTC.DDR.BIT.B1 = OFF;			//Encorder_value
	PORTC.DDR.BIT.B2 = OFF;			//Encorder_value
	PORTC.DDR.BIT.B3 = OFF;			//Encorder_value
	/*PORT4.ICR.BIT.B0 = ON;
	PORT4.ICR.BIT.B1 = ON;
	PORT4.ICR.BIT.B2 = ON;
	PORT4.ICR.BIT.B3 = ON;
	PORT4.ICR.BIT.B4 = ON;
	PORT4.ICR.BIT.B5 = ON;
	PORT4.ICR.BIT.B6 = ON;
	PORT4.ICR.BIT.B7 = ON;*/
}
/******************************************************************************
*	タイトル ： sci通信初期化
*	  関数名 ： init_Sci
*	  戻り値 ： void型 
*	    引数 ： なし
******************************************************************************/
void init_Sci(void)	//SCI1版
{
	int bit_count = 0;

	SYSTEM.MSTPCRB.BIT.MSTPB30 = 0;	//SCI1モジュールSTOP状態を解除
	
	SCI1.SCR.BYTE		= 0x00;		//シリアルコントロールレジスタ
	
	PORT3.DDR.BIT.B0	= 0;		//
	
	PORT3.ICR.BIT.B0	= 1;		//
	
	/*SCI1.SMR.BYTE		= 0x00;		//シリアルモードレジスタ

	SCI1.BRR			= 25;		//ビットレートレジスタ 
								//9600bps：シリアルモードレジスタ→0x01で77
								//115200bps：25
								//230400bps:21
	
	SCI1.SEMR.BIT.ABCS	= 1;		//調歩同期基本クロックを８サイクルの期間を１ビット期間の転送レートとする
	*/
	SCI1.SEMR.BIT.ABCS	= 1;		//調歩同期基本クロックを８サイクルの期間を１ビット期間の転送レートとする
	
	#if BITRATE_1 == 9600
		SCI1.SMR.BYTE		= 0x01;	
	#else
		SCI1.SMR.BYTE		= 0x00;	
	#endif
	
	SCI1.BRR = ((48*1000000)/((64/(1+SCI1.SEMR.BIT.ABCS))*powf(2,2*SCI1.SMR.BIT.CKS-1)*BITRATE_1)-1);	
	for( bit_count = 0; bit_count < 0x800000; bit_count++ ){	//１ビット待つため
	}
	
	SCI1.SCR.BYTE		= 0x30;		//送受信動作を許可	
}
/******************************************************************************
*	タイトル ： sci通信初期化(割り込み)
*	  関数名 ： init_Sci_2
*	  戻り値 ： void型 
*	    引数 ： なし
******************************************************************************/
void init_Sci_2(void)//追加
{
	int bit_count = 0;	
	
	SYSTEM.MSTPCRB.BIT.MSTPB29 = 0;	//SCI1モジュールSTOP状態を解除
	SCI2.SCR.BYTE		= 0x00;		//シリアルコントロールレジスタ
										//河原 0x01→0x00 で通信速度を最大に．分周1
	PORT1.DDR.BIT.B2	= 0;		//
	PORT1.ICR.BIT.B2	= 1;		//
	PORT1.DDR.BIT.B3 	= 0;	//追加
	PORT1.ICR.BIT.B3 	= 1;	//追加
	
	//SCI2.BRR		= 12;		//ビットレートレジスタ77  9600bpsなら0x01の77
									//河原77→12 通信速度を230400bpsに設定
	SCI2.SEMR.BIT.ABCS	= 1;		//調歩同期基本クロックを８サイクルの期間を１ビット期間の転送レートとする
	
	#if BITRATE_2 == 9600
		SCI2.SMR.BYTE		= 0x01;	
	#else
		SCI2.SMR.BYTE		= 0x00;	
	#endif
	
	SCI2.BRR = ((48*1000000)/((64/(1+SCI2.SEMR.BIT.ABCS))*powf(2,2*SCI2.SMR.BIT.CKS-1)*BITRATE_2)-1);
	
	for( bit_count = 0; bit_count < 0x800000; bit_count++ ){	//１ビット待つため
	}
	SCI2.SCR.BYTE		= 0x70;		//送受信動作を許可
	
	IEN(SCI2,RXI2) = 1;
	IPR(SCI2,RXI2) = 11;
}
/******************************************************************************
*	タイトル ： 文字送信
*	  関数名 ： Transmit_uart_c
*	  戻り値 ： void型 
*	   引数1 ： char型 character  
******************************************************************************/
void Transmit_uart_c(char character)
{
	while(SCI1.SSR.BIT.TDRE == 0);//箱TDRの中にデータが残っていればフラグ=1  出てくまで待つ
	SCI1.TDR=character;//データを書き込み（ライト）
	SCI1.SSR.BIT.TDRE = 0;
	while( SCI1.SSR.BIT.TEND == 0 );
}
/******************************************************************************
*	タイトル ： 文字送信(P12,P13)
*	  関数名 ： Transmit_uart_c
*	  戻り値 ： void型 
*	   引数1 ： char型 character  
******************************************************************************/
void Transmit_uart_c_2(char character)
{
	while(SCI2.SSR.BIT.TDRE == 0);//箱TDRの中にデータが残っていればフラグ=1  出てくまで待つ
	SCI2.TDR=character;//データを書き込み（ライト）
	SCI2.SSR.BIT.TDRE = 0;
	while( SCI2.SSR.BIT.TEND == 0 );
}
/******************************************************************************
*	タイトル ： 文字列を文字送信関数へ送る
*	  関数名 ： String
*	  戻り値 ： void型 
*	   引数1 ： char型 s[]  
******************************************************************************/
void String (char s[])
{
	int i=0;
	while(s[i] != '\0')
	{
		Transmit_uart_c(s[i]);
		i++;
	}
}
/******************************************************************************
*	タイトル ： p12,p13で文字列を文字送信関数へ送る
*	  関数名 ： String
*	  戻り値 ： void型 
*	   引数1 ： char型 s[]  
******************************************************************************/
void String_2(char s[])
{
	int i=0;
	while(s[i] != '\0')
	{
		Transmit_uart_c_2(s[i]);
		i++;
	}
}
/******************************************************************************
*	タイトル ：p12,p13で得た受信データを格納し返す
*	  関数名 ： Receive_uart_c
*	  戻り値 ： char型
*	    引数： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
/*char Receive_uart_c(void)
{
	while (SCI2.SSR.BIT.RDRF == 0);		//RDRF = 0：SCRDR に有効な受信データが格納されていないことを表示
	SCI2.SSR.BIT.RDRF = 0;				//RDRFを待機状態に変更	
	return SCI2.RDR;
}*/

//数値データの取出し
/*float pick_out_atoz_value(char character){
    
    int box = 0;
    
    if( (character >= 'a') && (character <= 'z') ){
        box = (int)(character - 'a');
        return ( g_atoz_value[box] );
    }else if( (character >= 'A') && (character <= 'Z') ){
        box = (int)(character - 'A');
        return ( g_AtoZ_value[box] );
    }else{
        return ( 0 );
    }
}

//数値データの書き込み
void throw_away_atoz_value(char character, float write){
    
    int box = 0;
    
    if( (character >= 'a') && (character <= 'z') ){
        box = (int)(character - 'a');
        g_atoz_value[box] = write;
    }else if( (character >= 'A') && (character <= 'Z') ){
        box = (int)(character - 'A');
        g_AtoZ_value[box] = write;
    }
}

//調整可能パラメータ初期値入力関数
void para(void){
	throw_away_atoz_value('A', A_UP_TO_SEESAW);//
	throw_away_atoz_value('B', A_DOWN_TO_SEESAW);//
	throw_away_atoz_value('C', MAX_VELOCITY_TO_SEESAW);//
	throw_away_atoz_value('D', KP_SEESAW_PHASE_VELOCITY);//
	throw_away_atoz_value('E', KP_SEESAW_CURVE_DEGREE);//
	throw_away_atoz_value('F', KD_SEESAW_CURVE_DEGREE);//
	throw_away_atoz_value('G', SEESAW_CURVE_A_UP);//
	throw_away_atoz_value('H', SEESAW_CURVE_A_DOWN);//
	throw_away_atoz_value('I', SEESAW_CURVE_MAX_VELOCITY);//
}

//文字列をint型に変換
int change_int(char *str){
    int n = 0;
    int i = 0;
    while(str[i]!='\0')
    {
        if(str[i]<'0' || str[i]>'9') break;
        n=n*10+str[i]-'0';
        i++;
    }
    return(n);
}*/

//解析した命令に応じて数値を格納する関数
/*void receive_order_depot(int target_box, char *storage_str, int minus_flag, int after_point_count, int large_size_flag){
    
    float value = 0.000;
    
    value = (float)change_int(storage_str);
    
    if(minus_flag == 1){
        value *= ( -1.000 );
    }
    
	//①mbed
    value = value * pow( 0.100, after_point_count );

	//②62N?
	//while(after_point_count > 0){
	///	after_point_count--;
	//		value *= 0.100;
	//}
          
    if( (target_box >= 0) && (target_box <= 25) ){
        if(large_size_flag == 0){
            g_atoz_value[target_box] = value;
        }else{
            g_AtoZ_value[target_box] = value;
        }
    }
}

//一文字ごとに解析する関数
void receive_order_c(char character)
{
    static int target_box = 255;						 //格納命令の開始文字(ASCIIコードのa～z,A～Z)
    static char storage_str[RECEIVE_STR_COLUMN] = "";	 //文字の格納用の文字列
    static int storage_num = 0;							 //文字を文字列のどこに格納するか
    static int minus_flag = 0;							 //マイナス値か否か
    static int point_flag = 0;							 //小数点以下が含まれているか否か
    static int after_point_count = 0;					 //小数点以下にどれだけ数があるか
    static int large_size_flag = 0;						 //大文字なのか否か
    int reset = 0;										 //処理のリセットをするか否か
	const char end = END;								 //格納命令の終了文字
    
    if(character == end){
            storage_str[storage_num] = '\0';
            receive_order_depot(target_box, storage_str, minus_flag, after_point_count, large_size_flag);
            reset = 1;
            target_box = 255;
            large_size_flag = 0;
    }else{
        if( (character >= '0') && (character <= '9') ){
            storage_str[storage_num] = character;
            storage_num++;  
            if( point_flag == 1 ){
                after_point_count++;
            }
        }else if( (character >= 'a') && (character <= 'z') ){
            reset = 1;
            target_box = (int)(character - 'a');
            large_size_flag = 0;
        }else if( (character >= 'A') && (character <= 'Z') ){
            reset = 1;
            target_box = (int)(character - 'A');
            large_size_flag = 1;
        }else if( character == '-' ){
            minus_flag = 1;
        }else if( character == '.' ){
            point_flag = 1;
        }
    }
    
    if( reset == 1 ){
       strcpy(storage_str,"");
       storage_num = 0;
       minus_flag = 0;
       point_flag = 0;
       after_point_count = 0;
    }    
}

//文字列単位で解析する関数
void receive_order_s(char *word)
{
    while(*word != '\0'){
        receive_order_c(*word);
        word++;
    }
}

//5ms、10msの割り込み処理で保存していた文字列を一気に文字解析にかける
void receive_order_solve(void){
    
    int row = 0;
    
    for(row = 0; row < RECEIVE_STR_ROW_SUB; row++){
        receive_order_s(&g_receive_str_sub[row][0]);
    }
	for(row = 0; row < RECEIVE_STR_ROW_PC; row++){
        receive_order_s(&g_receive_str_pc[row][0]);
    }
}

//サブマイコンから来た文字をとりあえず保存しておく
void receive_order_bundle_sub(char character){
    
    static char str[RECEIVE_STR_COLUMN] = "";
    static int row = 0,
                column = 0;
    const char end = END;
    
    str[column] = character;
    if(character == end){
        str[(column + 1)] = '\0';
        strcpy(&g_receive_str_sub[row][0],str);
        strcpy(str, "");
        column = 0;
        row++;
        if(row >= RECEIVE_STR_ROW_SUB) row = 0;
    }else{
        if(column < (RECEIVE_STR_COLUMN - 2)) column++;
    }
}

//PCから来た文字をとりあえず保存しておく
void receive_order_bundle_pc(char character){

	static char str[RECEIVE_STR_COLUMN] = "";
	static int row = 0,
                column = 0;
	const char end = END;

	str[column] = character;
	if(character == end){
        str[(column + 1)] = '\0';
        strcpy(&g_receive_str_pc[row][0],str);
        strcpy(str, "");
        column = 0;
        row++;
        if(row >= RECEIVE_STR_ROW_PC) row = 0;
    }else{
        if(column < (RECEIVE_STR_COLUMN - 2)) column++;
    }
}
//受信割り込み(チェックモード付き)
void receive_att(void){

	char c;
	#if BLUETOOTH_MODE == ON
		int i;
		static int check_mode = 0;
		char str[100];
	#endif
	
	c = Receive_uart_c();//受信データ

	#if BLUETOOTH_MODE == ON//青歯からの受信データ
	
		Transmit_uart_c_2(c);

		if(c == CHECK){	//チェックモード
			if(check_mode == 0){
				check_mode = 1;
				String_2("\r\nCHECK MODE\r\n");
				for(i = 0; i < RECEIVE_STR_ROW_SUB; i++){
					sprintf(str,"[SUB%d:%s]\t", i, &g_receive_str_sub[i][0]);
					String_2(str);
					String_2("\r\n");
				}
				for(i = 0; i < RECEIVE_STR_ROW_PC; i++){
					sprintf(str,"[PC%d:%s]\t", i, &g_receive_str_pc[i][0]);
					String_2(str);
					String_2("\r\n");
				}
				for(i = 0; i < 26; i++){
					sprintf(str,"[%c:%.3f]\t", ('a'+i), g_atoz_value[i]);
					String_2(str);
				}
				for(i = 0; i < 26; i++){
					sprintf(str,"[%c:%.3f]\t", ('A'+i), g_AtoZ_value[i]);
					String_2(str);
				}
				String_2("\r\n");
			}
		}else{
			check_mode = 0;
			if(c == END) String_2("\r\n");
			receive_order_bundle_pc(c);
			if(c == SAFETY){
				g_flag_safety = ON;
			}
		}
	#else//サブマイコンからの受信データ
    		//receive_order_c(c);//←ボーレートが高いと処理が間に合わなくなった。
		receive_order_bundle_sub(c);
	#endif
}*/
/******************************************************************************
*	タイトル ： すべてのエンコーダ設定を行う
*	  関数名 ： init_all_encorder
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
void init_all_encorder(void)
{
	PORTC.ICR.BIT.B6 = 1;	//MTCLKAの入力バッファを有効に
	PORTC.ICR.BIT.B7 = 1;	//MTCLKBの入力バッファを有効に
	PORTC.ICR.BIT.B4 = 1;	//MTCLKCの入力バッファを有効に
	PORTC.ICR.BIT.B5 = 1;	//MTCLKDの入力バッファを有効に
	PORTC.ICR.BIT.B2 = 1;	//MTCLKEの入力バッファを有効に
	PORTC.ICR.BIT.B3 = 1;	//MTCLKFの入力バッファを有効に
	PORTC.ICR.BIT.B0 = 1;	//MTCLKGの入力バッファを有効に
	PORTC.ICR.BIT.B1 = 1;	//MTCLKHの入力バッファを有効に
	
	IOPORT.PFCMTU.BIT.TCLKS = 1;	//PC6,7,4,5をMTCLKn-B端子として設定
	IOPORT.PFDMTU.BIT.TCLKS = 0;	//PC2,3,0,1をMTCLKn-A端子として設定

	SYSTEM.MSTPCRA.BIT.MSTPA9 = 0;
	SYSTEM.MSTPCRA.BIT.MSTPA8 = 0;
	
	MTUA.TSTR.BIT.CST1 = 0;//カウント動作停止
	MTUA.TSTR.BIT.CST2 = 0;//カウント動作停止
	MTUB.TSTR.BIT.CST1 = 0;//カウント動作停止
	MTUB.TSTR.BIT.CST2 = 0;//カウント動作停止
	
	MTU1.TMDR.BIT.MD = 4;//位相計数モード
	MTU2.TMDR.BIT.MD = 4;//位相計数モード
	MTU7.TMDR.BIT.MD = 4;//位相計数モード
	MTU8.TMDR.BIT.MD = 4;//位相計数モード
	
	MTU1.TCR.BIT.CCLR = 0;//TCNTのクリア禁止
	MTU2.TCR.BIT.CCLR = 0;//TCNTのクリア禁止
	MTU7.TCR.BIT.CCLR = 0;//TCNTのクリア禁止
	MTU8.TCR.BIT.CCLR = 0;//TCNTのクリア禁止
	
	MTUA.TSTR.BIT.CST1 = 1;//カウント動作開始
	MTUA.TSTR.BIT.CST2 = 1;//
	MTUB.TSTR.BIT.CST1 = 1;//
	MTUB.TSTR.BIT.CST2 = 1;//
	
	IPR(MTU1,TCIV1) = 0;			//割り込みの優先度を最低(割り込み禁止)にする
	IPR(MTU2,TCIV2) = 0;			//割り込みの優先度を最低(割り込み禁止)にする
	IPR(MTU7,TCIV7) = 0;			//割り込みの優先度を最低(割り込み禁止)にする
	IPR(MTU8,TCIV8) = 0;			//割り込みの優先度を最低(割り込み禁止)にする
	
	MTU1.TIER.BIT.TCIEV = 1;//オーバーフロー割り込みを許可する
	MTU1.TIER.BIT.TCIEU = 1;//アンダーフロー割り込みを許可する
	MTU2.TIER.BIT.TCIEV = 1;//オーバーフロー割り込みを許可する
	MTU2.TIER.BIT.TCIEU = 1;//アンダーフロー割り込みを許可する
	MTU7.TIER.BIT.TCIEV = 1;
	MTU7.TIER.BIT.TCIEU = 1;
	MTU8.TIER.BIT.TCIEV = 1;
	MTU8.TIER.BIT.TCIEU = 1;
	
	IEN(MTU1,TCIV1) = 1;//割り込み処理を許可
	IEN(MTU1,TCIU1) = 1;//割り込み処理を許可
	IPR(MTU1,TCIV1) = 15;//割り込み優先度を14
	
	IEN(MTU2,TCIV2) = 1;//割り込み処理を許可
	IEN(MTU2,TCIU2) = 1;//割り込み処理を許可
	IPR(MTU2,TCIV2) = 15;//割り込み優先度を14に
	
	IEN(MTU7,TCIV7) = 1;//割り込み処理を許可
	IEN(MTU7,TCIU7) = 1;//割り込み処理を許可
	IPR(MTU7,TCIV7) = 15;//割り込み優先度を14に
	
	IEN(MTU8,TCIV8) = 1;//割り込み処理を許可
	IEN(MTU8,TCIU8) = 1;//割り込み処理を許可
	IPR(MTU8,TCIV8) = 15;//割り込み優先度を14に
}
/******************************************************************************
*	タイトル ： PWMの設定
*	  関数名 ： init_pwm
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/27
******************************************************************************/
void init_pwm(void)
{
	//MTU1,MTU2,,MTU7,MTU8は位相計数モードのためPWM設定不要
	
	PORT7.DDR.BIT.B0 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B1 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B2 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B3 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B4 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B5 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B6 = ON;			//MOTOR_OUTPUT
	PORT7.DDR.BIT.B7 = ON;			//MOTOR_OUTPUT
	PORT9.DDR.BIT.B0 = ON;			//MOTOR_OUTPUT
	PORT9.DDR.BIT.B1 = ON;			//MOTOR_OUTPUT
	PORT9.DDR.BIT.B2 = ON;			//MOTOR_OUTPUT
	PORT9.DDR.BIT.B3 = ON;			//MOTOR_OUTPUT
	PORTB.DDR.BIT.B2 = ON;			//MOTOR_OUTPUT
	PORTB.DDR.BIT.B3 = ON;			//MOTOR_OUTPUT
	PORTB.DDR.BIT.B6 = ON;			//MOTOR_OUTPUT
	PORTB.DDR.BIT.B7 = ON;			//MOTOR_OUTPUT
	PORTB.DDR.BIT.B0 = ON;			//MOTOR_PWM
	PORTB.DDR.BIT.B1 = ON;			//MOTOR_PWM
	PORTB.DDR.BIT.B4 = ON;			//MOTOR_PWM
	PORTB.DDR.BIT.B5 = ON;			//MOTOR_PWM
	PORTA.DDR.BIT.B0 = ON;			//MOTOR_PWM
	PORTA.DDR.BIT.B2 = ON;			//MOTOR_PWM
	PORT8.DDR.BIT.B2 = ON;			//MOTOR_PWM
	PORT8.DDR.BIT.B3 = ON;			//MOTOR_PWM
	
	
	MTUA.TSTR.BIT.CST4 = 0;			//カウント停止 
	MTUB.TSTR.BIT.CST4 = 0;			//カウント停止 
	MTUA.TSTR.BIT.CST3 = 0;			//柳田追加12/22
	MTUB.TSTR.BIT.CST0 = 0; 		//柳田追加12/22
	MTUB.TSTR.BIT.CST3 = 0; 		//柳田追加12/22
	IOPORT.PFCMTU.BIT.MTUS4 = 1;		//ポートファンクションレジスタMTIOC4A-B,MTIOC4C-B端子を選択　追加
	SYSTEM.MSTPCRA.BIT.MSTPA8 = 0;		//MTUユニット1（MTU6～MTU11）のモジュールストップ解除
	SYSTEM.MSTPCRA.BIT.MSTPA9 = 0;		//MTUユニット0（MTU0～MTU5）のモジュールストップ解除 追加柳田12/22
	MTU10.TCNT = 0;				//TCNTを初期化する
	MTU4.TCNT = 0;				//追加柳田12/22　
	MTU6.TCNT = 0;				//追加柳田12/22
	MTU9.TCNT = 0;				//追加柳田12/22
	MTU10.TCR.BIT.CCLR = 0x01;		//同期クリア/同期動作をしている他のチャネルのカウンタクリアでTCNT をクリア
	MTU4.TCR.BIT.CCLR = 0x01;		//追加柳田12/22
	MTU6.TCR.BIT.CCLR = 0x01;		//追加柳田12/22
	MTU9.TCR.BIT.CCLR = 0x01;		//追加柳田12/22
	MTU10.TCR.BIT.CKEG = 0x00;		//立ち上がりエッジでカウント
	MTU4.TCR.BIT.CKEG = 0x00;		//追加柳田12/22
	MTU6.TCR.BIT.CKEG = 0x00;		//追加柳田12/22
	MTU9.TCR.BIT.CKEG = 0x00;		//追加柳田12/22
	MTU10.TCR.BIT.TPSC = 0x00;//0x03;		//内部クロック設定：ICLK/4
	MTU4.TCR.BIT.TPSC = 0x00;//0x03;		//追加柳田12/22
	MTU6.TCR.BIT.TPSC = 0x00;//0x03;		//追加柳田12/22
	MTU9.TCR.BIT.TPSC = 0x00;//0x03;		//追加柳田12/22

	MTU10.TMDR.BIT.MD = 0x02;		//PWMモード1
	MTU4.TMDR.BIT.MD = 0x02;		//追加柳田12/22
	MTU6.TMDR.BIT.MD = 0x02;		//追加柳田12/22
	MTU9.TMDR.BIT.MD = 0x02;		//追加柳田12/22
	MTUB.TOER.BIT.OE4A = 1;			//PWM出力許可 MTIOC10A
	MTUB.TOER.BIT.OE4C = 1;			//PWM出力許可 MTIOC10C
	MTUA.TOER.BIT.OE4A = 1;
	MTUA.TOER.BIT.OE4C = 1;
	MTU10.TIORH.BIT.IOA = 2;		//アウトプットコンペアレジスタに設定、初期値、出力値の選択A		←わからない←最適値が←柳田修正12/22 =6; → =1;
	MTU10.TIORH.BIT.IOB = 1;		//アウトプットコンペアレジスタに設定、初期値、出力値の選択B		柳田修正12/22 =5; → =1;
	MTU4.TIORH.BIT.IOA = 2;			//追加柳田12/22
	MTU4.TIORH.BIT.IOB = 1;			//追加柳田12/22
	MTU6.TIORH.BIT.IOA = 2;			//追加柳田12/22
	MTU6.TIORH.BIT.IOB = 1;			//追加柳田12/22
	MTU9.TIORH.BIT.IOA = 2;			//追加柳田12/22
	MTU9.TIORH.BIT.IOB = 1;			//追加柳田12/22
	MTU10.TIORL.BIT.IOC = 2;		//アウトプットコンペアレジスタに設定、初期値、出力値の選択C		柳田修正12/22 =6; → =2;
	MTU10.TIORL.BIT.IOD = 1;		//アウトプットコンペアレジスタに設定、初期値、出力値の選択D		柳田修正12/22 =5; → =1;
	MTU4.TIORL.BIT.IOC = 2;			//追加柳田12/22
	MTU4.TIORL.BIT.IOD = 1;			//追加柳田12/22
	MTU6.TIORL.BIT.IOC = 2;			//追加柳田12/22
	MTU6.TIORL.BIT.IOD = 1;			//追加柳田12/22
	MTU9.TIORL.BIT.IOC = 2;			//追加柳田12/22
	MTU9.TIORL.BIT.IOD = 1;			//追加柳田12/22
	MTU10.TGRA = PWM_PERIOD;		//48000 / 4 / 8 * 0.01(周辺クロック/内部クロック/タイマプリスケーラ*周期)[1kHz] 
	MTU10.TGRC = PWM_PERIOD;		//48000 / 4 / 8 * 0.01(周辺クロック/内部クロック/タイマプリスケーラ*周期)[1kHz] 
	MTU4.TGRA = PWM_PERIOD;		//追加柳田12/22
	MTU4.TGRC = PWM_PERIOD;		//追加柳田12/22
	MTU6.TGRA = PWM_PERIOD;//_OTHER;		//追加柳田12/22
	MTU6.TGRC = PWM_PERIOD;//_OTHER;		//追加柳田12/22
	MTU9.TGRA = PWM_PERIOD;		//追加柳田12/22
	MTU9.TGRC = PWM_PERIOD;		//追加柳田12/22

	MTUA.TSTR.BIT.CST3 = 1;			//柳田追加12/22	//2013.02.18	CST3→CST4	MTU4のため3だと動かなかった
	MTUA.TSTR.BIT.CST4 = 1;			//柳田追加12/22	//2013.02.18	CST3→CST4	MTU4のため3だと動かなかった
	MTUB.TSTR.BIT.CST4 = 1;			//カウント停止 
	MTUB.TSTR.BIT.CST0 = 1; 		//柳田追加12/22
	MTUB.TSTR.BIT.CST3 = 1; 		//柳田追加12/22
}
/******************************************************************************
*	タイトル ：D　U　A　L　S　H　O　C　K
*	  関数名 ： init_Rspi_dualshock
*	  戻り値 ： void型 
*	   引数1 ： char型 s[]  
******************************************************************************/
void init_Rspi_dualshock(void)	//(デュアルショック用)
{
	MSTP(RSPI1)			= 0;	//RSPI1モジュールストップの解除
	
	RSPI1.SPCR.BYTE		= 0x00;	//始めにRSPI通信を使用するために0x00で通信を有効に
	
	RSPI1.SPPCR.BIT.SPLP	= 0;	//RSPIループバックビルド=通常モード
	RSPI1.SPPCR.BIT.SPLP2	= 0;	//RSPI2スープバックビルド=通常モード
	RSPI1.SPPCR.BIT.SPOM	= 0;	//RSPI出力端子モードビット=CMOS出力
	RSPI1.SPPCR.BIT.MOIFV	= 1;	//MOSIアイドル固定値ビット1
	RSPI1.SPPCR.BIT.MOIFE	= 1;	//MOSI出力値はMOIFVビットの設定値
	
	RSPI1.SPBR			= 75;	//RSPIビットレートレジスタ=255最低速度

	RSPI1.SPDCR.BIT.SPFC	= 0x00;	//SPDRレジスタに格納できるフレーム数を１にする
	RSPI1.SPDCR.BIT.SLSEL	= 0x00;	//SSL端子出力設定余ったポートをIOポートにする=すべて出力用
	RSPI1.SPDCR.BIT.SPRDTD	= 0;	//RSPI受信/送信データ選択ビット=SPDRは受信バッファを読みだす
	RSPI1.SPDCR.BIT.SPLW	= 1;	//SPDRレジスタへはロングワードアクセス。

	RSPI1.SPSCR.BIT.SPSLN	= 0x02;	//RSPIシーケンス長設定ビット=シーケンス長3
	
	RSPI1.SPCKD.BIT.SCKDL	= 0x00;	//RSPCK遅延設定ビット=1RSPCK 
	
	RSPI1.SSLND.BIT.SLNDL	= 0x00;	//SSLネゲート遅延設定ビット=1RSPCK
	
	RSPI1.SPND.BIT.SPNDL	= 0x00;	//RSPI次アクセス遅延設定ビット=1RSPCK+2PCLK
	
	RSPI1.SPCR2.BIT.SPPE	= 0;	//パリティ有効ビット、送信データのパリティビットを付加しない
	RSPI1.SPCR2.BIT.SPOE	= 0;	//パリティモードビット=偶数パリティイで送受信
	RSPI1.SPCR2.BIT.SPIIE	= 1;	//アイドル割り込み要求の発生を許可
	RSPI1.SPCR2.BIT.PTE		= 0;	//パリティ回路自己診断機能は無効
	
	RSPI1.SPCMD0.BIT.CPHA	= 1;	//奇数エッジでデータ変化、偶数エッジでデータサンプル
	RSPI1.SPCMD0.BIT.CPOL	= 1;	//アイドル時のRSPCKが'1'
	RSPI1.SPCMD0.BIT.BRDV	= 0x03;	//ベースのビットレートを8分周を選択
	RSPI1.SPCMD0.BIT.SSLA	= 0x00;	//SSL信号アサート設定ビット=SSLO
	RSPI1.SPCMD0.BIT.SSLKP	= 1;	//転送終了後から次アクセス開始までSSL信号レベルを保持

	RSPI1.SPCMD0.BIT.SPB		= 0x03;	//RSPIデータ長設定ビット=32ビット
	RSPI1.SPCMD0.BIT.LSBF		= 1;		//RSPILSBファーストビット=LSBファーストビット
	RSPI1.SPCMD0.BIT.SPNDEN	= 1;		//次アクセス遅延はRSPI次アクセス遅延レジスタ(SPND)の設定値
	RSPI1.SPCMD0.BIT.SLNDEN	= 1;		//次アクセス遅延設定許可ビット=SSLネゲート遅延はRSPIスレーブセレクトネゲート遅延レジスタ(SSLND)の設定値
	RSPI1.SPCMD0.BIT.SCKDEN	= 1;		//RSPCK遅延はRSPCK遅延はRSPIクロック遅延レジスタ(SPCKD)の設定値
	
	RSPI1.SPCMD1.WORD = RSPI1.SPCMD0.WORD;	//4バイト毎の送信時に行う設定をコピーさせる
	RSPI1.SPCMD2.WORD = RSPI1.SPCMD0.WORD;	//1バイト毎の送信時に行う設定をコピーさせる
	RSPI1.SPCMD2.BIT.SPB	= 0x07;			//RSPIデータ長設定ビット=8ビット

	RSPI1.SPCMD2.BIT.SSLKP	= 0;			//送信が終わった際に出力をHighにするため

	//割り込みコントローラの設定
	//DMACAの設定
	//入出力ポートの設定	(今回はシングルマスタ設定のため入出力が自動で決定される)
	PORTE.ICR.BIT.B7 = 1;
	
	IOPORT.PFHSPI.BIT.RSPIS = 1;

	IOPORT.PFHSPI.BIT.RSPCKE	= 1;	//RSPCKB端子有効
	IOPORT.PFHSPI.BIT.MOSIE		= 1;	//MOSIB端子有効
	IOPORT.PFHSPI.BIT.MISOE		= 1;	//MISOB端子有効
	IOPORT.PFHSPI.BIT.SSL0E		= 1;	//SSLB0端子有効
	IOPORT.PFHSPI.BIT.SSL1E		= 1;	//SSLB1端子有効
	IOPORT.PFHSPI.BIT.SSL2E		= 1;	//SSLB2端子有効
	IOPORT.PFHSPI.BIT.SSL3E		= 1;	//SSLB3端子有効
	
	RSPI1.SPCR.BIT.SPMS		= 0;	//RSPIモード選択ビット=SPI動作(4線式)
	RSPI1.SPCR.BIT.TXMD 	= 0;	//通信動作モード選択ビット=全二重同期式シリアル通信
	RSPI1.SPCR.BIT.MODFEN	= 0;	//モードフォルトエラー検出を禁止
	RSPI1.SPCR.BIT.MSTR		= 1;	//RSPIマスタ/スレーブモード選択=マスタモード
	RSPI1.SPCR.BIT.SPEIE	= 0;	//RSPIエラー割り込み要求の発生を禁止
	RSPI1.SPCR.BIT.SPTIE	= 0;	//RSPI送信割り込み要求の発生を禁止
	RSPI1.SPCR.BIT.SPE		= 1;	//RSPI機能を有効に
	RSPI1.SPCR.BIT.SPRIE	= 1;	//RSPI受信割り込み要求の発生を許可
	
	RSPI1.SSLP.BIT.SSLP0	= 0;	//SSL0信号は0アクティブ
	RSPI1.SSLP.BIT.SSLP1	= 0;	//SSL1信号は0アクティブ
	RSPI1.SSLP.BIT.SSLP2	= 0;	//SSL2信号は0アクティブ
	RSPI1.SSLP.BIT.SSLP3	= 0;	//SSL3信号は0アクティブ
	
	//以下不要の場合は削除の事
	RSPI1.SPSR.BIT.OVRF		= 0;	//オーバランエラーなし
	RSPI1.SPSR.BIT.IDLNF	= 0;	//RSPIがアイドル状態(後で送るときだけ1を代入するのだろうか)<武山のでは使用されていなかった>？
	RSPI1.SPSR.BIT.MODF	= 0;	//モードフォルトエラーなし
	RSPI1.SPSR.BIT.PERF		= 0;	//パリティエラーなし

	//以上不要の場合は削除の事
	RSPI1.SPCR.BYTE;	//SPCRのリード
	IEN(RSPI1,SPRI1) = 1;
	IPR(RSPI1,SPRI1) = 12;
}
/******************************************************************************
*	タイトル ： SPI通信で受信したものを返す
*	  関数名 ： Rspi_send_1
*	  戻り値 ：unsigned lond型
*	    引数 ： unsingned long moji
******************************************************************************/
unsigned long Rspi_send_1(unsigned long moji)
{
	RSPI1.SPDR.LONG = moji;
	while( RSPI1.SPSR.BIT.SPRF == 0 );	//受信バッファになにか来るまで待つ
	return RSPI1.SPDR.LONG;
}
/******************************************************************************
*	タイトル ： SPI通信で受信したものを返す
*	  関数名 ： Rspi_send_1
*	  戻り値 ：unsigned lond型
*	    引数 ： unsingned long moji
******************************************************************************/
unsigned long Rspi_send_short_1(unsigned short int moji)
{
	RSPI1.SPDR.LONG = moji;
	while( RSPI1.SPSR.BIT.SPRF == 0 );	//受信バッファになにか来るまで待つ
	return RSPI1.SPDR.LONG;
}
/******************************************************************************
*	タイトル ： デュアルショックからの送信データを格納
*	  関数名 ： Rspi_receive_send_line_dualshock
*	  戻り値 ： void型
*	    引数 ： なし
******************************************************************************/
void Rspi_recive_send_line_dualshock(void)	//DualShockアナログコントローラ(アナログモード緑LED)用送信プログラム
{
	while( RSPI1.SPSR.BIT.SPRF == 1 ){				//受信バッファがフルならリードしてクリアする
		RSPI1.SPDR.LONG;
	}	
	g_controller_receive_1st = Rspi_send_1(0x00004201);
	g_controller_receive_2nd = Rspi_send_1(0x00000000);
	g_controller_receive_3rd = Rspi_send_short_1(0x00);
}

/******************************************************************************
*	タイトル ： A/D変換の初期設定
*	  関数名 ： init_Ad
*	  戻り値 ： なし
*	    引数 ： なし
*	  作成者 ： 市川 智章
*	  作成日 ： 2011/08/22
******************************************************************************/
void init_Ad(void)
{	
	PORT4.DDR.BIT.B0 = OFF;
	PORT4.DDR.BIT.B1 = OFF;
	PORT4.DDR.BIT.B2 = OFF;
	PORT4.DDR.BIT.B3 = OFF;
	PORT4.DDR.BIT.B4 = OFF;
	PORT4.DDR.BIT.B5 = OFF;
	PORT4.DDR.BIT.B6 = OFF;
	PORT4.DDR.BIT.B7 = OFF;
	
	SYSTEM.MSTPCRA.BIT.MSTPA23 = 0;		//10bitA/Dコンバータ(ユニット0)のモジュール解除

	PORT4.PORT.BYTE = 0x00;			//入力チャンネル:P4を受信設定にする
	//PORT4.DR.BYTE = 0xFF;//PORT4.PORT.BYTE = 0xFF;			//入力チャンネル:P4の入力バッファを有効にする
	
	AD0.ADCR.BIT.MODE = 2;//0;			//モード選択:
	AD0.ADCSR.BIT.ADST = 0;			//設定:A/D変換停止
	AD0.ADCSR.BIT.CH = 3;			//設定:AN0-3
	AD0.ADCSR.BIT.ADIE = 1;			//設定:A/D変換終了によるADI割り込み禁止
	AD0.ADCR.BIT.CKS = 0;			//設定:PCLK/8
	AD0.ADCR.BIT.TRGS = 0;			//設定:ソフトウェアトリガ
	AD0.ADDPR.BIT.DPSEL = 0;		//設定:データはLSB詰め(最初のビットから)
	AD0.ADDIAGR.BIT.DIAG = 0;		//設定:自己診断オフ
	
	AD0.ADSSTR = 0x1A;//0xFF			//設定:AD変換時間を最大に5.1μs
						//page1718 of 1974
	AD0.ADCSR.BIT.ADST = 1;			//設定:A/D変換開始
	SYSTEM.MSTPCRA.BIT.MSTPA22 = 0;		//10bitA/Dコンバータ(ユニット1)のモジュール解除
//	PORT4.PORT.BYTE = 0x00;			//入力チャンネル:P4を受信設定にする
//	PORT4.PORT.BYTE = 0xFF;			//入力チャンネル:P4の入力バッファを有効にす
	AD1.ADCR.BIT.MODE = 2;//0;			//モード選択:
	AD1.ADCSR.BIT.ADST = 0;			//設定:A/D変換停止
	AD1.ADCSR.BIT.CH = 3;			//設定:AN4-7
	AD1.ADCSR.BIT.ADIE = 1;			//設定:A/D変換終了によるADI割り込み禁止
	AD1.ADCR.BIT.CKS = 0;			//設定:PCLK/8
	AD1.ADCR.BIT.TRGS = 0;			//設定:ソフトウェアトリガ
	AD1.ADDPR.BIT.DPSEL = 0;		//設定:データはLSB詰め(最初のビットから)
	AD1.ADDIAGR.BIT.DIAG = 0;		//設定:自己診断オフ
	
	AD1.ADSSTR = 0x1A;//0xFF			//設定:AD変換時間を最大に5.1μs
						//page1718 of 1974
	AD1.ADCSR.BIT.ADST = 1;			//設定:A/D変換開始
	
	IEN(AD0,ADI0) = 1;
	IEN(AD1,ADI1) = 1;
	IPR(AD0,ADI0) = 13;
	IPR(AD1,ADI1) = 13;
}
/*void init_Ad(void)
{
	
	//AD0:AN0～AN3
	SYSTEM.MSTPCRA.BIT.MSTPA23 = 0;		//10bitA/Dコンバータユニット0モジュールストップ解除
	AD0.ADCSR.BIT.ADST = 0;				//A/D変換停止
	AD0.ADCR.BIT.MODE = ADC10U0_MODE;	//モード選択
	AD0.ADCSR.BIT.CH = ADC10U0_CH;		//変換対象チャネルの設定
	AD0.ADCSR.BIT.ADIE = 1;				//A/D変換終了によるADI割り込み許可
	AD0.ADCR.BIT.CKS = 0;				//クロック選択PCLK/8
	AD0.ADDPR.BIT.DPSEL = 0;			//LSB詰め
	AD0.ADDIAGR.BIT.DIAG = 0;			//自己診断無し
	AD0.ADSSTR = 0xFF;					//設定:AD変換時間を最大に5.1μs
	AD0.ADCSR.BIT.ADST = 1;				//A/D変換開始
	
	//AD1:AN4～AN7
	SYSTEM.MSTPCRA.BIT.MSTPA22 = 0;		//10bitA/Dコンバータユニット1モジュールストップ解除
	AD1.ADCSR.BIT.ADST = 0;				//A/D変換停止
	AD1.ADCR.BIT.MODE = ADC10U1_MODE;	//モード選択
	AD1.ADCSR.BIT.CH = ADC10U1_CH;		//変換対象チャネルの設定
	AD1.ADCSR.BIT.ADIE = 1;				//A/D変換終了によるADI割り込み許可
	AD1.ADCR.BIT.CKS = 0;				//クロック選択PCLK/8
	AD1.ADDPR.BIT.DPSEL = 0;			//LSB詰め
	AD1.ADDIAGR.BIT.DIAG = 0;			//自己診断無し
	AD1.ADSSTR = 0xFF;					//設定:AD変換時間を最大に5.1μs
	AD1.ADCSR.BIT.ADST = 1;				//A/D変換開始
}*/

/******************************************************************************
*	タイトル ： AD変換(10bitA/Dコンバータ)の値を得る
*	  関数名 ： get_Ad
*	  戻り値 ： int型 
*	   引数1 ： int型 ch  
*	  作成者 ： 真下康宏
*	  作成日 ： 2012/12/15
*****************************************************************************/
float get_Ad(int ch)
{
	float figure_ad = 0;
	if(ch <= 3){
		AD0.ADCSR.BIT.CH=ch;	//チャネル選択ビット	データシート(1708/1974)
		AD0.ADCSR.BIT.ADST=1;	//A/D変換開始
		switch(ch){
			case 0:	figure_ad = AD0.ADDRA;break;
			case 1:	figure_ad = AD0.ADDRB;break;
			case 2:	figure_ad = AD0.ADDRC;break;
			case 3:	figure_ad = AD0.ADDRD;break;
		}
	}else{
		ch-= 4;	
		AD1.ADCSR.BIT.CH=ch;
		AD1.ADCSR.BIT.ADST=1;
		switch(ch){
			case 0:	figure_ad = AD1.ADDRA;break;
			case 1:	figure_ad = AD1.ADDRB;break;
			case 2:	figure_ad = AD1.ADDRC;break;
			case 3:	figure_ad = AD1.ADDRD;break;
		}
	}

	return figure_ad;
}
/******************************************************************************
*	タイトル ： AD変換(CH0~3)の割り込み処理
*	  関数名 ： Ad0_interrupt
*	  戻り値 ： void
*	    引数 ： 	なし
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
void Ad0_interrupt(void)
{
	static int i = 0;
	
	IR(AD0,ADI0) = OFF;
	if(i >= 4){
		i = 0;
	}
	g_ad_att[i] = get_Ad(i);
	
	i++;
}
/******************************************************************************
*	タイトル ： AD変換(CH4~7)の割り込み処理
*	  関数名 ： Ad0_interrupt
*	  戻り値 ： void
*	    引数 ： 	なし
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
void Ad1_interrupt(void)
{
	static int i = 4;
	
	IR(AD1,ADI1) = OFF;
	
	if(i >= 8){
		i = 4;
	}
	g_ad_att[i] = get_Ad(i);
	
	i++;
}

/******************************************************************************
*	タイトル ： すべての初期設定を行う
*	  関数名 ： All_setup
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/

/******************************************************************************
*	タイトル ： ブザー周期(LED追加)
*	  関数名 ： Buzzer_period
*	  戻り値 ： void
*	    引数1 ：int型 period
*		引数2 : int型 number 	
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
void Buzzer_period(int period,	int number)
{
	static int count[5] = {0};
	
	count[number] ++;
	if((count[number] >= 0) && (count[number] < period)){
		//BUZZER = ON;
		g_buzzer_io = OFF;
		#if COLOR == RED
		LED_BLUE = OFF;
		#elif	COLOR == BLUE
		LED_RED = OFF;
		#endif
	}else if((count[number] >= period) && (count[number] < (period * 2))){
		g_buzzer_io = ON;
		#if COLOR == RED
		LED_BLUE = ON;
		#elif	COLOR == BLUE
		LED_RED = ON;
		#endif
	}else{
		count[number] = 0;
	}
}

/******************************************************************************
*	タイトル ： MTU1のエンコーダのカウントを返す
*	  関数名 ： get_encorder_MTU1
*	  戻り値 ： long型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
float get_encorder_MTU1(void)
{
	static float count_now = 0;
	count_now = (MTU1_ENCODER_VALUE + (65535 * g_over_under_flow_count_MTU1));
	return(count_now);
}
/******************************************************************************
*	タイトル ： MTU2のエンコーダのカウントを返す
*	  関数名 ： get_encorder_MTU2
*	  戻り値 ： long型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
float get_encorder_MTU2(void)
{
	static float count_now = 0;
	count_now = (MTU2_ENCODER_VALUE + (65535 * g_over_under_flow_count_MTU2));
	return(count_now);
}
/******************************************************************************
*	タイトル ： MTU7のエンコーダのカウントを返す
*	  関数名 ： get_encorder_MTU7
*	  戻り値 ： long型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
float get_encorder_MTU7(void)
{
	static float count_now = 0;
	count_now = (MTU7_ENCODER_VALUE + (65535 * g_over_under_flow_count_MTU7));
	return(count_now);
}
/******************************************************************************
*	タイトル ： MTU8のエンコーダのカウントを返す
*	  関数名 ： get_encorder_MTU8
*	  戻り値 ： long型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
float get_encorder_MTU8(void)
{
	static float count_now = 0;
	count_now = (MTU8_ENCODER_VALUE + (65535 * g_over_under_flow_count_MTU8));
	return(count_now);
}
/******************************************************************************
*	タイトル ： 度数のラジアン変換
*	  関数名 ： convert_radian
*	  戻り値 ： float型
*	    引数1： float型 degree 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
float convert_radian(float degree)
{
	float radian = 0.0;
	radian = degree * (M_PI / 180);
	return (radian);
}
/******************************************************************************
*	タイトル ： ラジアンの度数変換
*	  関数名 ： 	convert_degree
*	  戻り値 ： float型
*	    引数1： float型 radian
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
float convert_degree(float radian)
{
	float degree = 0.0;
	degree = radian * (180 / M_PI);
	
	if(degree > 180){
		degree = degree - 360.0;
	}
	if(degree < -180){
		degree = degree + 360.0;
	}
	
	return(degree);
}
/******************************************************************************
*	タイトル： 現在地から目標値までの角度を返す
*	  関数名 ： get_target_degree
*	  戻り値 ： float型
*	    引数1： float型 target_x
*	    引数2： float型 target_y
*	    引数3： float型 x_now
*	    引数4： float型 y_now 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_target_degree(float target_x,float target_y,float x_now,float y_now)
{
	float target_degree = 0.0;
	static float target_degree_old = 0.0;
	
	if((target_x - x_now != 0.0) || (target_y - y_now != 0.0)){
		target_degree = atan2(target_y - y_now,target_x - x_now) * 180 /M_PI;
		target_degree_old = target_degree;
	}else{
		target_degree = target_degree_old;//動いてなかったら前の角度
		}
	
	return (target_degree);
}
/******************************************************************************
*	タイトル ： 値のブレを減少させる
*	  関数名 ： get_Average
*	  戻り値 ： float型 
*	   引数1 ： int型 number_scope  
*	   引数2 ： int型 box  
*	   引数3 ： float型 add  
*	  作成者 ： 眞下康宏
*	  作成日 ： 2013/02/16
******************************************************************************/
float get_Average(int number_scope, int box, float add)
{
	static float average[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	static float number[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	
	if(number[box] >= number_scope){		//回数が増え過ぎたらリセットする
		number[box] = (number_scope-1);
	}
	
	average[box] *= number[box];			//前回までの平均値と回数から合計を求める
	average[box] += add;				//今回の入力値を加える
	number[box]++;					//回数の値を1加え、今回の回数にする
	average[box] = average[box]/number[box];	//合計を今回の回数で割る

	return (average[box]);				//今回の平均値を返す
}
/******************************************************************************
*	タイトル： 角度のズレを返す
*	  関数名 ： get_gap_degree
*	  戻り値 ： float 型 
*	    引数1： float型 target_degree
*          引数2 :  floa型t degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_gap_degree(float target_degree,float degree_now)
{
	int i = 0;
	
	target_degree = target_degree - degree_now;//目標の角度と今の角度の差
	
	for(i = 0;  i <= 4; i++){
		//角度の範囲越え防止
		if(target_degree > 180){
			target_degree = target_degree - 360;
		}
		if(target_degree < -180){
			target_degree = target_degree + 360;
		}
	}
	
	if((target_degree > 180) || (target_degree < -180)){
		return (0);
	}else{
		return (target_degree);
	}
}
/******************************************************************************
*	タイトル ： 自己位置推定
*	  関数名 ： calculate_information
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/23
******************************************************************************/
void calculate_information(void)
{
	float 		gap_front_encorder_count = 0,	gap_left_encorder_count = 0,	gap_right_encorder_count = 0;
	float front_encorder_count_now = 0.0,	left_encorder_count_now = 0.0,	right_encorder_count_now = 0.0;	
	static float front_encorder_count_old = 0,	left_encorder_count_old = 0,	right_encorder_count_old = 0;
	float 		d_distance_f  = 0.0,	d_distance_l = 0.0,	d_distance_r = 0.0,
			degree_reverse_f = 0.0,	degree_reverse_l = 0.0,	degree_reverse_r = 0.0,
			velocity_x = 0.0,  velocity_y = 0.0,	
			correct_x_l = 0.0,	correct_y_l = 0.0,	correct_x_r = 0.0,	correct_y_r = 0.0,
		correct_x_b = 0.0,	correct_y_b = 0.0;
	static float 	x_c_old = START_X,	y_c_old = START_Y,	direction_degree_old = 0.0,
			degree_old = START_DEGREE,	radian_f = 0.0,	radian_l = 0.0,	radian_r = 0.0,
			velocity_old = 0.0;
	
	//反時計回りを正
	front_encorder_count_now = (-1) * get_encorder_MTU1();
	left_encorder_count_now = get_encorder_MTU2();
	right_encorder_count_now = get_encorder_MTU7();
	
	gap_front_encorder_count = front_encorder_count_now  - front_encorder_count_old;
	gap_left_encorder_count = left_encorder_count_now  - left_encorder_count_old;
	gap_right_encorder_count = right_encorder_count_now  - right_encorder_count_old;
	
	//エンコーダタイヤの値が飛んだ時
	if((fabs(front_encorder_count_now - front_encorder_count_old) > 400) || (fabs(left_encorder_count_now - left_encorder_count_old) > 400) || (fabs(right_encorder_count_now - right_encorder_count_old) > 400)){
		g_flag_safety = ON;
	}
	
	d_distance_f = gap_front_encorder_count * (FRONT_ENCORDER_CIRCUMFERENCE / ENCORDER_DIVISION);
	d_distance_l =  gap_left_encorder_count * (LEFT_ENCORDER_CIRCUMFERENCE / ENCORDER_DIVISION);
	d_distance_r = gap_right_encorder_count * (RIGHT_ENCORDER_CIRCUMFERENCE / ENCORDER_DIVISION);
	
	radian_f = d_distance_f / ENCORDER_DISTANCE;
	radian_l = d_distance_l / ENCORDER_DISTANCE;
	radian_r = d_distance_r / ENCORDER_DISTANCE;
	
	//角度算出
	g_radian += /*convert_radian(START_DEGREE) +*/ ((radian_f + radian_l + radian_r) / 3);
	if(g_radian > 2 * M_PI){
		g_radian -= 2 * M_PI;
	}
	if(g_radian < -2 * M_PI){
		g_radian += 2 * M_PI;
	}
	g_degree = convert_degree(g_radian);
	
	/*if(fabs(get_gap_degree(g_degree ,degree_old)) >= 10.0){
		g_flag_safety = ON;
	}*/
	
	//エンコーダが反対方向になった時、角度を180度ひっくり返す
	if(d_distance_l < 0){
		 degree_reverse_l = 180.0;
	}
	if(d_distance_r < 0){
		degree_reverse_r = 180.0;
	}
	if(d_distance_f < 0){
		degree_reverse_f = 180.0;
	}
	
	//三角形の頂点の座標を算出
	g_vertex_b_x += (fabs(d_distance_r) * cos(convert_radian(g_degree  + (degree_reverse_r - 30))) + fabs(d_distance_l) * cos(convert_radian(g_degree + (degree_reverse_l - 150))));
	g_vertex_b_y += (fabs(d_distance_r) * sin(convert_radian(g_degree  + (degree_reverse_r - 30))) + fabs(d_distance_l) * sin(convert_radian(g_degree  + (degree_reverse_l - 150))));
	g_vertex_l_x += (fabs(d_distance_l) * cos(convert_radian(g_degree - 150.0 + degree_reverse_l)) + fabs(d_distance_f) * cos(convert_radian(g_degree + 90.0 + degree_reverse_f)));
	g_vertex_l_y += (fabs(d_distance_l) * sin(convert_radian(g_degree - 150.0 + degree_reverse_l)) + fabs(d_distance_f) * sin(convert_radian(g_degree + 90.0 + degree_reverse_f)));
	g_vertex_r_x += (fabs(d_distance_f) * cos(convert_radian(g_degree + 90.0 + degree_reverse_f)) + fabs(d_distance_r) * cos(convert_radian( g_degree + (degree_reverse_r - 30))));
	g_vertex_r_y += (fabs(d_distance_f) * sin(convert_radian(g_degree + 90.0 + degree_reverse_f)) + fabs(d_distance_r) * sin(convert_radian( g_degree + (degree_reverse_r - 30))));
	
	//エンコーダ二つから計算した中心座標(座標の補正用)
	/*correct_x_b = g_vertex_b_x + (VERTEX_CENTER_DISTANCE * cos(convert_radian(g_degree + 0.0)));
	correct_y_b =  g_vertex_b_y + (VERTEX_CENTER_DISTANCE * sin(convert_radian(g_degree + 0.0)));
	correct_x_l =  g_vertex_l_x + (VERTEX_CENTER_DISTANCE * cos(convert_radian(g_degree + 120.0)));
	correct_y_l =  g_vertex_l_y + (VERTEX_CENTER_DISTANCE * sin(convert_radian(g_degree + 120.0)));
	correct_x_r = g_vertex_r_x + (VERTEX_CENTER_DISTANCE * cos(convert_radian(g_degree - 120.0)));
	correct_y_r = g_vertex_r_y + (VERTEX_CENTER_DISTANCE * sin(convert_radian(g_degree - 120.0)));
	*/
	
	//車体中心の座標格納
	g_x_c = (g_vertex_b_x + g_vertex_l_x + g_vertex_r_x) / 3;
	g_y_c = (g_vertex_b_y + g_vertex_l_y + g_vertex_r_y) / 3;
	/*
	g_x_c = (g_vertex_b_x + g_vertex_l_x + g_vertex_r_x + correct_x_b + correct_x_l + correct_x_r) / 6;
	g_y_c = (g_vertex_b_y + g_vertex_l_y + g_vertex_r_y + correct_y_b + correct_y_l + correct_y_r) / 6;
	*/
	
	//車体の速度、角速度
	velocity_x = (g_x_c - x_c_old) * (1000 / INTERRUPT_TIME);
	velocity_y = (g_y_c - y_c_old) * (1000 / INTERRUPT_TIME);
	g_velocity = pow(pow(velocity_x,2) + pow(velocity_y,2),0.5);
	g_omega = (get_gap_degree(g_degree , degree_old)) * (1000 / INTERRUPT_TIME);
	
	g_accele = (g_velocity - velocity_old) * (1000 / INTERRUPT_TIME);
	
	//車体の進んでいる方向の角度
	/*if((g_y_c - y_c_old != 0.0) || (g_x_c - x_c_old != 0.0)){
		g_direction_degree = atan2(g_y_c - y_c_old,g_x_c - x_c_old) * (180.0 / M_PI);
		direction_degree_old = g_direction_degree;
	}else{
		g_direction_degree = direction_degree_old;//動いてなかったら前の角度
	}*/

	//5m秒前の情報の更新
	front_encorder_count_old = front_encorder_count_now;
	left_encorder_count_old = left_encorder_count_now;
	right_encorder_count_old = right_encorder_count_now;
	x_c_old = g_x_c;
	y_c_old = g_y_c;
	degree_old = g_degree;
	velocity_old = g_velocity;
}
/******************************************************************************
*	タイトル ： すべての情報の初期値設定
*	  関数名 ： All_information_start
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void All_information_start(void)
{
	g_omega = 0.0;
	//角度
	g_degree = START_DEGREE;
	g_radian = convert_radian(START_DEGREE);
	//現在地
	g_x_c = START_X;
	g_y_c = START_Y;
	//三角形の頂点の座標
	g_vertex_b_x = START_X + VERTEX_CENTER_DISTANCE * cos(convert_radian(START_DEGREE + 180.0));
	g_vertex_b_y = START_Y + VERTEX_CENTER_DISTANCE * sin(convert_radian(START_DEGREE + 180.0));
	g_vertex_l_x = START_X + VERTEX_CENTER_DISTANCE * cos(convert_radian(START_DEGREE + 60.0));
	g_vertex_l_y = START_Y + VERTEX_CENTER_DISTANCE * sin(convert_radian(START_DEGREE + 60.0));
	g_vertex_r_x = START_X + VERTEX_CENTER_DISTANCE * cos(convert_radian(START_DEGREE - 60.0));
	g_vertex_r_y = START_Y + VERTEX_CENTER_DISTANCE * sin(convert_radian(START_DEGREE - 60.0));
}
/******************************************************************************
*	タイトル ： 情報のリセット
*	  関数名 ： information_reset
*	  戻り値 ： void型
*	    引数1： float型 x_now
*	    引数2： float型 y_now
*	    引数3： float型 degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/1/24
******************************************************************************/
void information_reset(float x_now,float y_now,float degree_now)
{
	g_x_start = x_now;
	g_y_start = y_now;
	g_radian = convert_radian(degree_now);
	g_vertex_b_x = x_now + VERTEX_CENTER_DISTANCE * cos(convert_radian(degree_now + 0.0));
	g_vertex_b_y = y_now + VERTEX_CENTER_DISTANCE * sin(convert_radian(degree_now + 0.0));
	g_vertex_l_x = x_now + VERTEX_CENTER_DISTANCE * cos(convert_radian(degree_now + 120.0));
	g_vertex_l_y = y_now + VERTEX_CENTER_DISTANCE * sin(convert_radian(degree_now + 120.0));
	g_vertex_r_x = x_now + VERTEX_CENTER_DISTANCE * cos(convert_radian(degree_now - 120.0));
	g_vertex_r_y = y_now + VERTEX_CENTER_DISTANCE * sin(convert_radian(degree_now - 120.0));
}
/******************************************************************************
*	タイトル ： 上アーム値変換(AD値→mm)
*	  関数名 ： convert_top_arm_ad_mm
*	  戻り値 ： float型
*	    引数1： float型 ad
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/1/24
******************************************************************************/
float convert_top_arm_ad_mm(float ad)
{
	return(ad * TOP_ARM_MOVABLE_MM / TOP_ARM_MOVABLE_AD);
}
/******************************************************************************
*	タイトル ： 上アーム値変換(AD値→角度)
*	  関数名 ： convert_top_arm_ad_degree
*	  戻り値 ： float型
*	    引数1： float型 ad
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/1/24
******************************************************************************/
float convert_top_arm_ad_degree(float ad)
{
	return(ad * TOP_ARM_MOVABLE_TURN_DEGREE / TOP_ARM_MOVABLE_TURN_AD);
}
/******************************************************************************
*	タイトル ： 上アーム傾き値変換(AD値→degree)
*	  関数名 ： convert_top_arm_tilt_ad_mm
*	  戻り値 ： float型
*	    引数1： float型 ad
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/1/24
******************************************************************************/
float convert_top_arm_tilt_ad_degree(float ad)
{
	return(ad * TOP_ARM_MOVABLE_TILT_DEGREE / TOP_ARM_MOVABLE_TILT_AD);
}
/******************************************************************************
*	タイトル ： シーソーアーム値変換(AD値→degree)
*	  関数名 ： convert_seesaw_arm_ad_mm
*	  戻り値 ： float型
*	    引数1： float型 ad
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/1/24
******************************************************************************/
float convert_seesaw_arm_ad_mm(float ad)
{
	return(ad * SEESAW_ARM_MOVABLE_MM / SEESAW_ARM_MOVABLE_AD);
}
/******************************************************************************
*	タイトル ：アームデータ算出
*	  関数名 ： calculate_information_arm
*	  戻り値 ： void型
*	    引数： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void calculate_information_arm(int flag_lift_arm_set,  int flag_top_arm_set,  int flag_seesaw_arm_set)
{
	float 	lift_arm_encorder_count_now = 0,	gap_lift_arm_encorder_count = 0;
	float top_arm_velocity_x = 0.0,	top_arm_velocity_y = 0.0;
	static float lift_arm_encorder_count_old = 0,	z_top_arm_old = INIT_TOP_ARM_HIGH,	z_seesaw_arm_old = INIT_SEESAW_ARM_HIGH,
			z_swing_arm_old = INIT_SWING_ARM_HIGH;
	float d_distance_lift_arm = 0.0,	top_arm_change_high,	d_top_arm_change_high;
	static float top_arm_change_high_old = 0.0,	x_top_arm_old = 0.0,		y_top_arm_old = 0.0,		top_arm_degree_old = INIT_TOP_ARM_DEGREE;
	static int flag_start = OFF;
	
	if(flag_start == OFF){
		flag_start = ON;
		x_top_arm_old = START_X + ((CAD_SIZE_TOP_ARM_1 + CAD_SIZE_TOP_ARM_4 + INIT_TOP_ARM_LENGTH + CAD_SIZE_TOP_ARM_5) * cos(convert_radian(START_DEGREE)));
		y_top_arm_old = START_Y + ((CAD_SIZE_TOP_ARM_1 + CAD_SIZE_TOP_ARM_4 + INIT_TOP_ARM_LENGTH + CAD_SIZE_TOP_ARM_5) * sin(convert_radian(START_DEGREE)));
	}
	
	lift_arm_encorder_count_now = (-1) * get_encorder_MTU8();
	gap_lift_arm_encorder_count = lift_arm_encorder_count_now - lift_arm_encorder_count_old;
	
	d_distance_lift_arm = gap_lift_arm_encorder_count * (LIFT_ARM_ENCORDER_CIRCUMFERENCE / LIFT_ARM_ENCORDER_DIVISION);
	
	//角度計算
	#if POTENTIO_DIRECTION_TOP_ARM_DEGREE == FRONT
	g_top_arm_degree= convert_top_arm_ad_degree(g_now_ad[0] - g_init_ad[0]) + INIT_TOP_ARM_DEGREE;
	#else
	g_top_arm_degree = conver_top_arm_ad_degree(g_init_ad[0] - g_now_ad[0]) + INIT_TOP_ARM_DEGREE;
	#endif
	
	if(flag_top_arm_set == ON){
		//上アーム長さ計算
		#if POTENTIO_DIRECTION_TOP_ARM_LENGTH == FRONT
		g_top_arm_length = convert_top_arm_ad_mm(g_now_ad[1] - g_init_ad[1]) + INIT_TOP_ARM_LENGTH;
		#else
		g_top_arm_length = convert_top_arm_ad_mm(g_init_ad[1] - g_now_ad[1]) + INIT_TOP_ARM_LENGTH;
		#endif
	}else{
		g_init_ad[1] = g_now_ad[1];
		g_top_arm_length = INIT_TOP_ARM_LENGTH;
	}
	
	
	
	//上アーム傾き計算
	#if POTENTIO_DIRECTION_TOP_ARM_TILT == FRONT
	g_top_arm_tilt_degree = convert_top_arm_tilt_ad_degree(g_now_ad[2] - g_init_ad[2]) + INIT_TOP_ARM_TILT_DEGREE;
	#else
	g_top_arm_tilt_degree = convert_top_arm_tilt_ad_degree(g_init_ad[2] - g_now_ad[2]) + INIT_TOP_ARM_TILT_DEGREE
	#endif
	top_arm_change_high = (2 * CAD_SIZE_TOP_ARM_7 * sin(convert_radian(g_top_arm_tilt_degree / 2))) * sin(convert_radian(g_top_arm_tilt_degree / 2));
	d_top_arm_change_high = top_arm_change_high - top_arm_change_high_old;
	
	g_x_c_top_arm = g_x_c + ((CAD_SIZE_TOP_ARM_1 + CAD_SIZE_TOP_ARM_4 + g_top_arm_length + CAD_SIZE_TOP_ARM_5) * cos(convert_radian(g_degree)));
	g_y_c_top_arm = g_y_c + ((CAD_SIZE_TOP_ARM_1 + CAD_SIZE_TOP_ARM_4 + g_top_arm_length + CAD_SIZE_TOP_ARM_5) * sin(convert_radian(g_degree)));
	
//	top_arm_velocity_x = (g_x_c_top_arm - x_top_arm_old) * (1000 / INTERRUPT_TIME);//mm/s
//	top_arm_velocity_y = (g_y_c_top_arm - y_top_arm_old) * (1000 / INTERRUPT_TIME);//mm/s
//	g_top_arm_velocity = powf(powf(top_arm_velocity_x,2.0) + powf(top_arm_velocity_y,2.0),0.5);
//	g_top_arm_turn_omega = (get_gap_degree(g_top_arm_degree , top_arm_degree_old)) * (1000 / INTERRUPT_TIME);//θ/s
	
	/*if(pow(pow(g_top_arm_velocity_x,2.0) + pow(g_top_arm_velocity_y,2.0),0.5) >= 1250){
		BUZZER = ON;
	}else{
		if(g_flag_safety == OFF){
			BUZZER = OFF;
		}
	}*/
	
	//シーソーアーム長さ計算
	if(flag_seesaw_arm_set == ON){
		#if POTENTIO_DIRECTION_SEESAW_ARM_LENGTH == FRONT
		g_seesaw_arm_length = convert_seesaw_arm_ad_mm(g_now_ad[3] - g_init_ad[3]) + INIT_SEESAW_ARM_LENGTH;
		#else
		g_seesaw_arm_length = convert_seesaw_arm_ad_mm(g_init_ad[3] - g_now_ad[3]) + INIT_SEESAW_ARM_LENGTH;
		#endif
	}else{
		g_init_ad[3] = g_now_ad[3];
		g_seesaw_arm_length = INIT_SEESAW_ARM_LENGTH;
	}
	
	/*g_x_c_seesaw_arm = g_x_c + INIT_SEESAW_ARM_LENGTH * cos(convert_radian(g_seesaw_swing_arm_degree + g_degree));
	g_y_c_seesaw_arm = g_y_c + INIT_SEESAW_ARM_LENGTH * sin(convert_radian(g_seesaw_swing_arm_degree + g_degree));
	
	g_x_c_swing_arm = g_x_c + INIT_SWING_ARM_LENGTH * cos(convert_radian(g_seesaw_swing_arm_degree + g_degree));
	g_y_c_swing_arm = g_y_c + INIT_SWING_ARM_LENGTH * sin(convert_radian(g_seesaw_swing_arm_degree + g_degree));*/
	
	if(flag_lift_arm_set == ON){
		g_z_c_top_arm += (d_distance_lift_arm + d_top_arm_change_high);
		g_z_c_seesaw_arm += d_distance_lift_arm;
		g_z_c_swing_arm += d_distance_lift_arm;
	}else{
		g_z_c_top_arm = INIT_TOP_ARM_HIGH;
		g_z_c_seesaw_arm = INIT_SEESAW_ARM_HIGH;
		g_z_c_swing_arm = INIT_SWING_ARM_HIGH;
	}
	
	//ファンの座標
	g_x_c_fan_l = g_x_c + CAD_SIZE_CENTER_TO_FAN_0 * cos(convert_radian(g_degree + CAD_SIZE_CENTER_TO_FAN_1));
	g_y_c_fan_l = g_y_c + CAD_SIZE_CENTER_TO_FAN_0 * sin(convert_radian(g_degree + CAD_SIZE_CENTER_TO_FAN_1));
	g_x_c_fan_r = g_x_c + CAD_SIZE_CENTER_TO_FAN_0 * cos(convert_radian(g_degree - CAD_SIZE_CENTER_TO_FAN_1));
	g_y_c_fan_r = g_y_c + CAD_SIZE_CENTER_TO_FAN_0 * sin(convert_radian(g_degree - CAD_SIZE_CENTER_TO_FAN_1));		
	g_x_c_fan_b = g_x_c + CAD_SIZE_CENTER_TO_FAN_2  * cos(convert_radian(g_degree + 180.0));
	g_y_c_fan_b = g_y_c + CAD_SIZE_CENTER_TO_FAN_2  * sin(convert_radian(g_degree + 180.0));
	
	//支点座標(左、右タイヤの中心位置)
	g_x_c_fulcrum = g_x_c + (CAD_SIZE_CENTER_TO_TIRE * 0.5) * cos(convert_radian(g_degree));
	g_y_c_fulcrum = g_y_c + (CAD_SIZE_CENTER_TO_TIRE * 0.5) * sin(convert_radian(g_degree));
		
	g_top_arm_velocity_z = (g_z_c_top_arm - z_top_arm_old) * (1000 / INTERRUPT_TIME);
	g_seesaw_arm_velocity_z = (g_z_c_seesaw_arm - z_seesaw_arm_old) * (1000 / INTERRUPT_TIME);
	g_swing_arm_velocity_z = (g_z_c_swing_arm - z_swing_arm_old) * (1000 / INTERRUPT_TIME);
	
	//カウント更新
	lift_arm_encorder_count_old = lift_arm_encorder_count_now;
	top_arm_change_high_old = top_arm_change_high;
	
	/*x_top_arm_old = g_x_c_top_arm;
	y_top_arm_old = g_y_c_top_arm;*/
	z_top_arm_old = g_z_c_top_arm;
	z_seesaw_arm_old = g_z_c_seesaw_arm;
	z_swing_arm_old = g_z_c_swing_arm;
	top_arm_degree_old = g_top_arm_degree;
}
/******************************************************************************
*	タイトル ： Excel処理のためのデータをシリアル送信
*	  関数名 ： sci_transformer
*	  戻り値 ： void型 
*	    引数 ： なし
*	  作成者 ： 眞下康宏
*	  作成日 ： 2013/02/25
******************************************************************************/
void sci_transformer(void)
{	
	#if MODE_SCIDATA_BOX != OFF
		char 	sc1[50],sc2[50],sc3[50],sc4[50],sc5[50],sc6[50],sc7[50],sc8[50];
	#endif
	
	#if MODE_SCIDATA_BOX >= 1
		sprintf(sc1,"%f",(float)g_sci1);
		String(",");
		String(sc1);
	#endif
	#if MODE_SCIDATA_BOX >= 2
		sprintf(sc2,"%f",(float)g_sci2);
		String(",");
		String(sc2);
	#endif
	#if MODE_SCIDATA_BOX >= 3
		sprintf(sc3,"%f",(float)g_sci3);
		String(",");
		String(sc3);
	#endif
	#if MODE_SCIDATA_BOX >= 4
		sprintf(sc4,"%f",(float)g_sci4);
		String(",");
		String(sc4);
	#endif
	#if MODE_SCIDATA_BOX >= 5
		sprintf(sc5,"%f",(float)g_sci5);
		String(",");
		String(sc5);
	#endif
	#if MODE_SCIDATA_BOX >= 6
		sprintf(sc6,"%5d",(long)g_sci6);
		String(",");
		String(sc6);		
	#endif
	#if MODE_SCIDATA_BOX >= 7
		sprintf(sc7,"%5d",(long)g_sci7);
		String(",");
		String(sc7);
	#endif
	#if MODE_SCIDATA_BOX >= 8
		sprintf(sc8,"%5d",(long)g_sci8);
		String(",");
		String(sc8);
	#endif
	
	String("\n\r");
}
/******************************************************************************
*	タイトル ： 設定した範囲内の値を返す
*	  関数名 ： Limit_ul
*	  戻り値 ： float型 出力値
*	   引数1 ： float型 upper  上限の数値
*	   引数2 ： float型 lower  下限の数値
*	   引数3 ： float型 figure  比較する数値
*	  作成者 ： 市川 智章
*	  作成日 ： 2011/08/31
******************************************************************************/
float Limit_ul(float upper,float lower,float figure)
{
	if(upper < figure){
		return(upper);
	}else if(figure < lower){
		return(lower);
	}else{
		return(figure);
	}
}
/******************************************************************************
*	タイトル ： 2点間の距離(絶対値)を返す
*	  関数名 ： get_distance
*	  戻り値 ： float型
*	    引数1： float型 target_x
*	    引数2： float型 target_y
*	    引数3： float型 x_now
*	    引数4： float型 y_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_distance(float target_x,float target_y,float x_now,float y_now)
{
	float distance = 0.0;
	distance = fabs( sqrtf(powf(target_x - x_now,2.0) + powf(target_y - y_now,2.0)));//distance =| √(x^2 + y^2)| 
	return (distance);
}
/******************************************************************************
*	タイトル： 水平方向の距離を返す(ベクトル表記)
*	  関数名 ： get_horizontal_distance
*	  戻り値 ： float型
*	    引数1： float型 degree_gap
*          引数2 :  float型 distance
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_horizontal_distance(float degree_gap,float distance)
{
	if(degree_gap > 90){
		degree_gap = 180 - degree_gap;
		}
	if(degree_gap < -90){
		degree_gap = -degree_gap - 180;
		}
	
	if(degree_gap > 0){
		return ((-1)*distance * cos(convert_radian(90-fabs(degree_gap))));//車体の向きに対して水平方向が左
	}else{
		return(distance * cos(convert_radian(90-fabs(degree_gap))));
	}
}
/******************************************************************************
*	タイトル： 垂直方向の距離を返す(ベクトル表記)
*	  関数名 ： get_vertical_distance 
*	  戻り値 ： float型
*	   引数1 ： float型 gap
*         引数2  :  float型 distance
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_vertical_distance(float degree_gap,float distance)
{
	int limit_over = OFF;
	if(degree_gap > 90){
		degree_gap = 180 - degree_gap;
		limit_over = ON;
		}
	if(degree_gap < -90){
		degree_gap = -degree_gap - 180;
		limit_over = ON;
		}
	
	if(limit_over == OFF){
		return (distance * sin(convert_radian(90 - fabs(degree_gap))));
	}else{
		return((-1)*distance * sin(convert_radian(90 - fabs(degree_gap))));//車体の向きに対して垂直方向が後方
	}
}
/******************************************************************************
*	タイトル： 関数get_horizontal_distanceの値を座標、角度から求め、返す
*	  関数名 ： get_horizontal_distance_func
*	  戻り値 ： float 型
*	    引数1： float型 target_x   目標値の座標
*	    引数2： float型 target_y
*	    引数3： float型 x_now　　現在地
*	    引数4： float型 y_now
*	    引数5： float型 degree_now 　　今の車体の角度
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_horizontal_distance_func(float target_x,float target_y,float x_now,float y_now,float degree_now)
{
	return(get_horizontal_distance(get_gap_degree(get_target_degree(target_x,target_y,x_now,y_now),degree_now),get_distance(target_x,target_y,x_now,y_now)));
}
/******************************************************************************
*	タイトル： 関数get_vertical_distanceの値を座標、角度から求め、返す
*	  関数名 ： get_vertical_distance_func
*	  戻り値 ： float 型
*	    引数1： float型 target_x   目標値の座標
*	    引数2： float型 target_y
*	    引数3： float型 x_now　　現在地
*	    引数4： float型 y_now
*	    引数5： float型 degree_now 　　今の車体の角度
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/08/30
******************************************************************************/
float get_vertical_distance_func(float target_x,float target_y,float x_now,float y_now,float degree_now)
{
	return(get_vertical_distance(get_gap_degree(get_target_degree(target_x,target_y,x_now,y_now),degree_now),get_distance(target_x,target_y,x_now,y_now)));
}
/******************************************************************************
*	タイトル ： 左タイヤの出力リセット
*	  関数名 ： Deadtime_left_tire
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Deadtime_left_tire(void)
{
	LEFT_TIRE_CW = OFF;
	LEFT_TIRE_CCW = OFF;
	LEFT_TIRE_DUTY = OFF;
}
/******************************************************************************
*	タイトル ： 左タイヤ動作
*	  関数名 ： Move_left_tire
*	  戻り値 ： void型
*	    引数1： float型 left_duty 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Move_left_tire(float left_duty)
{
	static int i = 0;
	static float left_duty_old = 0.0;
	//int left_duty = 0;
	
	if(left_duty == BRAKE){
		left_duty = 0.0;
	}
	
	if(((left_duty > 0.0) && (left_duty_old > 0.0)) || ((left_duty < 0.0) && (left_duty_old < 0.0))){
		if(fabs(left_duty - left_duty_old) >= 80.0){
			left_duty = (left_duty + left_duty_old) / 2.000;
		}else{
			left_duty = left_duty;
		}
	}
	
	//left_duty_row = (left_duty_row + left_duty_old + left_duty_old_2) / 3.0;
	//left_duty = (int)left_duty_row;
	//left_duty_old = left_duty_row;
	//left_duty_old_2 = left_duty_old;
	
	if(left_duty < 0){
		if(i != 0){
			Deadtime_left_tire();
			if(g_left_motor_timer_count >= 10){
				i = 0;
			}
		}else{
			g_left_motor_timer_count = 0;
			left_duty *= (-1);
			LEFT_TIRE_CW = OFF;
			LEFT_TIRE_CCW = ON;
			i = 0;
		}
	}else if(left_duty == BRAKE){
		if(i != 1){
			Deadtime_left_tire();
			if(g_left_motor_timer_count >= 10){
				i = 1;
			}
		}else{
			g_left_motor_timer_count = 0;
			LEFT_TIRE_CW = ON;
			LEFT_TIRE_CCW = ON;
			left_duty = 100;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_left_tire();
			if(g_left_motor_timer_count >= 10){
				i = 2;
			}	
		}else{
			g_left_motor_timer_count = 0;
			LEFT_TIRE_CW = ON;
			LEFT_TIRE_CCW = OFF;
			i = 2;
		}
	}
	
	if(left_duty > 10){
		left_duty = Limit_ul(LIMIT_MOTOR_DUTY_TIRE,0.0,left_duty);
		LEFT_TIRE_DUTY = ((PWM_PERIOD * left_duty) / 100);
	}else{
		Deadtime_left_tire();
	}
	
	left_duty_old = left_duty;
}
/******************************************************************************
*	タイトル ： 右タイヤの出力リセット
*	  関数名 ： Deadtime_right_tire
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Deadtime_right_tire(void)
{
	RIGHT_TIRE_CW = OFF;
	RIGHT_TIRE_CCW = OFF;
	RIGHT_TIRE_DUTY = OFF;
}
/******************************************************************************
*	タイトル ： 右タイヤの動作
*	  関数名 ： Move_right_tire
*	  戻り値 ： void型
*	    引数1： float型 right_duty 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Move_right_tire(float right_duty)
{
	static int i = 0;
	static float right_duty_old = 0.0;
	
			/*right_duty_old_2 = 0.0;
			*/
	//int right_duty = 0;
	
	if(right_duty == BRAKE){
		right_duty = 0.0;
	}
	
	if(((right_duty > 0.0) && (right_duty_old > 0.0)) || ((right_duty < 0.0) && (right_duty_old < 0.0))){
		if(fabs(right_duty - right_duty_old) >= 80.0){
			right_duty = (right_duty + right_duty_old) / 2.000;
		}else{
			right_duty = right_duty;
		}
	}
	
	//right_duty = (int)right_duty_row;
	
	if(right_duty < 0){
		if(i != 0){
			Deadtime_right_tire();
			if(g_right_motor_timer_count >= 10){
				i = 0;
			}
		}else{
			g_right_motor_timer_count = 0;
			right_duty *= (-1);
			RIGHT_TIRE_CW = OFF;
			RIGHT_TIRE_CCW = ON;
			i = 0;
		}
	}else if(right_duty == BRAKE){
		if(i != 1){
			Deadtime_right_tire();
			if(g_right_motor_timer_count >= 10){
				i = 1;
			}
		}else{
			g_right_motor_timer_count = 0;
			RIGHT_TIRE_CW = ON;
			RIGHT_TIRE_CCW = ON;
			right_duty = 100.0;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_right_tire();
			if(g_right_motor_timer_count >= 10){
				i = 2;
			}
		}else{
			g_right_motor_timer_count = 0;
			RIGHT_TIRE_CW = ON;
			RIGHT_TIRE_CCW = OFF;
			i = 2;
		}
	}
	
	if(right_duty > 10){
		right_duty =	Limit_ul(LIMIT_MOTOR_DUTY_TIRE , 0	, right_duty);
		RIGHT_TIRE_DUTY = ((PWM_PERIOD * right_duty) / 100.0);
		}
	else{
		Deadtime_right_tire();
		}
	
	right_duty_old = right_duty;
}
/******************************************************************************
*	タイトル ： 後ろタイヤの出力リセット
*	  関数名 ： Deadtime_back_tire
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Deadtime_back_tire(void)
{
	BACK_TIRE_CW = OFF;
	BACK_TIRE_CCW = OFF;
	BACK_TIRE_DUTY = OFF;
}
/******************************************************************************
*	タイトル ：後ろタイヤ動作
*	  関数名 ： Move_back_tire
*	  戻り値 ： void型
*	    引数1： float型 back_duty 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Move_back_tire(float back_duty)
{
	static int i = 0;
	static float back_duty_old = 0.0;
			/*back_duty_old_2 = 0.0;*/
	//int back_duty = 0;
	
	if(back_duty == BRAKE){
		back_duty = 0.0;
	}
		
	//back_duty_row = (back_duty_row + back_duty_old + back_duty_old_2) / 3.0;
	//back_duty = (int)back_duty_row;
	//back_duty_old = back_duty_row;
	//back_duty_old_2 = back_duty_old;
	
	if(((back_duty > 0.0) && (back_duty_old > 0.0)) || ((back_duty < 0.0) && (back_duty_old < 0.0))){
		if(fabs(back_duty - back_duty_old) >= 80.0){
			back_duty = (back_duty + back_duty_old) / 2.000;
		}else{
			back_duty = back_duty;
		}
	}
	
	if(back_duty < 0){
		if(i != 0){
			Deadtime_back_tire();
			if(g_back_motor_timer_count >= 10){
				i = 0;
			}
		}else{
			g_back_motor_timer_count = 0;
			back_duty *= (-1);
			BACK_TIRE_CW = OFF;
			BACK_TIRE_CCW = ON;
			i = 0;
		}
	}else if(back_duty == BRAKE){
		if(i != 1){
			Deadtime_back_tire();
			if(g_back_motor_timer_count >= 10){
				i = 1;
			}
		}else{
			g_back_motor_timer_count = 0;
			BACK_TIRE_CW = ON;
			BACK_TIRE_CCW = ON;
			back_duty = LIMIT_MOTOR_DUTY_TIRE;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_back_tire();
			if(g_back_motor_timer_count >= 10){
				i = 2;
			}
		}else{
			g_back_motor_timer_count = 0;
			BACK_TIRE_CW = ON;
			BACK_TIRE_CCW = OFF;
			i = 2;
		}
	}
	
	if(back_duty > 10){
		back_duty = Limit_ul(LIMIT_MOTOR_DUTY_TIRE,		0	,back_duty);
		BACK_TIRE_DUTY = ((PWM_PERIOD * back_duty) / 100);
	}else{
		Deadtime_back_tire();
	}
	
	back_duty_old = back_duty;
}
/******************************************************************************
*	タイトル ： モータ関数
*	  関数名 ： Move
*	  戻り値 ： void型
*	    引数1： float型 left_duty
*	    引数2： float型 right_duty
*	    引数3： float型 back_duty
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/24
******************************************************************************/
void Move(float left_duty,float right_duty,float back_duty)
{
	Move_left_tire(left_duty);
	Move_right_tire(right_duty);
	Move_back_tire(back_duty);
}
/******************************************************************************
*	タイトル ： リフトアームの出力リセット
*	  関数名 ： Deadtime_lift_arm
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Deadtime_lift_arm(void)
{
	LIFT_ARM_UP = OFF;
	LIFT_ARM_DOWN = OFF;
	LIFT_ARM_DUTY = OFF;
}
/******************************************************************************
*	タイトル ： リフトアーム動作
*	  関数名 ： Move_lift_arm
*	  戻り値 ： void型
*	    引数1 ：float型 lift_duty 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Motor_lift_arm(float lift_duty)
{
	static int i = 0;
	
	if(lift_duty < 0){
		if(i != 0){
			Deadtime_lift_arm();
			i = 0;
		}else{
			lift_duty *= (-1.0);
			LIFT_ARM_UP = OFF;
			LIFT_ARM_DOWN = ON;
			i = 0;
		}
	}else if(lift_duty == BRAKE){
		if(i != 1){
			Deadtime_lift_arm();
			i = 1;
		}else{
			LIFT_ARM_UP = ON;
			LIFT_ARM_DOWN = ON;
			lift_duty = 100.0;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_lift_arm();
			i = 2;
		}else{
			LIFT_ARM_UP = ON;
			LIFT_ARM_DOWN = OFF;
			lift_duty = lift_duty;
			i = 2;
		}
	}
	
	if(lift_duty > 3.0){
		lift_duty = Limit_ul(LIMIT_MOTOR_DUTY_TIRE,0.0,lift_duty);
		LIFT_ARM_DUTY = PWM_PERIOD * lift_duty / 100.0;
	}else{
		Deadtime_lift_arm();
	}
}
/******************************************************************************
*	タイトル ： シーソー・ブランコアームの出力リセット
*	  関数名 ： Deadtime_seesaw_swing_arm
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Deadtime_seesaw_arm(void)
{
	SEESAW_ARM_PUSH = OFF;
	SEESAW_ARM_PULL = OFF;
	SEESAW_ARM_DUTY = OFF;
}
/******************************************************************************
*	タイトル ：シーソーアーム動作
*	  関数名 ： Move_seesaw_swing_arm
*	  戻り値 ： void型
*	    引数1 ：float型 lift_duty 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Motor_seesaw_arm(float pwm_persent)
{
	static int i = 0;
	
	if(pwm_persent < 0){
		if(i != 0){
			Deadtime_seesaw_arm();
			i = 0;
		}else{
			pwm_persent *= (-1.0);
			SEESAW_ARM_PUSH = OFF;
			SEESAW_ARM_PULL = ON;
			i = 0;
		}
	}else if(pwm_persent == BRAKE){
		if(i != 1){
			Deadtime_seesaw_arm();
			i = 1;
		}else{
			SEESAW_ARM_PUSH = ON;
			SEESAW_ARM_PULL = ON;
			pwm_persent = 100.0;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_seesaw_arm();
			i = 2;
		}else{
			SEESAW_ARM_PUSH = ON;
			SEESAW_ARM_PULL = OFF;
			pwm_persent = pwm_persent;
			i = 2;
		}
	}
	
	if(pwm_persent > 10.0){
		pwm_persent = Limit_ul(LIMIT_MOTOR_DUTY_ARM,0.0,pwm_persent);
		SEESAW_ARM_DUTY = PWM_PERIOD * pwm_persent / 100.0;
	}else{
		Deadtime_seesaw_arm();
	}
}
/******************************************************************************
*	タイトル ： 上アームの傾き出力リセット
*	  関数名 ： Deadtime_top_arm_tilt
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Deadtime_top_arm_tilt(void)
{
	TOP_ARM_TILT = OFF;
	TOP_ARM_PARALLEL = OFF;
	TOP_ARM_TILT_DUTY = OFF;
}
/******************************************************************************
*	タイトル ： 上アーム傾き動作
*	  関数名 ： Move_top_arm_tilt
*	  戻り値 ： void型
*	    引数1 ：float型 pwm_persent
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Motor_top_arm_tilt(float pwm_persent)
{
	static int i = 0;
	
	if(pwm_persent < 0){
		if(i != 0){
			Deadtime_top_arm_tilt();
			i = 0;
		}else{
			pwm_persent *= (-1.0);
			TOP_ARM_TILT = OFF;
			TOP_ARM_PARALLEL = ON;
			i = 0;
		}
	}else if(pwm_persent == BRAKE){
		if(i != 1){
			Deadtime_top_arm_tilt();
			i = 1;
		}else{
			TOP_ARM_TILT = ON;
			TOP_ARM_PARALLEL = ON;
			pwm_persent = 100.0;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_top_arm_tilt();
			i = 2;
		}else{
			TOP_ARM_TILT = ON;
			TOP_ARM_PARALLEL = OFF;
			pwm_persent = pwm_persent;
			i = 2;
		}
	}
	
	if(pwm_persent > 5.0){
		pwm_persent = Limit_ul(LIMIT_MOTOR_DUTY_TIRE,0.0,pwm_persent);
		TOP_ARM_TILT_DUTY = PWM_PERIOD * pwm_persent / 100.0;
	}else{
		Deadtime_top_arm_tilt();
	}
}
/******************************************************************************
*	タイトル ： 上アームの出力リセット
*	  関数名 ： Deadtime_top_arm
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Deadtime_top_arm(void)
{
	TOP_ARM_PUSH = OFF;
	TOP_ARM_PULL = OFF;
	TOP_ARM_DUTY = OFF;
}
/******************************************************************************
*	タイトル ：上アーム前後動作
*	  関数名 ： Motor_top_arm_turn
*	  戻り値 ： void型
*	    引数1： float型 pwm_persent
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Motor_top_arm(float pwm_persent)
{
	static int i = 0;
	
	if(pwm_persent < 0){
		if(i != 0){
			Deadtime_top_arm();
			i = 0;
		}else{
			pwm_persent *= (-1.0);
			TOP_ARM_PUSH = OFF;
			TOP_ARM_PULL = ON;
			i = 0;
		}
	}else if(pwm_persent == BRAKE){
		if(i != 1){
			Deadtime_top_arm();
			i = 1;
		}else{
			TOP_ARM_PUSH = ON;
			TOP_ARM_PULL = ON;
			pwm_persent = 100.0;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_top_arm();
			i = 2;
		}else{
			TOP_ARM_PUSH = ON;
			TOP_ARM_PULL = OFF;
			pwm_persent = pwm_persent;
			i = 2;
		}
	}
	
	if(pwm_persent > 5.0){
		pwm_persent = Limit_ul(LIMIT_MOTOR_DUTY_ARM,0.0,pwm_persent);
		TOP_ARM_DUTY = PWM_PERIOD * pwm_persent / 100.0;
	}else{
		Deadtime_top_arm();
	}
}
/******************************************************************************
*	タイトル ： 上アームの回転出力リセット
*	  関数名 ： Deadtime_top_arm_turn
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/12/5
******************************************************************************/
void Deadtime_top_arm_turn(void)
{
	TOP_ARM_CW = OFF;
	TOP_ARM_CCW = OFF;
	TOP_ARM_TURN_DUTY = OFF;
}
/******************************************************************************
*	タイトル ：上アーム回転動作
*	  関数名 ： Motor_top_arm_turn
*	  戻り値 ： void型
*	    引数1： float型 pwm_persent
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Motor_top_arm_turn(float pwm_persent)
{
	static int i = 0;
	
	if(pwm_persent < 0){
		if(i != 0){
			Deadtime_top_arm_turn();
			i = 0;
		}else{
			pwm_persent *= (-1.0);
			TOP_ARM_CW = OFF;
			TOP_ARM_CCW = ON;
			i = 0;
		}
	}
	else if(pwm_persent == BRAKE){
		if(i != 1){
			Deadtime_top_arm_turn();
			i = 1;
		}else{
			TOP_ARM_CW = ON;
			TOP_ARM_CCW = ON;
			pwm_persent = 100.0;
			i = 1;
		}
	}else{
		if(i != 2){
			Deadtime_top_arm_turn();
			i = 2;
		}else{
			TOP_ARM_CW = ON;
			TOP_ARM_CCW = OFF;
			pwm_persent = pwm_persent;
			i = 2;
		}
	}
	
	if(pwm_persent > 5.0){
		pwm_persent = Limit_ul(LIMIT_MOTOR_DUTY_ARM,0.0,pwm_persent);
		TOP_ARM_TURN_DUTY = PWM_PERIOD * pwm_persent / 100.0;
	}else{
		Deadtime_top_arm_turn();
	}
}

/******************************************************************************
*	タイトル ： 左オムニタイヤの出力決定
*	  関数名 ： get_motor_output_l
*	  戻り値 ： float型
*	    引数1 ：float型 motor_output_x
*	    引数2 ：float型 motor_output_y
*	    引数3 ：float型 degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/11/21
******************************************************************************/
float get_motor_output_l(float motor_output_x,float motor_output_y,float degree_now)
{
	float 	motor_output_l = 0.0,
		degree_reverse_x = 0.0,
		degree_reverse_y = 0.0;
	
	if(motor_output_x < 0.0){
		degree_reverse_x = 180.0;
	}else{
		degree_reverse_x = 0.0;
		}
	if(motor_output_y < 0.0){
		degree_reverse_y = 180.0;
	}else{
		degree_reverse_y = 0.0;
	}
	
	motor_output_l = fabs(motor_output_x) * cos(convert_radian(degree_now + (150.0 + degree_reverse_x))) + fabs(motor_output_y) * sin(convert_radian(degree_now + (150.0 + degree_reverse_y)));
	return(motor_output_l);
}
/******************************************************************************
*	タイトル ： 右オムニタイヤの出力決定
*	  関数名 ： get_motor_output_r
*	  戻り値 ： float型
*	    引数1 ：float型 motor_output_x
*	    引数2 ：float型 motor_output_y
*	    引数3 ：float型 degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/11/21
******************************************************************************/
float get_motor_output_r(float motor_output_x,float motor_output_y,float degree_now)
{
	float 	motor_output_r = 0.0,
		degree_reverse_x = 0.0,
		degree_reverse_y = 0.0;
	
	if(motor_output_x < 0.0){
		degree_reverse_x = 180.0;
	}else{
		degree_reverse_x = 0.0;
		}
	if(motor_output_y < 0.0){
		degree_reverse_y = 180.0;
	}else{
		degree_reverse_y = 0.0;
	}
	
	motor_output_r = fabs(motor_output_x) * cos(convert_radian(degree_now +( 30.0 + degree_reverse_x))) + fabs(motor_output_y) * sin(convert_radian(degree_now + (30.0 + degree_reverse_y)));
	return(motor_output_r);
}
/******************************************************************************
*	タイトル ： 後ろオムニタイヤの出力決定
*	  関数名 ： get_motor_output_b
*	  戻り値 ： float型
*	    引数1 ：float型 motor_output_x
*	    引数2 ：float型 motor_output_y
*	    引数3 ：float型 degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/11/21
******************************************************************************/
float get_motor_output_b(float motor_output_x,float motor_output_y,float degree_now)
{
	float 	motor_output_b = 0.0,
		degree_reverse_x = 0.0,
		degree_reverse_y = 0.0;
	
	if(motor_output_x < 0.0){
		degree_reverse_x = 180.0;
	}else{
		degree_reverse_x = 0.0;
		}
	if(motor_output_y < 0.0){
		degree_reverse_y = 180.0;
	}else{
		degree_reverse_y = 0.0;
	}
	
	motor_output_b = fabs(motor_output_x) * cos(convert_radian(degree_now  + (degree_reverse_x - 90.0))) + fabs(motor_output_y) * sin(convert_radian(degree_now +( degree_reverse_y - 90.0)));
	return(motor_output_b);
}
/******************************************************************************
*     タイトル ： 目標角速度の算出(台形制御)
*	  関数名 ： get_target_omega
*	  戻り値 ： float型
*	   引数1 ： int型 mode_turn
*	   引数2 ： float型 a_up_turn
*	   引数3 ： float型 a_down_turn
*	   引数4 ： float型 start_degree
*	   引数5 ： float型 degree_now
*	   引数6 ： float型 target_degree
*	   引数7 ： float型 max_omega
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/09/24
******************************************************************************/
float get_target_omega(int mode_turn,float a_up_turn,float a_down_turn,float start_degree,float degree_now,float target_degree,float max_omega)
{
	float 	target_omega = 0.0,	gap_all = 0.0,	gap_s_n = 0.0,	gap_n_t = 0.0;
	int turn_direction = CW;
	
	gap_all = get_gap_degree(target_degree,start_degree);
	gap_s_n = get_gap_degree(degree_now,start_degree);
	gap_n_t = get_gap_degree(target_degree,degree_now);
	
	//回転方向の分岐
	if(gap_all >= 0){
		turn_direction = CCW;
	}else{
		turn_direction = CW;
	}
	
	//目標速度の計算モード     mode_turn  →  0:台形制御   1:台形制御の前半(終点で最高速)  2:台形制御の後半(始点で最高速)
	//omega = √(2* a * s)
	if(mode_turn == 0){
		if(fabs(gap_s_n) < fabs(gap_all / 2)){//スタートから中間まで
			target_omega = pow( 2 * a_up_turn * fabs(gap_s_n),0.5);
			}
		else if(fabs(gap_n_t) < fabs(gap_all / 2)){//中間のとき
			target_omega = pow( 2 * (a_up_turn + a_down_turn) *0.5 * fabs(gap_all / 2) , 0.5);
			}
		else{//中間から終わりまで
			target_omega = pow(2 * a_down_turn * fabs(gap_n_t), 0.5);
			}
	}else if(mode_turn == 1){
		target_omega =  pow( 2 * a_up_turn * fabs(gap_s_n),0.5);
	}else{
		target_omega = pow(2 * a_down_turn * fabs(gap_n_t), 0.5);
	}
	
	if(turn_direction == CCW){//回転方向が反時計回りのとき
		if(target_omega >= max_omega){
			target_omega = max_omega;
		}
		if(gap_n_t < 0.0){
			target_omega *= (-1);
		}
	}else if(turn_direction == CW){//回転方向が時計回りのとき
		target_omega *= (-1);
		if(gap_n_t >= 0.0){
			target_omega *= (-1);
		}
		if(target_omega < (-1) * max_omega){
			target_omega = (-1) * max_omega;
		}
	}
	
	return(target_omega); 
}
/******************************************************************************
*	タイトル ： シーソーアームの上下速度制御
*	  関数名 ： Move_seesaw_arm_lift_velocity
*	  戻り値 ： void
*	    引数1 ：float型  target_z
*		引数2  :  int型	 step
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
void Move_seesaw_arm_lift_velocity(float target_z,int step)
{
	float distance_rest = 0.0,
		motor_output = 0.0,
		gap_now = 0.0,
		p_gain = 1.0,
		a_up = 1500,
		a_down = 1500,
		max_velocity = 2000;
	static float target_velocity = 0.0,	gap_old = 0.0;	
	static int step_old = 0,	chapter = 0;
	
	//順送りのステップが変化したとき
	if(step != step_old){
		target_velocity = 0.0;
		gap_old = 0.0;
		chapter = 0;
	}
	
	distance_rest = fabs(target_z - g_z_c_seesaw_arm);
	
	if(chapter == 0){
		if(distance_rest > 0.5 * max_velocity * max_velocity / a_down ){
			if(g_z_c_seesaw_arm <=  target_z){
				if(target_velocity < max_velocity){
					target_velocity += (a_up * 0.001 * INTERRUPT_TIME);
				}else{
					target_velocity = max_velocity;
				}
			}else{
				if(target_velocity > (-1) * max_velocity){
					target_velocity -= (a_up * 0.001 * INTERRUPT_TIME);
				}else{
					target_velocity = (-1)*max_velocity;
				}
			}
		}else{
			if(g_z_c_seesaw_arm <= target_z){
				target_velocity = sqrtf( 2 * a_down * distance_rest);
			}else{
				target_velocity = (-1) * sqrtf( 2 * a_down * distance_rest);
			}
		}
		gap_now = target_velocity - g_seesaw_arm_velocity_z;
		motor_output = gap_now * p_gain;
		
		if(distance_rest < 5.0){
			chapter ++;
		}
	}else if(chapter == 1){//上下ロック
		gap_now  = target_z - g_z_c_seesaw_arm;
		motor_output = gap_now * KP_LIFT_ARM_LOCK + ((gap_now - gap_old) * KD_LIFT_ARM_LOCK);
		gap_old = gap_now;
	}
	
	if(( (LIMIT_SW_LIFT_ARM_HIGH == ON ) && (motor_output > 0) ) || ( (LIMIT_SW_LIFT_ARM_LOW == ON) && (motor_output < 0) )){
		Deadtime_lift_arm();
	}else{
		Motor_lift_arm(motor_output);
	}
	step_old = step;
}
/******************************************************************************
*	タイトル ：シーソーアーム指定高さ出力
*	  関数名 ： Move_seesaw_arm_lift
*	  戻り値 ： void型
*	    引数1： float型 target_z 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
/*void Move_seesaw_arm_lift(float target_z)
{
	float motor_output = 0.0,
		gap_now = 0.0,
		p_gain = KP_LIFT_ARM_DOWN,
		d_gain = KD_LIFT_ARM_DOWN;
	static float gap_old = 0.0;	
	
	gap_now = target_z - g_z_c_seesaw_arm;
	
	if(gap_now > 0){
		p_gain = KP_LIFT_ARM_UP;
		d_gain = KD_LIFT_ARM_UP;
	}
	
	motor_output = (gap_now * p_gain) + (d_gain * (gap_now - gap_old ));
	gap_old = gap_now;
	
	if(( (LIMIT_SW_LIFT_ARM_HIGH == ON ) && (motor_output > 0) ) || ( (LIMIT_SW_LIFT_ARM_LOW == ON) && (motor_output < 0) )){
		Deadtime_lift_arm();
	}else{
		Motor_lift_arm(motor_output);
	}
}*/
/*Move_swing_arm_lift_velocity(float target_z,int step)
{
	float distance_rest = 0.0,
		motor_output = 0.0,
		gap_now = 0.0,
		p_gain = 0.1,
		a_up = 1000,
		a_down = 1000,
		max_velocity = 2000;
	static float target_velocity = 0.0,	gap_old = 0.0;	
	static int step_old = 0,	chapter = 0;
	
	//順送りのステップが変化したとき
	if(step != step_old){
		target_velocity = 0.0;
		gap_old = 0.0;
		chapter = 0;
	}
	
	distance_rest = fabs(target_z - g_z_c_swing_arm);	
	if(chapter == 0){
		if(distance_rest > 0.5 * max_velocity * max_velocity / a_down ){
			if(g_z_c_swing_arm <=  target_z){
				if(target_velocity < max_velocity){
					target_velocity += (a_up * 0.001 * INTERRUPT_TIME);
				}else{
					target_velocity = max_velocity;
				}
			}else{
				if(target_velocity > (-1) * max_velocity){
					target_velocity -= (a_up * 0.001 * INTERRUPT_TIME);
				}else{
					target_velocity = (-1)*max_velocity;
				}
			}
		}else{
			if(g_z_c_swing_arm <= target_z){
				target_velocity = sqrtf( 2 * a_down * distance_rest);
			}else{
				target_velocity = (-1) * sqrtf( 2 * a_down * distance_rest);
			}
		}
		gap_now = target_velocity - g_swing_arm_velocity_z;
		motor_output = gap_now * p_gain;
		
		if(distance_rest < 5.0){
			chapter ++;
		}
	}else if(chapter == 1){//上下ロック
		gap_now  = target_z - g_z_c_swing_arm;
		motor_output = gap_now * KP_LIFT_ARM_LOCK + ((gap_now - gap_old) * KD_LIFT_ARM_LOCK);
		gap_old = gap_now;
	}
	
	if(( (LIMIT_SW_LIFT_ARM_HIGH == ON ) && (motor_output > 0) ) || ( (LIMIT_SW_LIFT_ARM_LOW == ON) && (motor_output < 0) )){
		Deadtime_lift_arm();
	}else{
		Motor_lift_arm(motor_output);
	}	
	step_old = step;
}*/
/******************************************************************************
*	タイトル ：ブランコアーム指定高さ出力
*	  関数名 ： Move_swing_arm_lift
*	  戻り値 ： void型
*	    引数1： float型 target_z 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Move_swing_arm_lift(float target_z)
{
	float motor_output = 0.0,
		gap_now = 0.0,
		p_gain = KP_LIFT_ARM_DOWN,
		d_gain = KD_LIFT_ARM_DOWN;
	static float gap_old = 0.0;	
	
	gap_now = target_z - g_z_c_swing_arm;
	
	if(gap_now > 0){
		p_gain = KP_LIFT_ARM_UP;
		d_gain = KD_LIFT_ARM_UP;
	}
	
	motor_output = (gap_now * p_gain) + (d_gain * (gap_now - gap_old ));
	gap_old = gap_now;
	
	if(( (LIMIT_SW_LIFT_ARM_HIGH == ON ) && (motor_output > 0) ) || ( (LIMIT_SW_LIFT_ARM_LOW == ON) && (motor_output < 0) )){
		Deadtime_lift_arm();
	}else{
		Motor_lift_arm(motor_output);
	}
}
/******************************************************************************
*	タイトル ： 上アームの上下速度制御
*	  関数名 ： Move_top_arm_lift_velocity
*	  戻り値 ： void
*	    引数1 ：float型  target_z
*		引数2  :  int型	 step
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
Move_top_arm_lift_velocity(float target_z,int step)
{
	float distance_rest = 0.0,
		motor_output = 0.0,
		gap_now = 0.0,
		p_gain = 0.6,
		a_up = 1000,
		a_down = 1000,
		max_velocity = 2000;
	static float target_velocity = 0.0,	gap_old = 0.0;	
	static int step_old = 0,	chapter = 0;
	
	//順送りのステップが変化したとき
	if(step != step_old){
		target_velocity = 0.0;
		gap_old = 0.0;
		chapter = 0;
	}
	
	if(step == 4){
		a_up = 1500;
		a_down = 1500;
		max_velocity = 2000;
	}
	
	if(step == 28){
		target_z = target_z +  (2 * CAD_SIZE_TOP_ARM_7 * sin(convert_radian(g_top_arm_tilt_degree / 2))) * sin(convert_radian(g_top_arm_tilt_degree / 2));
	}
	
	distance_rest = fabs(target_z - g_z_c_top_arm);
	if(chapter == 0){
		if(distance_rest > 0.5 * max_velocity * max_velocity / a_down ){
			if(g_z_c_top_arm <=  target_z){
				if(target_velocity < max_velocity){
					target_velocity += (a_up * 0.001 * INTERRUPT_TIME);
				}else{
					target_velocity = max_velocity;
				}
			}else{
				if(target_velocity > (-1) * max_velocity){
					target_velocity -= (a_up * 0.001 * INTERRUPT_TIME);
				}else{
					target_velocity = (-1)*max_velocity;
				}
			}
		}else{
			if(g_z_c_top_arm <= target_z){
				target_velocity = sqrtf( 2 * a_down * distance_rest);
			}else{
				target_velocity = (-1) * sqrtf( 2 * a_down * distance_rest);
			}
		}
		gap_now = target_velocity - g_top_arm_velocity_z;
		motor_output = gap_now * p_gain;
		
		if(distance_rest < 5.0){
			chapter ++;
		}
	}else if(chapter == 1){//上下ロック
		gap_now  = target_z - g_z_c_top_arm;
		motor_output = gap_now * KP_LIFT_ARM_LOCK + ((gap_now - gap_old) * KD_LIFT_ARM_LOCK);
		gap_old = gap_now;
	}
	
	if(( (LIMIT_SW_LIFT_ARM_HIGH == ON ) && (motor_output > 0) ) || ( (LIMIT_SW_LIFT_ARM_LOW == ON) && (motor_output < 0) )){
		g_buzzer_io = ON;
		Deadtime_lift_arm();
	}else{
		g_buzzer_io = OFF;
		Motor_lift_arm(motor_output);
	}
	step_old = step;
}
/******************************************************************************
*	タイトル ：上アーム指定高さ出力
*	  関数名 ： Move_top_arm_lift
*	  戻り値 ： void型
*	    引数1： float型 target_z 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
/*void Move_top_arm_lift(float target_z)
{
	float motor_output = 0.0,
		gap_now = 0.0,
		p_gain = KP_LIFT_ARM_DOWN,
		d_gain = KD_LIFT_ARM_DOWN;
	static float gap_old = 0.0;	
	gap_now = target_z - g_z_c_top_arm;
	if(gap_now > 0){
		p_gain = KP_LIFT_ARM_UP;
		d_gain = KD_LIFT_ARM_UP;
	}
	motor_output = (gap_now * p_gain) + (d_gain * (gap_now - gap_old ));
	gap_old = gap_now;
	
	if(( (LIMIT_SW_LIFT_ARM_HIGH == ON ) && (motor_output > 0) ) || ( (LIMIT_SW_LIFT_ARM_LOW == ON) && (motor_output < 0) )){
		Deadtime_lift_arm();
	}else{
		Motor_lift_arm(motor_output);
	}
}*/
/******************************************************************************
*	タイトル : シーソーアーム指定長さ出力
*	  関数名 ： Move_seesaw_swing_arm_turn
*	  戻り値 ： void型
*	    引数1： float型 target_degree
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Move_seesaw_arm_length(float target_length)
{
	float motor_output = 0.0,
		gap_now = 0.0;
		/*p_gain = 2.30,
		d_gain = 60.0;*/
	static float gap_old = 0.0;
	
	gap_now = target_length - g_seesaw_arm_length;
	motor_output = (gap_now * KP_SEESAW_ARM_LENGTH) + (KD_SEESAW_ARM_LENGTH * (gap_now - gap_old));
	gap_old = gap_now;
	
	if(fabs(gap_now) < LIMIT_SEESAW_ARM_GAP){
		motor_output = 0.0;
	}
	
	if( ((LIMIT_SW_SEESAW_ARM_BACK == ON ) && (motor_output > 0)) || ((LIMIT_SW_SEESAW_ARM_FRONT == ON) && (motor_output < 0)) ){
		Deadtime_seesaw_arm();
	}else{
		Motor_seesaw_arm(motor_output);
	}
}
/******************************************************************************
*	タイトル ：上アーム指定角度出力
*	  関数名 ： Move_top_arm_turn
*	  戻り値 ： void型
*	    引数1： float型 target_degree 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Move_top_arm_turn(float target_degree)
{
	float motor_output = 0.0,
		gap_now = 0.0;
		/*p_gain = 1.0,
		d_gain = 5.0;*/
	static float gap_old = 0.0;
	
	target_degree = Limit_ul(LIMIT_TOP_ARM_DEGREE,  (-1) * LIMIT_TOP_ARM_DEGREE,  target_degree);
	
	gap_now = target_degree - g_top_arm_degree;
	motor_output = (gap_now * KP_TOP_ARM_TURN) + ((gap_now - gap_old) * KD_TOP_ARM_TURN);
	gap_old = gap_now;
	
	if(((g_top_arm_degree >= LIMIT_TOP_ARM_DEGREE) && (motor_output > 0)) || ((g_top_arm_degree <= (-1) * LIMIT_TOP_ARM_DEGREE) &&( motor_output < 0))){
		Deadtime_top_arm_turn();
	}else{
		Motor_top_arm_turn(motor_output);
	}
}
/******************************************************************************
*	タイトル ： 上アーム回転角速度制御
*	  関数名 ： Move_top_arm_turn_omega
*	  戻り値 ： void
*	    引数1 ：float型  start_degree
*		引数2	: float型	target_degree
*		引数3  :  int型	 step
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
void Move_top_arm_turn_omega(float start_degree,float target_degree,int step)
{
	float motor_output = 0.0,
		gap_now_omega = 0.0,
		gap_now_turn = 0.0,
		p_gain = 0.3,
		d_gain = 0.0,
		target_omega = 0.0;
	static float gap_old_omega = 0.0,  gap_old_turn = 0.0;
	static int step_old = 0, flag_end = OFF; 
	
	if(step != step_old){
		flag_end = OFF;
		gap_old_turn = 0.0;
		gap_old_omega = 0.0;
	}
	
	/*if(get_gap_degree(target_degree,  start_degree) >= 0.0){
		turn_direction = CCW;
	}else{
		turn_direction = CW;
	}*/
	
	target_degree = Limit_ul(LIMIT_TOP_ARM_DEGREE,  (-1) * LIMIT_TOP_ARM_DEGREE,  target_degree);

	
	if(flag_end == OFF){
		target_omega = get_target_omega(2,  50,  50,  start_degree,  g_top_arm_degree,  target_degree, 100);
		gap_now_omega = target_omega - g_top_arm_turn_omega;
		motor_output = gap_now_omega * p_gain + (gap_now_omega - gap_old_omega) * d_gain;
		gap_old_omega = gap_now_omega;
		if(fabs(get_gap_degree(target_degree,  g_top_arm_degree)) <= 3.0){
			flag_end = ON;
		}
	}else{
		gap_now_turn = target_degree - g_top_arm_degree;
		motor_output = (gap_now_turn * KP_TOP_ARM_TURN) + ((gap_now_turn - gap_old_turn) * KD_TOP_ARM_TURN);
		gap_old_turn = gap_now_turn;
	}
	
	if(((g_top_arm_degree >= LIMIT_TOP_ARM_DEGREE) && (motor_output > 0)) || ((g_top_arm_degree <= (-1) * LIMIT_TOP_ARM_DEGREE) &&( motor_output < 0))){
		Deadtime_top_arm_turn();
	}else{
		Motor_top_arm_turn(motor_output);
	}
	step_old = step;
	
}
/******************************************************************************
*	タイトル ：上アーム指定長さ出力
*	  関数名 ： Move_top_arm_length
*	  戻り値 ： void型
*	    引数1： float型 target_length 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Move_top_arm_length(float target_length)
{
	float motor_output = 0.0,
		gap_now = 0.0,
		p_gain = KP_TOP_ARM_LENGTH,
		d_gain = KD_TOP_ARM_LENGTH;
	static float gap_old = 0.0;
	
	gap_now = target_length - g_top_arm_length;
	
	if(gap_now < 0.0){
		p_gain = 0.7;
		d_gain = 4.0;
	}
	
	motor_output = (gap_now * p_gain) + ((gap_now - gap_old) * d_gain);
	//motor_output = (gap_now * g_a_value) + ((gap_now - gap_old) * g_b_value);
	gap_old = gap_now;
	
	if(fabs(gap_now) < LIMIT_TOP_ARM_GAP){
		motor_output = 0.0;
	}
	if(( (LIMIT_SW_TOP_ARM_FRONT == ON) && (motor_output < 0) ) || ( (LIMIT_SW_TOP_ARM_BACK == ON) && (motor_output > 0)) ){
		Deadtime_top_arm();
	}else{
		Motor_top_arm(motor_output);
	}
}
/******************************************************************************
*	タイトル ：上アーム指定傾き出力
*	  関数名 ： Move_under_arm_length
*	  戻り値 ： void型
*	    引数1： float型 target_length 
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/01/22
******************************************************************************/
void Move_top_arm_tilt(float target_degree)
{
	float motor_output = 0.0,
		gap_now = 0.0,
		p_gain = KP_TOP_ARM_TILT,
		d_gain = KD_TOP_ARM_TILT;
	static float gap_old = 0.0;
	
	target_degree = Limit_ul(110.0,  -20.0,  target_degree);

	/*
	if((target_degree <= 5.0) && (target_degree >= -5.0)){
		if((g_top_arm_tilt_degree <= 5.0) && (g_top_arm_tilt_degree >= -5.0) && (AR_TOP_CATCH == OFF)){
			p_gain = 70.0;
			d_gain = 2500.0;
		}
	}*/

	gap_now = target_degree - g_top_arm_tilt_degree;
	motor_output = (gap_now * p_gain) + ((gap_now - gap_old) * d_gain);
	gap_old = gap_now;
	
	
	/*
	if(fabs(target_degree - g_top_arm_tilt_degree) <= 0.3){
		motor_output = 0.0;
	}*/
	
	if(((g_top_arm_tilt_degree > 130.0) && (motor_output > 0.0)) || ((g_top_arm_tilt_degree < -40.0) && (motor_output < 0.0))){
		Deadtime_top_arm_tilt();
	}else{
		Motor_top_arm_tilt(motor_output);
	}
}
/******************************************************************************
*	タイトル ： 角度ロック
*	  関数名 ： get_motor_output_turn
*	  戻り値 ： float型
*	    引数1： float型 target_degree
*	    引数2： float型 degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/11/21
******************************************************************************/
float get_motor_output_turn(float target_degree,float degree_now)
{
	float 	motor_output_turn = 0.0,
		gap_now = 0.0;
	static float 	gap_old = 0.0;
	gap_now = get_gap_degree(target_degree,degree_now);
	
	motor_output_turn =  (gap_now * KP_DEGREE_LOCK) + ((gap_now - gap_old) * KD_DEGREE_LOCK);
	gap_old = gap_now;
	
	return(motor_output_turn);
}
/******************************************************************************
*	タイトル ：シーソー周りでの角度ロック（ゲイン高め）
*	  関数名 ： get_motor_output_turn_seesaw
*	  戻り値 ： float
*	    引数1 ：float型  target_degree
*		引数2  :  float型	 degree_now
*		引数3  : int型　chapter
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
float get_motor_output_turn_seesaw(float target_degree,float degree_now,int chapter)
{
	float 	motor_output_turn = 0.0,
		gap_now = 0.0;
	static float 	gap_old = 0.0;
	static int chapter_old = 0;
	
	gap_now = get_gap_degree(target_degree,degree_now);
	
	if(chapter != chapter_old){
		gap_old = 0.0;
	}
	
	motor_output_turn =  (gap_now * KP_SEESAW_CURVE_DEGREE) + ((gap_now - gap_old) * KD_SEESAW_CURVE_DEGREE);
	gap_old = gap_now;
	chapter_old = chapter;
	
	return(motor_output_turn);
}
/******************************************************************************
*	タイトル ： 車体角速度P制御
*	  関数名 ：get_motor_output_turn_omega
*	  戻り値 ： float型
*	    引数1 ：int型 mode
*		引数2  : float型　start_degree
*		引数3	: float型  degree_now
*	    引数4 ： float型　target_degree
*		引数5  : float型　omega_now
*		引数6	: float型  a_up
*		引数7	: float型  a_down
*		引数8	: float型  max_omega
*	  作成者 ：坂下文彦 
*	  作成日 ： 2014/05/27
******************************************************************************/
float get_motor_output_turn_omega(int mode,	  float start_degree,  float degree_now,  float target_degree,  float omega_now,	float a_up,  float a_down,  float max_omega)
{
		float motor_output_turn = 0.0,
				target_omega = 0.0;
		static float target_degree_old = 0.0;
		static int flag = OFF;
		
		if(target_degree != target_degree_old){
			flag = OFF;
		}
		
		if(fabs(get_gap_degree(target_degree,  degree_now)) <= 3.0){
			flag = ON;
		}
		if(flag == ON){
			motor_output_turn = get_motor_output_turn(target_degree,  degree_now);
		}else{
			target_omega = get_target_omega( mode, a_up,  a_down,  start_degree,  degree_now,  target_degree,  max_omega);
			motor_output_turn = (target_omega - omega_now) * KP_OMEGA;
		}
		
		target_degree_old = target_degree;
		
		return (motor_output_turn);
}

struct calc_seesaw
{
	float l;
	float r;
	float b;
}motor_output_seesaw_curve;
/******************************************************************************
*	タイトル ： シーソー周りの曲線走行の出力計算
*	  関数名 ： calculate_motor_output_curve
*	  戻り値 ： void型
*	    引数1 ：float型 x_start
*	    引数2 ：float型 y_start
*	    引数3 ：float型 x_now
*	    引数4 ：float型 y_now
*	    引数5 ：float型 center_x
*	    引数6 ：float型 center_y
*	    引数7 ：float型 target_center_degree
*	    引数8 ：float型 degree_now
*	    引数9 ：float型 target_radius
*	  作成者 ：坂下文彦 
*	  作成日 ： 2013/11/30
******************************************************************************/
void calculate_motor_output_lrb_curve(float x_start,float y_start, float x_now,float y_now ,float center_x,float center_y, float target_center_degree,float degree_now,float target_radius, int step)
{
	float 		a_up = SEESAW_CURVE_A_UP,	a_down = SEESAW_CURVE_A_DOWN,	max_velocity = SEESAW_CURVE_MAX_VELOCITY,	
			center_degree_now = 0.0,		center_degree_gap = 0.0,		center_degree_rest = 0.0,
			radius_now = 0.0,	omega_now = 0.0,	phase_velocity = 0.0,		distance_arc = 0.0,
			motor_output = 0.0,	motor_output_x = 0.0,	motor_output_y = 0.0,	motor_output_velocity = 0.0,	
			motor_output_velocity_l = 0.0,	motor_output_velocity_r = 0.0,	motor_output_velocity_b = 0.0,
			direction_target_degree = 0.0,	degree_reverse_velocity = 0.0,	degree_reverse = 0.0,
			gap_now = 0.0;
	static float target_phase_velocity = 0.0,	center_degree_gap_old = 0.0,	gap_old = 0.0;
	static int step_old = 5;
	
	/*a_up = pick_out_atoz_value('G');
	a_down = pick_out_atoz_value('H');
	max_velocity = pick_out_atoz_value('I');*/
	
	//今の半径
	radius_now = get_distance(center_x  ,center_y,  x_now,  y_now);
	
	//スタート地点からの中心角
	center_degree_now = get_target_degree(x_now,y_now,center_x,center_y);
	
	if(step != step_old){
		target_phase_velocity = 0.0;
		center_degree_gap_old = 0.0;
		gap_old = 0.0;
	}
	step_old = step;
	
	center_degree_gap = get_gap_degree(center_degree_now , get_target_degree(x_start,y_start,center_x,center_y));
	
	//角速度[θ / s] → [radian / s]にしなきゃ位相速度だめ
	omega_now =convert_radian(get_gap_degree(center_degree_gap , center_degree_gap_old)) * (1000 / INTERRUPT_TIME);
	
	//位相速度 v = rω
	phase_velocity = radius_now * omega_now;
	
	//終点と現在の中心角(＋であれば車体右方向に移動、-であれば車体左方向に移動)
	//※get_gap_degree関数を使うと180°付近で±逆転するので使用しない
	center_degree_rest = target_center_degree - center_degree_gap;
	
	//弧の長さ l = rθ    θ[radian]
	distance_arc = fabs(convert_radian(center_degree_rest) * target_radius);
	
	//目標速度
	if(distance_arc > 0.5 * max_velocity * max_velocity / a_down ){
		if(center_degree_rest > 0){
			if(target_phase_velocity < max_velocity){
				target_phase_velocity += (a_up * 0.001 * INTERRUPT_TIME);
			}else{
				target_phase_velocity = max_velocity;
			}
		}else{
			if(target_phase_velocity > (-1) * max_velocity){
				target_phase_velocity -= (a_up * 0.001 * INTERRUPT_TIME);
			}else{
				target_phase_velocity = (-1)*max_velocity;
			}
		}
	}else{
		if(center_degree_rest > 0.0){
			target_phase_velocity = sqrtf( 2 * a_down * distance_arc);
		}else{
			target_phase_velocity = (-1) *  sqrtf( 2 * a_down * distance_arc);
		}
	}
	
	//半径ロック出力
	gap_now =  radius_now - target_radius;//逆であることに注意
	motor_output = (gap_now * KP_SEESAW_RADIUS_LOCK) + ((gap_now - gap_old) * KD_SEESAW_RADIUS_LOCK);
	gap_old = gap_now;
	
	//位相速度出力
	motor_output_velocity = (target_phase_velocity - phase_velocity) * KP_SEESAW_PHASE_VELOCITY;
	
	if(motor_output < 0){//出力が負のとき、角度を180度反転
		degree_reverse = 180.0;
	}else{
		degree_reverse = 0.0;
	}
	//位相速度のPID制御は常に車体正面から±90度方向のベクトル(車体に対して右が正、左が負になるので出力の正負に注意)
	if(motor_output_velocity > 0.0){
		degree_reverse_velocity = 180.0;
	}else{
		degree_reverse_velocity = 0.0;
	}
	//今回は車体が常に中心を向いている
	motor_output_velocity_l = fabs(motor_output_velocity) * sin(convert_radian(degree_reverse_velocity + 150.0));
	motor_output_velocity_r = fabs(motor_output_velocity) * sin(convert_radian(degree_reverse_velocity + 30.0));
	motor_output_velocity_b = fabs(motor_output_velocity) * sin(convert_radian(degree_reverse_velocity - 90.0));
	//現在地と中心座標の角度
	//direction_target_degree = get_target_degree(center_x,center_y,x_now,y_now);
	direction_target_degree = get_target_degree(center_x,center_y,x_now,y_now);
	
	motor_output_x = fabs(motor_output) * cos(convert_radian(direction_target_degree + degree_reverse));
	motor_output_y = fabs(motor_output) * sin(convert_radian(direction_target_degree + degree_reverse));
	
	motor_output_seesaw_curve.l = get_motor_output_l(motor_output_x,motor_output_y,degree_now) + motor_output_velocity_l;
	motor_output_seesaw_curve.r = get_motor_output_r(motor_output_x,motor_output_y,degree_now) + motor_output_velocity_r;
	motor_output_seesaw_curve.b = get_motor_output_b(motor_output_x,motor_output_y,degree_now) + motor_output_velocity_b;	
	
	center_degree_gap_old = center_degree_gap;
}

/******************************************************************************
*	タイトル ： 距離からの各オムニタイヤへの出力計算(PD制御)
*	  関数名 ： calculate_motor_output_lrb_distance
*	  戻り値 ： void型
*	    引数1 ：float型 target_x
*	    引数1 ：float型 target_y
*	    引数1 ：float型 x_now
*	    引数1 ：float型 y_now
*	    引数1 ：float型 degree_now
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/11/30
******************************************************************************/
void calculate_motor_output_lrb_distance(float target_x,float target_y,float x_now,float y_now,float degree_now, int step)
{
	float  target_degree = 0.0,	motor_output = 0.0,	motor_output_x = 0.0,	motor_output_y = 0.0;
	float p_gain = 0.03,d_gain = 0.3;
	float gap_now = 0.0;
	static float gap_old = 0.0;
	static int step_old = 0;
	
	target_degree = get_target_degree(target_x,target_y,x_now,y_now);
		
	gap_now = get_distance(target_x,target_y,x_now,y_now);
	
	if(step != step_old){
		gap_old = gap_now;
	}
	
	motor_output = (p_gain * gap_now) + (d_gain * (gap_now - gap_old));
	gap_old = gap_now;
	
	motor_output_x = motor_output * cos(convert_radian(target_degree));
	motor_output_y = motor_output * sin(convert_radian(target_degree));
	
	g_motor_output_l = get_motor_output_l(motor_output_x,motor_output_y,degree_now);
	g_motor_output_r = get_motor_output_r(motor_output_x,motor_output_y,degree_now);
	g_motor_output_b = get_motor_output_b(motor_output_x,motor_output_y,degree_now);
	
	step_old = step;
}
/******************************************************************************
*	タイトル ： 等角速度制御デューティ
*	  関数名 ： Uniform_duty_absolute_angular
*	  戻り値 ： float型 
*	   引数1 ： float型 target_posture_s  
*	   引数2 ： float型 present_posture_s  
*	  作成者 ： 眞下康宏
*	  作成日 ： 2013/02/16
******************************************************************************/
float Uniform_duty_absolute_angular(float target_posture_s, float present_posture_s)
{
	//未完成の制御なのであとで作り直すこと
	
	static float output = 0;
	const float smooth = 50,
			p = 1.0;
	float upper_output = 0.0;
	if(target_posture_s != 0){
		upper_output = Limit_ul(99, 10, target_posture_s*p);
		//if(Percentage(fabs(present_posture_s), target_posture_s) >= 1){
		if( (fabs(present_posture_s)/target_posture_s) >= 1){
			output = 0;
		}else{
			//output = upper_output*Percentage_inversion(fabs(present_posture_s), target_posture_s);
			output = upper_output* (1-(fabs(present_posture_s)/target_posture_s));
		}
		return (fabs(get_Average(smooth/INTERRUPT_TIME, 5, output)));
	}else{
		return 0;
	}
}

//絶対出力
float Absolute_duty(float max_duty, float target, float now){

	float output_duty = 0.00,
			percentage = 0.00;

	if(target != 0.00){
		 percentage = fabs(now / target);
	}

	if(percentage >= 1.00){
		output_duty = 0.00;
	}else{
		output_duty = max_duty * (1.00 - percentage);
	}
	
	return (output_duty);
}

/******************************************************************************
*	タイトル ： 等速度制御デューティ
*	  関数名 ： Uniform_duty_absolute_velocity
*	  戻り値 ： float型 
*	   引数1 ： float型 target_mm_s  
*	   引数2 ： float型 present_mm_s  
*	  作成者 ： 眞下康宏
*	  作成日 ： 2013/02/16
******************************************************************************/
float Uniform_duty_absolute_velocity(float target_mm_s, float present_mm_s)
{
	//未完成の制御なのであとで作り直すこと
	
	static float output = 0;
	const float smooth = 50,
			p = 0.8;
	float upper_output = 0.0;
	if(target_mm_s != 0){
		upper_output = Limit_ul(99, 30, target_mm_s*p);
		if( (fabs(present_mm_s)/target_mm_s) >= 1){
			output = 0;
		}else{
			output = upper_output* (1-(fabs(present_mm_s)/target_mm_s));
		}
		return (fabs(get_Average(smooth/INTERRUPT_TIME, 4, output)));
	}else{
		return 0;
	}
}
/******************************************************************************
*	タイトル ： 一定速度制御・速度方向
*	  関数名 ： Get_smooth_duty_v
*	  戻り値 ： float型 
*	   引数1 ： float型 target_velocity  
*	  作成者 ： 眞下康宏
*	  作成日 ： 2013/05/11
******************************************************************************/
/*float Get_smooth_duty_v(float target_velocity)
{
	float rtv = 0.0,
		ab_tv = 0.0;
	ab_tv = fabs(target_velocity);
	rtv = (Uniform_duty_absolute_velocity(ab_tv, g_absolute_velocity));
	if(target_velocity >= 0){
	}else{
		 rtv *= -1;
	}
	return (rtv);
}*/


struct calc_velocity
{
	float l;
	float r;
	float b;
}motor_output_velocity;
struct calc_distance
{
	float l;
	float r;
	float b;
}motor_output_distance;
/******************************************************************************
*	タイトル ： 速度台形制御出力計算
*	  関数名 ： calculate_motor_output_lrb_velocity
*	  戻り値 ： void型
*	    引数1： float型 target_x
*	    引数2： float型 target_y
*	    引数3： float型 x_now
*	    引数4： float型 y_now
*	    引数5： float型 degree_now
*	    引数6： float型 a_up
*	    引数7： float型 a_down
*	    引数8： float型 max_velocity
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/03/03
******************************************************************************/
/*void calculate_motor_output_lrb_velocity(float target_x,float target_y,float x_now,float y_now,float degree_now,float a_up,float a_down,float max_velocity, int step)
{
	float direction_velocity = 0.0,	gap_now = 0.0,	motor_output = 0.0,	motor_output_x = 0.0,	motor_output_y = 0.0,
		degree_reverse = 0.0,	distance_rest = 0.0,	direction_target_degree = 0.0,	p_gain = 0.1;
	static float target_velocity = 0.0;
	static int step_old = 0;
	
	if(step != step_old){
		target_velocity = 0.0;
	}
	
	//目標方向
	direction_target_degree = get_target_degree(target_x,target_y,x_now,y_now);
	
	//今の車体の速度を目標地に向かう方向に変換(±あり)
	direction_velocity = (g_velocity) * cos(convert_radian(get_gap_degree(direction_target_degree,g_direction_degree)));
	
	//目標速度
	distance_rest = get_distance(target_x,target_y,x_now,y_now);
	
	if(distance_rest > 0.5 * max_velocity * max_velocity / a_down ){
		if(target_velocity < max_velocity){
			target_velocity += (a_up * 0.001 * INTERRUPT_TIME);
		}else{
			target_velocity = max_velocity;
		}
	}else{
		target_velocity = sqrtf( 2 * a_down * distance_rest);
	}
	
	gap_now = target_velocity - direction_velocity;
	motor_output = gap_now * p_gain;//速度はpゲインのみ
	
	
	if(motor_output < 0){//出力が負のとき、角度を180度反転
		degree_reverse = 180.0;
	}else{
		degree_reverse = 0.0;
	}
	
	motor_output_x = fabs(motor_output) * cos(convert_radian(direction_target_degree + degree_reverse));
	motor_output_y = fabs(motor_output) * sin(convert_radian(direction_target_degree + degree_reverse));
	
	motor_output_velocity.l = get_motor_output_l(motor_output_x,motor_output_y,degree_now);
	motor_output_velocity.r = get_motor_output_r(motor_output_x,motor_output_y,degree_now);
	motor_output_velocity.b = get_motor_output_b(motor_output_x,motor_output_y,degree_now);
	
	step_old = step;
}*/
/******************************************************************************
*	タイトル ： 速度台形制御出力計算(改良)
*	  関数名 ： calculate_motor_output_lrb_velocity
*	  戻り値 ： void型
*	    引数1： float型 target_x
*	    引数2： float型 target_y
*	    引数3： float型 x_now
*	    引数4： float型 y_now
*	    引数5： float型 degree_now
*	    引数6： float型 a_up
*	    引数7： float型 a_down
*	    引数8： float型 max_velocity
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/03/03
******************************************************************************/
void calculate_motor_output_lrb_velocity(float x_start,  float y_start,  float x_now,  float y_now,  float target_x, float target_y, float degree_now, float a_up,  float a_down,  float max_velocity,  int step)
{
	float direction_velocity = 0.0,	gap_now = 0.0,	motor_output = 0.0,	motor_output_x = 0.0,	motor_output_y = 0.0,
		degree_reverse = 0.0,	distance_rest = 0.0,	direction_degree_now = 0.0,	direction_target_degree = 0.0,	p_gain = 0.2;
	static float target_velocity = 0.0;
	static int step_old = 0;
	
	if(step != step_old){
		target_velocity = 0.0;
	}
	
	direction_target_degree = get_target_degree(target_x,target_y,x_start,y_start);
	direction_degree_now = get_target_degree(target_x,target_y,x_now,y_now);
	
	direction_velocity = (g_velocity) * cos(convert_radian(get_gap_degree(direction_target_degree,direction_degree_now)));
	
	//目標速度
	distance_rest = get_distance(target_x,target_y,x_now,y_now);
	
	if(distance_rest > 0.5 * max_velocity * max_velocity / a_down ){
		if(target_velocity < max_velocity){
			target_velocity += (a_up * 0.001 * INTERRUPT_TIME);
		}else{
			target_velocity = max_velocity;
		}
	}else{
		target_velocity = sqrtf( 2 * a_down * distance_rest);
	}
	
	gap_now = target_velocity - direction_velocity;
	motor_output = gap_now * p_gain;//速度はpゲインのみ
	
	
	if(motor_output < 0){//出力が負のとき、角度を180度反転
		degree_reverse = 180.0;
	}else{
		degree_reverse = 0.0;
	}
	
	motor_output_x = fabs(motor_output) * cos(convert_radian(direction_degree_now + degree_reverse));
	motor_output_y = fabs(motor_output) * sin(convert_radian(direction_degree_now + degree_reverse));
	
	motor_output_velocity.l = get_motor_output_l(motor_output_x,motor_output_y,degree_now);
	motor_output_velocity.r = get_motor_output_r(motor_output_x,motor_output_y,degree_now);
	motor_output_velocity.b = get_motor_output_b(motor_output_x,motor_output_y,degree_now);
	
	step_old = step;
}

/******************************************************************************
*	タイトル ： Atlas式曲線走行（返値は中間座標到達フラグ）
*	  関数名 ： get_Atlas_curve
*	  戻り値 ： int型
*	    引数1： float型 x_start
*	    引数2： float型 y_start
*	    引数3： float型 x_now
*	    引数4： float型 y_now
*	    引数5： float型 target_x
*	    引数6： float型 target_y
*	    引数7： float型 start_degree
*	    引数8： float型 degree_now
*	    引数9： int型 chapter
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/03/03
******************************************************************************/
int get_Atlas_curve(float x_start,float y_start,float x_now,float y_now,float target_x,float target_y,float start_degree,float degree_now,int chapter)
{
	int flag_percentage_max = 0;
	float distance_all = 0.0,	d_distance = 0.0,
		percentage_division = 100.0,//割合の分割回数
		target_x1 = 0.0,	target_y1 = 0.0,
		degree_gap = 0.0,	motor_output_d = 0.0,	motor_output_x_d = 0.0,	motor_output_y_d = 0.0,
		d_direction_target_degree = 0.0,	p_gain_d = 0.6, d_gain_d = 6.0	,gap_now = 0.0;
	static float number = 1.0;
	static int chapter_old = 0;
	static float gap_old = 0.0;

	if(chapter != chapter_old){
		number = 1.0;
		gap_old = 0.0;
	}
	
	distance_all = get_distance(target_x,target_y,x_start,y_start);//スタートから目標値までの距離

	/*****************************************距離制御**********************************************/
	degree_gap = get_gap_degree(get_target_degree(target_x,target_y,x_start,y_start),start_degree);
	d_distance = (distance_all / percentage_division) * number;
	//中間座標
	target_x1 = x_start + d_distance * cos(convert_radian(start_degree + (degree_gap / percentage_division) * number));
	target_y1 = y_start + d_distance * sin(convert_radian(start_degree + (degree_gap / percentage_division) * number));
	
	//出力分散
	d_direction_target_degree = get_target_degree(target_x1,target_y1,x_now,y_now);
	//motor_output_d = get_motor_output_distance(target_x1,target_y1,x_now,y_now,p_gain_d,d_gain_d);
	
	gap_now = get_distance(target_x1,target_y1,x_now,y_now);	
	motor_output_d = (p_gain_d * gap_now)  + (d_gain_d * (gap_now - gap_old));
	gap_old = gap_now;
	
	motor_output_x_d = motor_output_d * cos(convert_radian(d_direction_target_degree));
	motor_output_y_d = motor_output_d * sin(convert_radian(d_direction_target_degree));	
	
	motor_output_distance.l = get_motor_output_l(motor_output_x_d,motor_output_y_d,degree_now);
	motor_output_distance.r = get_motor_output_r(motor_output_x_d,motor_output_y_d,degree_now);
	motor_output_distance.b = get_motor_output_b(motor_output_x_d,motor_output_y_d,degree_now);

	//中間座標を到達したとき
	if(get_vertical_distance_func(target_x1,  target_y1,  x_now,  y_now,  get_target_degree(target_x,target_y,x_start,y_start)) <= 5.0){
		number ++;
		if(number > percentage_division){//パーセンテージの上限越え防止
			number = percentage_division;
			flag_percentage_max = ON;
		}else{
			flag_percentage_max = OFF;
		}
	}
	/*********************************************************************************************/
	chapter_old = chapter;
	
	return (flag_percentage_max);
}

struct calc_horizontal{
	float l;
	float r;
	float b;
}motor_output_horizontal;
/******************************************************************************
*	タイトル ： 目標座標までの水平距離からのPD制御
*	  関数名 ： calculate_motor_output_lrb_horizontal
*	  戻り値 ： なし
*	    引数1：float型 		x_start
*	    引数2： float型		y_start
*	    引数3： float型		x_now
*	    引数4： float型		y_now
*	    引数5： float型		target_x
*	    引数6： float型		target_y
*	    引数7： float型		degree_now
*	    引数8： int型		step
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/16
******************************************************************************/
void calculate_motor_output_lrb_horizontal(float x_start,float y_start,  float x_now  ,float y_now,float target_x, float target_y,  float degree_now,  int step)
{
	float motor_output = 0.0,
		motor_output_x = 0.0,
		motor_output_y = 0.0,
		gap_now = 0.0,
		degree_reverse = 0.0,
		p_gain = 0.5,
		d_gain = 3.0;
	static float gap_old = 0.0;
	static int step_old = 0;

	if(step != step_old){
		gap_old = 0.0;
	}
	
	gap_now = (-1) * get_horizontal_distance_func(target_x,target_y,x_now,y_now,get_target_degree(target_x,target_y,x_start,y_start));
	motor_output = (gap_now * p_gain) + ((gap_now - gap_old) * d_gain);
	gap_old = gap_now;

	if(motor_output < 0.0){
		degree_reverse = 180.0;
	}else{
		degree_reverse = 0.0;
	}

	motor_output_x = fabs(motor_output) * cos(convert_radian(degree_reverse + 90 + get_target_degree(target_x,target_y,x_start,y_start)));
	motor_output_y = fabs(motor_output) * sin(convert_radian(degree_reverse + 90 + get_target_degree(target_x,target_y,x_start,y_start)));

	motor_output_horizontal.l = get_motor_output_l(motor_output_x , motor_output_y,  degree_now);
	motor_output_horizontal.r = get_motor_output_r(motor_output_x , motor_output_y,  degree_now);
	motor_output_horizontal.b = get_motor_output_b(motor_output_x , motor_output_y,  degree_now);
	
	step_old = step;
}

struct calc_vertical{
	float l;
	float r;
	float b;
}motor_output_vertical;
/******************************************************************************
*	タイトル ： 目標座標までの垂直距離からのPD制御
*	  関数名 ： calculate_motor_output_lrb_vertical
*	  戻り値 ： なし
*	    引数1：float型 		x_start
*	    引数2： float型		y_start
*	    引数3： float型		x_now
*	    引数4： float型		y_now
*	    引数5： float型		target_x
*	    引数6： float型		target_y
*	    引数7： float型		degree_now
*	    引数8： int型		step
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/16
******************************************************************************/
void calculate_motor_output_lrb_vertical(float x_start,float y_start,  float x_now  ,float y_now,float target_x, float target_y,  float degree_now,  int step)
{
	float motor_output = 0.0,
		motor_output_x = 0.0,
		motor_output_y = 0.0,
		gap_now = 0.0,
		degree_reverse = 0.0,
		p_gain = 0.5,
		d_gain = 3.0;
	static float gap_old = 0.0;
	static int step_old = 0;

	if(step != step_old){
		gap_old = 0.0;
	}
	
	gap_now = get_vertical_distance_func(target_x,target_y,x_now,y_now,get_target_degree(target_x,target_y,x_start,y_start));
	motor_output = (gap_now * p_gain) + ((gap_now - gap_old) * d_gain);
	gap_old = gap_now;

	if(motor_output < 0.0){
		degree_reverse = 180.0;
	}else{
		degree_reverse = 0.0;
	}

	motor_output_x = fabs(motor_output) * cos(convert_radian(degree_reverse  + get_target_degree(target_x,target_y,x_start,y_start)));
	motor_output_y = fabs(motor_output) * sin(convert_radian(degree_reverse  + get_target_degree(target_x,target_y,x_start,y_start)));

	motor_output_vertical.l = get_motor_output_l(motor_output_x , motor_output_y,  degree_now);
	motor_output_vertical.r = get_motor_output_r(motor_output_x , motor_output_y,  degree_now);
	motor_output_vertical.b = get_motor_output_b(motor_output_x , motor_output_y,  degree_now);
	
	step_old = step;
}

struct calc_position_lock
{
		float l;
		float r;
		float b;
}motor_output_position_lock;

/******************************************************************************
*	タイトル ：ポジションロック関数
*	  関数名 ： calculate_motor_output_lrb_position_lock
*	  戻り値 ： なし
*	    引数1：float型 		x_start
*	    引数2： float型		y_start
*	    引数3： float型		x_now
*	    引数4： float型		y_now
*	    引数5： float型		target_x
*	    引数6： float型		target_y
*	    引数7： float型		degree_now
*	    引数8： float型		target_degree
*	    引数9： int型		step
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/16
******************************************************************************/
void calculate_motor_output_lrb_position_lock(float x_start,float y_start,  float x_now  ,float y_now,float target_x, float target_y,  float degree_now,  float target_degree,  int step)
{
	float motor_output_turn = 0.0;
	
	calculate_motor_output_lrb_horizontal(x_start,  y_start,  x_now,  y_now,  target_x,  target_y,  degree_now,  step);
	calculate_motor_output_lrb_vertical(x_start,  y_start,  x_now,  y_now,  target_x,  target_y,  degree_now,  step);
	motor_output_turn = get_motor_output_turn(target_degree,  g_degree);
	
	motor_output_position_lock.l = motor_output_horizontal.l + motor_output_vertical.l + motor_output_turn;
	motor_output_position_lock.r = motor_output_horizontal.r + motor_output_vertical.r + motor_output_turn;
	motor_output_position_lock.b = motor_output_horizontal.b + motor_output_vertical.b + motor_output_turn;
}

struct calc_slow_velocity{
	float l;
	float r;
	float b;
}motor_output_slow_velocity;

/******************************************************************************
*	タイトル ：低速度制御
*	  関数名 ： calculate_motor_output_lrb_slow
*	  戻り値 ： なし
*	    引数1：float型 		x_start
*	    引数2： float型		y_start
*	    引数3： float型		x_now
*	    引数4： float型		y_now
*	    引数5： float型		degree_now
*	    引数6： float型		target_velocity
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/16
******************************************************************************/
void calculate_motor_output_lrb_slow_velocity(float target_x, float target_y,  float x_now  ,float y_now,  float degree_now,  float target_velocity)
{	
	float motor_output = 0.0,
			motor_output_x = 0.0,
			motor_output_y = 0.0,
			direction_degree_now = 0.0;
	static int chapter = 0,		step_old = 0;
		
			
		motor_output = Uniform_duty_absolute_velocity(target_velocity,  g_velocity);
		direction_degree_now = get_target_degree(target_x,target_y,x_now,y_now);
		
		motor_output_x = motor_output * cos(convert_radian(direction_degree_now));
		motor_output_y = motor_output * sin(convert_radian(direction_degree_now));
		
		motor_output_slow_velocity.l = get_motor_output_l(motor_output_x , motor_output_y,  degree_now);
		motor_output_slow_velocity.r = get_motor_output_r(motor_output_x , motor_output_y,  degree_now);
		motor_output_slow_velocity.b = get_motor_output_b(motor_output_x , motor_output_y,  degree_now);
}
/*void Debug_opq(void)
{	
	float sencer_p = 0.0;
	char str1[100];
	
	switch((int)pick_out_atoz_value('o')){
		case 0:break;
		case 1:sencer_p = get_encorder_MTU1();break;
		case 2:sencer_p = get_encorder_MTU2();break;
		case 3:sencer_p = get_encorder_MTU7();break;
		case 4:sencer_p = get_encorder_MTU8();break;
		case 5:sencer_p = g_ad_att[0];break;
		case 6:sencer_p = 0;break;
		case 7:sencer_p = g_ad_att[2];break;
		case 8:sencer_p = 0;break;
		case 9:sencer_p = 0; break;
		case 10:sencer_p = g_ad_att[4];break;
		case 11:sencer_p = 0;break;
		case 12:sencer_p = g_ad_att[6];break;
		case 13:sencer_p = LIMIT_SW_LIFT_ARM_HIGH;break;
		case 14:sencer_p = LIMIT_SW_LIFT_ARM_LOW;break;
		case 15:sencer_p = LIMIT_SW_TOP_ARM_FRONT;break;
		case 16:sencer_p = LIMIT_SW_TOP_ARM_BACK;break;
		case 17:sencer_p = LIMIT_SW_SEESAW_ARM_FRONT;break;
		case 18:sencer_p = LIMIT_SW_SEESAW_ARM_BACK;break;
	}
	sprintf(str1,"p%.0f#",sencer_p);
	//sprintf(str2,"p%.0f#",sencer_p);
	String_2(str1);
	//String_2(str2);
}*/
/*void Move_all_arm(float target_top_arm_length,	float target_top_arm_degree,  float target_top_arm_tilt_degree,  float target_seesaw_arm_length)
{
	Move_top_arm_length(target_top_arm_length);
	Move_top_arm_turn(target_top_arm_degree);
	Move_top_arm_tilt(target_top_arm_tilt_degree);
	Move_seesaw_arm_length(target_seesaw_arm_length);
}*/
/******************************************************************************
*	タイトル ：アーム指定目標値制御関数
*	  関数名 ： Move_all_arm_2
*	  戻り値 ： void型
*	    引数1 ： float型　target_top_arm_length
*	    引数2 ： float型　target_top_arm_degree
*	    引数3 ： float型　target_top_arm_tilt_degree
*	    引数4 ： float型　target_seesaw_arm_length
*	    引数5 ： int型　step
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/27
******************************************************************************/
void Move_all_arm_2(float target_top_arm_length,  float target_top_arm_degree,  float target_top_arm_tilt_degree,  float target_seesaw_arm_length,  int step)
{
	static int step_old = 0;
	static float start_degree = INIT_TOP_ARM_DEGREE,
						target_degree_old = INIT_TOP_ARM_DEGREE;
	static float start_x = 0.0,		start_y = 0.0,	timer = 0.0;
	static int chapter = 0,	flag[4] = {OFF};
	
	if(target_top_arm_degree != target_degree_old){
		start_degree = g_top_arm_degree;
	}
	
	if(step == 11){
		Move_top_arm_turn(target_top_arm_degree);
	}else{
		Move_top_arm_turn_omega(start_degree,  target_top_arm_degree,  step);
	}
	
	if(((step == 19) && (step_old == 20)) || (step == 0) || (step == 13)){
		chapter = 0;
	}
	
	if(step == 19){
		g_flag_catch_from_swing = OFF;
		if(chapter == 0){
			start_x = g_x_c_top_arm;
			start_y = g_y_c_top_arm;
			chapter ++;
			
		}else if(chapter == 1){
			if(AR_TOP_ARM_LOCK == ON){
				AR_TOP_ARM_LOCK = OFF;
				flag[1] = ON;
			}
			if(flag[1] == ON){
				if(timer >= 0.5){
					flag[1] = OFF;
					timer = 0.0;
				}else{
					timer += (0.001 * INTERRUPT_TIME);
				}
				Deadtime_top_arm();
			}else{
				Move_top_arm_length(target_top_arm_length);
			}
			
			if(get_vertical_distance_func(TARGET_TOP_ARM_LOCK_X, TARGET_TOP_ARM_LOCK_Y, g_x_c_top_arm,  g_y_c_top_arm,  get_target_degree(TARGET_TOP_ARM_LOCK_X, TARGET_TOP_ARM_LOCK_Y ,  start_x,  start_y)) <= 10.0){
				//AR_TOP_ARM_LOCK = ON;
				//Deadtime_top_arm();
				chapter ++;
			}
			
			/*else{
				if(AR_TOP_ARM_LOCK == ON){
					AR_TOP_ARM_LOCK = OFF;
					flag[1] = ON;
				}
				if(flag[1] == ON){
					if(timer >= 0.5){
						flag[1] = OFF;
						timer = 0.0;
					}else{
						timer += (0.001 * INTERRUPT_TIME);
					}
					Deadtime_top_arm();
				}else{
					Move_top_arm_length(target_top_arm_length);
				}
			}*/
		}else if(chapter == 2){
			AR_TOP_ARM_LOCK = ON;
			Deadtime_top_arm();
		}
	}else if(step == 20){
		/*
		if(g_top_arm_length <= 400){
			flag[2] = ON;
			g_flag_catch_from_swing = ON;
		}
		
		if(flag[2] == ON){
			if(AR_TOP_ARM_LOCK == ON){
				AR_TOP_ARM_LOCK = OFF;
				flag[3] = ON;
			}
			if(flag[3] == ON){
				if(timer >= 0.5){
					flag[3] = OFF;
					timer = 0;
				}else{
					timer += (0.001 * INTERRUPT_TIME);
				}
				Deadtime_top_arm();
			}else{
				
				Move_top_arm_length(target_top_arm_length);
			}
		}else{
			if(g_flag_catch_from_swing == OFF){
				AR_TOP_ARM_LOCK = ON;
				Deadtime_top_arm();
			}else{
				flag[2] = ON;
			}
		}*/
		
		AR_TOP_ARM_LOCK = ON;
		Deadtime_top_arm();
	}else{
		g_flag_catch_from_swing = OFF;
		
		if(AR_TOP_ARM_LOCK == ON){
			AR_TOP_ARM_LOCK = OFF;
			flag[0] = ON;
		}
		if(flag[0] == ON){
			if(timer >= 0.5){
				flag[0] = OFF;
				timer = 0;
			}else{
				timer += (0.001 * INTERRUPT_TIME);
			}
			Deadtime_top_arm();
		}else{
			Move_top_arm_length(target_top_arm_length);
		}
	}
	
	//Move_top_arm_length(target_top_arm_length);
	Move_top_arm_tilt(target_top_arm_tilt_degree);
	Move_seesaw_arm_length(target_seesaw_arm_length);
	
	target_degree_old = target_top_arm_degree;
	step_old = step;
}
/******************************************************************************
*	タイトル ：すべてのエアーON/OFF決め
*	  関数名 ： Air_all_on_off
*	  戻り値 ： void型
*	    引数1 ： int型　top_arm_catch
*	    引数2 ： int型　seesaw_push
*	    引数3 ： int型　swing_catch
*	    引数4 ： int型　swing_push(未使用)
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/27
******************************************************************************/
void Air_all_on_off(int top_arm_catch,  int seesaw_push,  int swing_catch,  int swing_push)
{
	AR_TOP_CATCH = top_arm_catch;
	AR_SEESAW_PUSH = seesaw_push;
	AR_SWING_CATCH = swing_catch;
	//AR_SWING_PUSH = swing_push;
}
/******************************************************************************
*	タイトル ：重力からファンの出力変換
*	  関数名 ： convert_fan_power
*	  戻り値 ： float型
*	    引数1 ： float型　gravity
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/27
******************************************************************************/
float convert_fan_power(float gravity)
{
	float fan_power = 0.0;
	fan_power = ((gravity / FAN_POWER_MAX_WEIGHT) * 100);
	fan_power = Limit_ul(100.0,  0.0,  fan_power);
	return(fan_power);
}

struct calc_fan_power{
	float l;
	float r;
	float b;
}fan_power;
/******************************************************************************
*	タイトル ：各ファンの出力計算
*	  関数名 ： calculate_fan_power_lrb
*	  戻り値 ： void型
*	    引数1 ： int型  step
*	    引数2 ： int型  r2_sw
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/27
******************************************************************************/
void calculate_fan_power_lrb(int step,	int r2_sw)
{
	int mode_AUTO_or_MANUAL = MANUAL;
	float top_arm_to_fulcrum_length = 0.0,		fan_to_fulcrum_length_0= 0.0,
			fan_to_fulcrum_length_1 = 0.0,		gravity_to_fulcrum_length = 0.0,
			moment_top_arm = 0.0, 	moment_gravity = 0.0,
			fan_power_all = 0.0;
	static int step_old = 0;
	static int mode_AUTO_or_MANUAL_old = MANUAL;
	static int flag[3] = {OFF};
	
	//自動モードと手動モードの状態を見る
	if(r2_sw == 0){
		mode_AUTO_or_MANUAL = AUTO;
	}else{
		mode_AUTO_or_MANUAL = MANUAL;
	}
	
	top_arm_to_fulcrum_length = get_distance(g_x_c_top_arm,  g_y_c_top_arm,  g_x_c_fulcrum,  g_y_c_fulcrum);
	fan_to_fulcrum_length_0 = (CAD_SIZE_CENTER_TO_TIRE * 0.5) - (CAD_SIZE_CENTER_TO_FAN_0 * cos(convert_radian(CAD_SIZE_CENTER_TO_FAN_1)));
	fan_to_fulcrum_length_1 = (CAD_SIZE_CENTER_TO_TIRE * 0.5) + CAD_SIZE_CENTER_TO_FAN_2;
	gravity_to_fulcrum_length = (CAD_SIZE_CENTER_TO_TIRE * 0.5) + CAD_SIZE_CENTER_TO_GRAVITY;
	
	moment_top_arm = top_arm_to_fulcrum_length * AUTO_ROBOT_WEIGHT;
	moment_gravity = gravity_to_fulcrum_length * MANUAL_ROBOT_WEIGHT;
	
	if(mode_AUTO_or_MANUAL == MANUAL){
		#if COLOR == RED	
			if((step >= 5) && (step <= 11) && (g_y_c <=-1400)){//シーソー押すとき
			fan_power.l = 100.0;
			fan_power.r = 100.0;
			fan_power.b = 100.0;
		}else{
			if((step >= 0) && (step <= 2)){//初期状態
				fan_power.l = 0.0;
				fan_power.r = 0.0;
				fan_power.b = 0.0;		
			}else{
				if(AR_TOP_CATCH == OFF){//自動機をつかんでいるとき
					if(moment_top_arm >= moment_gravity){//モーメント計算上車体が浮く
						fan_power.l = 100.0;
						fan_power.r = 100.0;
						fan_power.b = 100.0;
					}else{
						if(step <= 21){
						//if(step <= 20){
							if(top_arm_to_fulcrum_length >= 200){
								fan_power_all = (top_arm_to_fulcrum_length / ((MANUAL_ROBOT_WEIGHT * gravity_to_fulcrum_length) / AUTO_ROBOT_WEIGHT)) * 100.0;
								fan_power.l = (fan_to_fulcrum_length_0 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all; 
								fan_power.r = (fan_to_fulcrum_length_0 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all;
							//	fan_power.b = (fan_to_fulcrum_length_1 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all;
								fan_power.b = (fan_to_fulcrum_length_0 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all;
								fan_power.l = Limit_ul(100.0,  0.0,  fan_power.l);
								fan_power.r = Limit_ul(100.0,  0.0,  fan_power.r);
								fan_power.b = Limit_ul(100.0,  0.0,  fan_power.b);						
							}else{
								fan_power.l = 0.0;
								fan_power.r = 0.0;
								fan_power.b = 0.0;			
							}
						}else{//ジャングルジムに置くとき
							fan_power.l = 0.0;
							fan_power.r = 0.0;
							fan_power.b = 0.0;
						}
					}
				}else{
					fan_power.l = 0.0;
					fan_power.r = 0.0;
					fan_power.b = 0.0;	
				}
			}
		}
			
		#elif COLOR == BLUE
		if((step >= 5) && (step <= 11) && (g_y_c >= 1400)){//シーソー押すとき
			fan_power.l = 100.0;
			fan_power.r = 100.0;
			fan_power.b = 100.0;
		}else{
			if((step >= 0) && (step <= 2)){//初期状態
				fan_power.l = 0.0;
				fan_power.r = 0.0;
				fan_power.b = 0.0;		
			}else{
				if(AR_TOP_CATCH == OFF){//自動機をつかんでいるとき
					if(moment_top_arm >= moment_gravity){//モーメント計算上車体が浮く
						fan_power.l = 100.0;
						fan_power.r = 100.0;
						fan_power.b = 100.0;
					}else{
						if(step <= 21){
						//if(step <= 20){	
							if(top_arm_to_fulcrum_length >= 200){
								fan_power_all = (top_arm_to_fulcrum_length / ((MANUAL_ROBOT_WEIGHT * gravity_to_fulcrum_length) / AUTO_ROBOT_WEIGHT)) * 100.0;
								fan_power.l = (fan_to_fulcrum_length_0 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all; 
								fan_power.r = (fan_to_fulcrum_length_0 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all;
								//fan_power.b = (fan_to_fulcrum_length_1 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all;
								fan_power.b = (fan_to_fulcrum_length_0 / (fan_to_fulcrum_length_0  + fan_to_fulcrum_length_1)) * fan_power_all;
								fan_power.l = Limit_ul(100.0,  0.0,  fan_power.l);
								fan_power.r = Limit_ul(100.0,  0.0,  fan_power.r);
								fan_power.b = Limit_ul(100.0,  0.0,  fan_power.b);						
							}else{
								fan_power.l = 0.0;
								fan_power.r = 0.0;
								fan_power.b = 0.0;			
							}
						}else{//ジャングルジムに置くとき
							fan_power.l = 0.0;
							fan_power.r = 0.0;
							fan_power.b = 0.0;
						}
					}
				}else{
					fan_power.l = 0.0;
					fan_power.r = 0.0;
					fan_power.b = 0.0;	
				}
			}
		}
		#endif
	}else if(mode_AUTO_or_MANUAL == AUTO){
		if((step == 5) || (step == 11)){
			fan_power.l = 0.0;
			fan_power.r = 0.0;
			fan_power.b = 0.0;
		}else{
			fan_power.l = 40.0;
			fan_power.r = 40.0;
			fan_power.b = 40.0;
		}
	}
	
	mode_AUTO_or_MANUAL_old = mode_AUTO_or_MANUAL;	
}

/******************************************************************************
*	タイトル ： メイン関数
*	  関数名 ： main
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2014/05/27
******************************************************************************/
void main(void)
{
	float nutral_x = 127,	nutral_y = 127,			//スティック中心の値
			stick_x_old = 0,	stick_y_old = 0,
			result_motor_output_l = 0.0,	result_motor_output_r = 0.0,	result_motor_output_b = 0.0,		//足回り最終出力
			motor_output_turn = 0.0,		//回転出力
			Motor_output_x = 0.0, 	Motor_output_y = 0.0,	
			manual_motor_output_l = 0.0,	manual_motor_output_r = 0.0,  manual_motor_output_b = 0.0,
			motor_output_lift = 0.0,
			motor_output_seesaw = 0.0,
		  	motor_output_top = 0.0,
			motor_output_top_turn = 0.0,	
			motor_output_top_tilt = 0.0,
		  	target_omega = 0.0,
			x_start_curve= 0.0, y_start_curve = 0.0,
			position_x_old = START_X,		position_y_old = START_Y,			
			
			target_lock_lift= INIT_SEESAW_ARM_HIGH,
			target_lock_top_arm_length = INIT_TOP_ARM_LENGTH,
			
			gap_lift_arm_now = 0.0,	
			gap_top_arm_now = 0.0,
			gap_top_arm_turn_now = 0.0,
			gap_lift_arm_old = 0.0,
			gap_top_arm_old = 0.0,
			gap_top_arm_turn_old = 0.0,
			
			target_swing_arm_z = 0.0,
			target_lock_top_arm_degree = INIT_TOP_ARM_DEGREE,
			target_top_arm_z = 0.0,
			target_top_arm_length = 0.0,
			target_swing_arm_length = 0.0,
			
			target_degree = START_DEGREE,
			start_degree = START_DEGREE,
			direction_target_degree = 0.0,
			
			pwm_percent = 0.0,
			pwm_percent_turn = 0.0,
			
			adjustment_count[5] = {0},
			adjustment_sum[5] = {0},	
			timer = 0.0,
			fan_power_send[3] = {0};
			
	int	flag_manual_high_low = 0,
			mode_high_or_low = OFF,
			mode_high_or_low_old = 0,
			mode_fan_ON_or_OFF = ON,
			mode_fan_ON_or_OFF_old = 0,
			flag_fan_ON_or_OFF = 0,
			auto_chapter_seesaw = 0,
			auto_chapter_start = 0,
			auto_chapter_swing = 0,
			flag_auto_seesaw = OFF,
			auto_chapter_to_swing = 0,
			auto_chapter_to_pole = 0,
			auto_chapter_to_jungle_gym = 0,
			swing_lock_chapter = 0,
			jungle_gym_lock_chapter = 0,
			flag_percentage_max = 0,
			flag[8] = {0},
			
			task = RETRY,
			step = 0,
			step_old = 0,
			
			flag_select = 0,
			flag_retry = 0,
			flag_retry_task = STANDBY,
	 		flag_circle_r2= 0,
			flag_circle_l2 = 0,
			flag_triangle_l1 = 0,
			flag_up = 0,
			flag_down = 0,
			flag_start = 0,
			flag_right = 0,
			flag_left = 0,
			
			flag_lift_arm_set = OFF,
			flag_lift_set_start = OFF,
			flag_top_arm_set_start = OFF,
			flag_top_arm_set = OFF,
			flag_seesaw_arm_set_start = OFF,
			flag_seesaw_arm_set = OFF,
			
			
			flag_reset_adjustment = OFF,
			flag_once_reset = OFF,
			
			flag_swing_arm_length = OFF,
			flag_auto_change_pwm = OFF,
			
			position_lock_count = 0,	
			position_lock_count_old = 0,
			
			count_ad = 0,
			count_average = 500,
			count_k = 0,
			count_l = 0,
			count_m = 0,
			count_n = 0,
			ad_num = 1,
			count_while = 0,
			
			count_auto_lift = 0;
			
	#if MODE_SEND_TO_MBED == ON
		unsigned short  i = 0;
		char  str1[100],str2[100];
	#endif
	
	union psdate1 getdate1;
	union psdate2 getdate2;
	union psdate3 getdate3;

	All_setup();
	All_information_start();
	//para();
	
	while(1){
		if(g_timer_all <= 300){
			if(count_ad == 0){
				g_init_ad[0] = get_Average((int)(count_average *  ad_num), 0 , g_ad_att[POTENTIO_TOP_ARM_DEGREE_CH]);//上アーム回転
				//g_init_ad[0] = get_Average((int)(count_average *  ad_num), 0 , get_Ad(POTENTIO_TOP_ARM_DEGREE_CH));
				g_now_ad[0] = g_init_ad[0];
				count_ad ++;
			}else if(count_ad == 1){
				g_init_ad[1] = get_Average((int)(count_average *  ad_num), 1 ,g_ad_att[POTENTIO_TOP_ARM_LENGTH_CH]);//上アーム前後
				//g_init_ad[1] = get_Average((int)(count_average *  ad_num), 1 , get_Ad(POTENTIO_TOP_ARM_LENGTH_CH));
				g_now_ad[1] = g_init_ad[1];
				count_ad ++;
			}else if(count_ad == 2){
				g_init_ad[2] = get_Average((int)(count_average *  ad_num) , 2 ,g_ad_att[POTENTIO_TOP_ARM_TILT_CH]);//上アームピッチ回転
				//g_init_ad[2] = get_Average((int)(count_average *  ad_num), 2 , get_Ad(POTENTIO_TOP_ARM_TILT_CH));
				g_now_ad[2] = g_init_ad[2];
				count_ad ++;
			}else if(count_ad == 3){
				g_init_ad[3] = get_Average((int)(count_average *  ad_num) , 3 ,g_ad_att[POTENTIO_SEESAW_ARM_CH]);//シーソーアーム前後
				//g_init_ad[3] = get_Average((int)(count_average *  ad_num), 3 , get_Ad(POTENTIO_SEESAW_ARM_CH));
				g_now_ad[3] = g_init_ad[3];
				count_ad = 0;
			}
		}else{
			if(count_ad == 0){
				g_now_ad[0] = get_Average((int)(count_average *  ad_num) , 0 , g_ad_att[POTENTIO_TOP_ARM_DEGREE_CH]);//上アーム回転
				//g_now_ad[0] = get_Average((int)(count_average *  ad_num), 0 , get_Ad(POTENTIO_TOP_ARM_DEGREE_CH));
				count_ad ++;
			}else if(count_ad == 1){
				g_now_ad[1] = get_Average((int)(count_average *  ad_num) , 1 , g_ad_att[POTENTIO_TOP_ARM_LENGTH_CH]);//上アーム前後
				//g_now_ad[1] = get_Average((int)(count_average *  ad_num), 1 , get_Ad(POTENTIO_TOP_ARM_LENGTH_CH));
				count_ad ++;
			}else if(count_ad == 2){
				g_now_ad[2] = get_Average((int)(count_average *  ad_num) , 2 , g_ad_att[POTENTIO_TOP_ARM_TILT_CH]);//上アームピッチ回転
				//g_now_ad[2] = get_Average((int)(count_average *  ad_num), 2 , get_Ad(POTENTIO_TOP_ARM_TILT_CH));
				count_ad ++;
			}else if(count_ad == 3){
				g_now_ad[3] = get_Average((int)(count_average *  ad_num)  , 3 , g_ad_att[POTENTIO_SEESAW_ARM_CH]);//シーソーアーム前後
				//g_now_ad[3] = get_Average((int)(count_average *  ad_num), 3 , get_Ad(POTENTIO_SEESAW_ARM_CH));
				count_ad = 0;
			}
		}
	
		count_while++;
		
		/*if(g_interrupt_timer_count_2 >= 50){
			g_interrupt_timer_count_2 = 0;
			//デュアルショックの値を取る
			Rspi_recive_send_line_dualshock();
			getdate1.dword = g_controller_receive_1st;
			getdate2.dword = g_controller_receive_2nd;
			getdate3.dword = g_controller_receive_3rd;
		}*/
		
		if(g_interrupt_timer_count >= INTERRUPT_TIME){
			g_interrupt_timer_count = 0;
			
			count_ad = 0;
			//デュアルショックの値を取る
			Rspi_recive_send_line_dualshock();
			getdate1.dword = g_controller_receive_1st;
			getdate2.dword = g_controller_receive_2nd;
			getdate3.dword = g_controller_receive_3rd;
			//座標、アームのデータ算出
			calculate_information();
			calculate_information_arm(flag_lift_arm_set,  flag_top_arm_set,  flag_seesaw_arm_set);
			
			#if MODE_ARM_TEST == OFF
			
			#if	COLOR == RED
				LED_RED = ON;
			#elif	COLOR == BLUE
				LED_BLUE = ON;
			#endif
			//receive_order_solve();
			
			if(TOGGLE_MANUAL_MODE == ON){
					//上アーム傾き
				if((getdate2.byte.square_sw == 0) && (getdate2.byte.l1_sw== 0)){
					motor_output_top_tilt= 80.0;//(100 * pick_out_atoz_value('d'));//70.0;
				}else if((getdate2.byte.square_sw == 0) && (getdate2.byte.l2_sw == 0)){
					motor_output_top_tilt = -80.0;//(-1) * (100 * pick_out_atoz_value('d'));//-70.0;
				}else{
					motor_output_top_tilt = BRAKE;
				}
				Motor_top_arm_tilt(motor_output_top_tilt);
			}
			
			//初期高さ調整
			if(getdate1.byte.start_sw == 0){//STARTボタン
				if(flag_start == OFF){
					flag_start = ON;
					if(LIMIT_SW_LIFT_ARM_LOW == OFF){//リフト
						flag_lift_set_start = ON;
					}else{
						flag_lift_set_start = OFF;
						flag_lift_arm_set = ON;
					}
					if(LIMIT_SW_TOP_ARM_FRONT == OFF){//上アーム
						flag_top_arm_set_start = ON;
					}else{
						flag_top_arm_set_start = OFF;
						flag_top_arm_set = ON;
					}
					if(LIMIT_SW_SEESAW_ARM_FRONT == OFF){//シーソーアーム
						flag_seesaw_arm_set_start = ON;
					}else{
						flag_seesaw_arm_set_start = OFF;
						flag_seesaw_arm_set = ON;
					}
				}
			}else{
				flag_start = OFF;
			}
			
			//リフト
			if(flag_lift_set_start == ON){
				if(LIMIT_SW_LIFT_ARM_LOW == OFF){//上リミットスイッチに触れていないとき
					flag_lift_arm_set = OFF;
					count_k = 0;
				}else{
					count_k ++;
				}
				Motor_lift_arm(-30.0);
			}
			if(count_k >= 30){
				count_k = 0;
				Motor_lift_arm(BRAKE);
				flag_lift_set_start = OFF;
				flag_lift_arm_set = ON;
				target_lock_lift = g_z_c_seesaw_arm;
			}
			
			//上アーム
			if(flag_top_arm_set_start == ON){
				if(LIMIT_SW_TOP_ARM_FRONT == OFF){//上アーム前リミットスイッチに触れていないとき
					flag_top_arm_set = OFF;
					count_l = 0;
				}else{
					count_l ++;
				}
				Motor_top_arm(-40.0);
			}
			if(count_l >= 10){
				count_l = 0;
				Motor_top_arm(BRAKE);
				flag_top_arm_set_start = OFF;
				flag_top_arm_set = ON;
			}
			
			//シーソーアーム
			if(flag_seesaw_arm_set_start == ON){
				if(LIMIT_SW_SEESAW_ARM_FRONT == OFF){//シーソーアーム前リミットスイッチに触れていないとき
					flag_seesaw_arm_set = OFF;
					count_m = 0;
				}else{
					count_m ++;
				}
				Motor_seesaw_arm(-30.0);
			}
			if(count_m >= 30){
				count_m = 0;
				Motor_seesaw_arm(BRAKE);
				flag_seesaw_arm_set_start = OFF;
				flag_seesaw_arm_set = ON;
			}
			
			
			
			//初期状態調整完了
			if((flag_lift_arm_set == ON) && (flag_top_arm_set == ON) && (flag_seesaw_arm_set == ON)){
			
				LED_GREEN = ON;
				
				//リトライ時 or アーム初期値に戻す
				if(getdate1.byte.select_sw == 0){//SELECTボタン
					if(flag_select == OFF){
						flag_select = ON;
						if((step_old >= 0) && (step_old <= 2)){
							flag_retry_task = STANDBY;
						}else if((step_old >= 3) && (step_old <= 11)){
							flag_retry_task = TASK_SEESAW;
						}else if((step_old >= 12) && (step_old <= 20)){
							flag_retry_task = TASK_SWING;
						}else if((step_old >= 21) && (step_old <= 25)){
						//else if((step_old >= 21) && (step_old <= 24)){
							flag_retry_task = TASK_POLE;
						}else if(step_old >= 26){
						//else if(step_old >= 25){
							flag_retry_task = TASK_JUNGLE_GYM;
						}
						step = 0;
						flag_retry = ON;
					}
				}else{
					flag_select = OFF;
				}
				/*
				if( (step == 22)|| ((step == 26) && (g_top_arm_tilt_degree >= 40)) || (step == 27)){
						pwm_percent = Uniform_duty_absolute_velocity(100.0,  g_velocity);
						pwm_percent_turn = Uniform_duty_absolute_angular(30,  fabs(g_omega));
				}else{
							
					//足回り速度変更
					if(getdate1.byte.up_sw == 0){//上ボタン
						if(flag_manual_high_low == OFF){
							flag_manual_high_low = ON;
							if(mode_high_or_low_old == OFF){
								mode_high_or_low = ON;
							}else{
								mode_high_or_low = OFF;	
							}
						}
					}else{
						flag_manual_high_low = OFF;
					}
					if(mode_high_or_low == ON){
						pwm_percent = HIGH_MANUAL_PERCENTAGE;
						pwm_percent_turn = HIGH_MANUAL_PERCENTAGE_TURN;
					}else{
						pwm_percent = LOW_MANUAL_PERCENTAGE;
						pwm_percent_turn = LOW_MANUAL_PERCENTAGE_TURN;
					}
				}*/
				
				//足回り速度自動切り替え
				if(flag_auto_change_pwm == OFF){
					if((step == 11) || ((step >= 13) && (step <= 20))){
						mode_high_or_low = ON;
					}else if((step == 23) || (step == 24) || (step == 22) || ((step == 26) && (g_top_arm_tilt_degree >= 40)) || (step == 27) || (step == 28)){
					//else if((step == 22) || (step == 23) || (step == 21)|| ((step == 25) && (g_top_arm_tilt_degree >= 40)) || (step == 26)){
						mode_high_or_low = OFF;
					}
				}
				
				//足回り速度変更
				if(getdate1.byte.up_sw == 0){//上ボタン
					flag_auto_change_pwm = ON;
					if(flag_manual_high_low == OFF){
						flag_manual_high_low = ON;
						if(mode_high_or_low_old == OFF){
							mode_high_or_low = ON;
						}else{
							mode_high_or_low = OFF;	
						}
					}
				}else{
						flag_manual_high_low = OFF;
				}
				
				if(mode_high_or_low == ON){
					if((step == 22) || ((step == 26) && (g_top_arm_tilt_degree >= 40)) || (step == 27) || (step == 28)){
					//if((step == 21)|| ((step == 25) && (g_top_arm_tilt_degree >= 40)) || (step == 26)){
						pwm_percent = LOW_MANUAL_PERCENTAGE;
						pwm_percent_turn = LOW_MANUAL_PERCENTAGE_TURN;
					}else{
						pwm_percent = HIGH_MANUAL_PERCENTAGE;
						pwm_percent_turn = HIGH_MANUAL_PERCENTAGE_TURN;
					}
					
				}else{
					if((step == 23) || (step == 24)|| (step == 28)){
					//if((step == 22) || (step == 23)){
						pwm_percent = LOW_MANUAL_PERCENTAGE;
						pwm_percent_turn = LOW_MANUAL_PERCENTAGE_TURN;
					}else if((step == 22)|| ((step == 26) && (g_top_arm_tilt_degree >= 40)) || (step == 27)){
						//else if((step == 21)|| ((step == 25) && (g_top_arm_tilt_degree >= 40)) || (step == 26)){
						pwm_percent = Uniform_duty_absolute_velocity(100.0,  g_velocity);
						pwm_percent_turn = Uniform_duty_absolute_angular(30,  fabs(g_omega));
						//pwm_percent = LOW_MANUAL_PERCENTAGE;
						//pwm_percent_turn = LOW_MANUAL_PERCENTAGE_TURN;
					}else{
						pwm_percent = LOW_MANUAL_PERCENTAGE;
						pwm_percent_turn = LOW_MANUAL_PERCENTAGE_TURN;
					}
				}
				
				mode_high_or_low_old = mode_high_or_low;		
				
				
				/****************************自動モード***************************************/
				if(TOGGLE_MANUAL_MODE == OFF){
					
					//ステップ、タスクに応じての足回り速度切り替え
					/*if((step == 11) || (task == TASK_SWING )){
						mode_high_or_low = ON;
					}else if((step == 23) || (step == 24)){
						mode_high_or_low = OFF;
					}*/
					
					//高さ微調整アップ
					/*if(step <= 26){
						if(getdate1.byte.right_sw == 0){
							if(flag_right == OFF){
								flag_right = ON;
								if(getdate2.byte.cross_sw == 0){//リフト上下
									adjustment_count[0] ++;
								}else if(getdate2.byte.triangle_sw == 0){//上アーム前後
									adjustment_count[1] ++;
								}else if(getdate2.byte.square_sw == 0){//上アームピッチ回転
									adjustment_count[2] ++;
								}else if(getdate2.byte.circle_sw == 0){//上アーム回転
									adjustment_count[3] ++;
								}
							}
						}else{
							flag_right = OFF;
						}
						//高さ微調整ダウン
						if(getdate1.byte.left_sw == 0){
							if(flag_left == OFF){
								flag_left = ON;
								if(getdate2.byte.cross_sw == 0){//×ボタン：リフト上下
									adjustment_count[0] --;
								}else if(getdate2.byte.triangle_sw == 0){//△ボタン：上アーム前後
									adjustment_count[1] --;
								}else if(getdate2.byte.square_sw == 0){//□ボタン：上アームピッチ回転
									adjustment_count[2] --;
								}else if(getdate2.byte.circle_sw == 0){//○ボタン：上アーム回転
									adjustment_count[3] --;
								}
							}
						}else{
							flag_left = OFF;
						}
					}else{//ジャングルジムのとき
						if(getdate1.byte.right_sw == 0){
							if(flag_right == OFF){
								flag_right = ON;
								if(getdate2.byte.cross_sw == 0){//リフト上下
									adjustment_count[0] ++;
								}else if(getdate2.byte.triangle_sw == 0){//上アーム前後
									adjustment_count[1] ++;
								}else if(getdate2.byte.circle_sw == 0){//上アーム回転
									adjustment_count[3] ++;
								}
							}
						}else{
							flag_right = OFF;
						}
						//高さ微調整ダウン
						if(getdate1.byte.left_sw == 0){
							if(flag_left == OFF){
								flag_left = ON;
								if(getdate2.byte.cross_sw == 0){//×ボタン：リフト上下
									adjustment_count[0] --;
								}else if(getdate2.byte.triangle_sw == 0){//△ボタン：上アーム前後
									adjustment_count[1] --;
								}else if(getdate2.byte.circle_sw == 0){//○ボタン：上アーム回転
									adjustment_count[3] --;
								}
							}
						}else{
							flag_left = OFF;
						}
						
						//ジャングルジムでの上アームピッチ回転微調整
						if((getdate2.byte.square_sw == 0) && (getdate1.byte.right_sw == 0)){
							adjustment_count[2] += (0.05);
						}else if((getdate2.byte.square_sw == 0) && (getdate1.byte.left_sw == 0)){//□ボタン：上アームピッチ回転
							adjustment_count[2] -= (0.05);
						}
					}*/
					
					if(step == 17){//ブランコ引く時のみブランコアームの調整可能
						if(getdate1.byte.right_sw == 0){
							adjustment_sum[4] -= (0.001 * INTERRUPT_TIME * 50);
						}else if(getdate1.byte.left_sw == 0){
							adjustment_sum[4] += (0.001 * INTERRUPT_TIME * 50);
						}
					}else{
						
						//リフト
						if((getdate2.byte.cross_sw == 0) && (getdate1.byte.right_sw == 0)){
							if(getdate2.byte.l2_sw == 0){
								adjustment_sum[0] += (0.001 * INTERRUPT_TIME * 25);
							}else{
								adjustment_sum[0] += (0.001 * INTERRUPT_TIME * 75);
							}
						}else if((getdate2.byte.cross_sw == 0) && (getdate1.byte.left_sw == 0)){
							if(getdate2.byte.l2_sw == 0){
								adjustment_sum[0] -= (0.001 * INTERRUPT_TIME  * 25);
							}else{
								adjustment_sum[0] -= (0.001 * INTERRUPT_TIME  * 75);
							}
						}
					
						//上アーム
						if((getdate2.byte.triangle_sw == 0) && (getdate1.byte.right_sw == 0)){
							adjustment_sum[1] += (0.001 * INTERRUPT_TIME * 50);
						}else if((getdate2.byte.triangle_sw == 0) && (getdate1.byte.left_sw == 0)){
							adjustment_sum[1] -= (0.001 * INTERRUPT_TIME * 50);
						}
					
						//上アームピッチ回転微調整
						if(step != 28){
							if((getdate2.byte.square_sw == 0) && (getdate1.byte.right_sw == 0)){
								count_n ++;
								if(count_n >= 10){
									adjustment_sum[2] += (0.001 * INTERRUPT_TIME * 5);
								}else{
									if(flag_right == OFF){
										flag_right = ON;
										adjustment_sum[2] ++;
									}
								}
							}else if((getdate2.byte.square_sw == 0) && (getdate1.byte.left_sw == 0)){//□ボタン：上アームピッチ回転
						
								count_n ++;
								if(count_n >= 10){
									adjustment_sum[2] -= (0.001 * INTERRUPT_TIME * 5);
								}else{
									if(flag_left == OFF){
										flag_left = ON;
										adjustment_sum[2] --;
									}
								}
							}else{
								count_n = 0;
								flag_right = OFF;
								flag_left = OFF;
							}
						}else{
							//上アーム回転
							if((getdate2.byte.square_sw == 0) && (getdate1.byte.right_sw == 0)){
								adjustment_sum[2] += (0.001 * INTERRUPT_TIME * 10);
							}else if((getdate2.byte.square_sw == 0) && (getdate1.byte.left_sw == 0)){//□ボタン：上アームピッチ回転
								adjustment_sum[2] -= (0.001 * INTERRUPT_TIME * 10);
							}
						}
					
						//上アーム回転
						if((getdate2.byte.circle_sw == 0) && (getdate1.byte.right_sw == 0)){
							adjustment_sum[3] += (0.001 * INTERRUPT_TIME * 20);
						}else if((getdate2.byte.circle_sw == 0) && (getdate1.byte.left_sw == 0)){//□ボタン：上アームピッチ回転
							adjustment_sum[3] -= (0.001 * INTERRUPT_TIME * 20);
						}
					}
					
					//微調整値の自動リセット
					#if COLOR == RED
					if(((step >= 0) && (step <= 2)) || ((step == 5) && (g_y_c < 0.0)) || (step == 6) || (step == 8) || (step == 10) || ((step == 11) && (g_y_c < 0.0))  || ((step == 16) && (g_top_arm_length < 320)) || (step == 24) || (step == 26)){
					//if(((step >= 0) && (step <= 2)) || ((step == 5) && (g_y_c < 0.0)) || ((step == 11) && (g_y_c < 0.0))  || ((step == 16) && (g_top_arm_length < 320)) || (step == 23)){
						flag_reset_adjustment = ON;
					}else{
						flag_reset_adjustment = OFF;
					}
					#elif COLOR == BLUE
					if(((step >= 0) && (step <= 2)) || ((step == 5) && (g_y_c > 0.0)) || (step == 6) || (step == 8) || (step == 10) || ((step == 11) && (g_y_c > 0.0))  || ((step == 16) && (g_top_arm_length < 320)) || (step == 24) || (step == 26)){
					//if(((step >= 0) && (step <= 2)) || ((step == 5) && (g_y_c > 0.0)) || ((step == 11) && (g_y_c > 0.0))  || ((step == 16) && (g_top_arm_length < 320)) || (step == 23)){
						flag_reset_adjustment = ON;
					}else{
						flag_reset_adjustment = OFF;
					}
					#endif
					
					if(flag_reset_adjustment == ON){
						if(flag_once_reset == OFF){
							flag_once_reset = ON;
							/*adjustment_count[0] = 0.0;
							adjustment_count[1] = 0.0;
							adjustment_count[2] = 0.0;
							adjustment_count[3] = 0.0;*/
							adjustment_sum[0] = 0.0;
							adjustment_sum[1] = 0.0;
							adjustment_sum[2] = 0.0;
							adjustment_sum[3] = 0.0;
							adjustment_sum[4] = 0.0;	
						}
					}else{
						flag_once_reset = OFF;
					}
					
					//微調整の合計値
					/*adjustment_sum[0] = adjustment_count[0] * 10.0;//リフト
					adjustment_sum[1] = adjustment_count[1] * 20.0;//上アーム前後
					adjustment_sum[2] = adjustment_count[2] * 0.5;//上アーム傾き
					adjustment_sum[3] = adjustment_count[3] * 5.0;//上アーム回転
					*/
					
					//ステップの進行
					if(  getdate2.byte.r1_sw == 0 ){
						if( flag_up == OFF ){
							flag_up = ON;
							step++;
							g_x_start = g_x_c;
							g_y_start = g_y_c;
							}
					}else{
						flag_up = OFF;
					}
					
					//ステップの後退		
					if(getdate2.byte.l1_sw == 0){
						if(flag_down == OFF){
							flag_down = ON;
							step --;
							g_x_start = g_x_c;
							g_y_start = g_y_c;
						}
					}else{
						flag_down = OFF;
					}
					
					
					//順送りのステップの上下限決め
					step = Limit_ul(30,  0,  step);
					
					//ジャングルジムをしている最中にステップを戻さないようにする
					if((step == 25 )&& (step_old == 26) && (g_top_arm_tilt_degree >= 40)){
						step = 26;
					}
					
					if(step != step_old){
						flag_auto_change_pwm = OFF;
					}
					
					//タスク移行
					if(step == 0){//リトライ時、アーム初期化
						task = RETRY;
					}else if((step == 1) || (step == 2)){//子供ロボット搭載
						task = STANDBY;
					}else if((step >= 3) && (step <= 11)){//シーソー
						task = TASK_SEESAW;
					}else if((step >= 13) && (step <= 20)){//ブランコ
						task = TASK_SWING;
					}else if((step >= 22) && (step <= 25)){//ポールウォーク
						task = TASK_POLE;
					}else if((step >= 27)){//ジャングルジム
						task = TASK_JUNGLE_GYM;
					}else if((step == 12) || (step == 21) || (step == 26)){//タスク選択、タスク間移動
						task = SELECT_TASK;
					}/*
					else if((step >= 13) && (step <= 19)){//ブランコ
						task = TASK_SWING;
					}else if((step >= 21) && (step <= 24)){//ポールウォーク
						task = TASK_POLE;
					}else if((step >= 26)){//ジャングルジム
						task = TASK_JUNGLE_GYM;
					}else if((step == 12) || (step == 20) || (step == 25)){//タスク選択、タスク間移動
						task = SELECT_TASK;
					}*/
					
					//ファンの出力設定
					#if MODE_ALL_FAN_STOP == OFF
						
						/*if(step >= 3){
							fan_power_send[0] = 100.0;
							fan_power_send[1] = 100.0;
							fan_power_send[2] = 100.0;
						}else{
							fan_power_send[0] = 0.0;
							fan_power_send[1] = 0.0;
							fan_power_send[2] = 0.0;
						}*/
						if(getdate1.byte.down_sw == 0){
							if(flag_fan_ON_or_OFF == OFF){
								flag_fan_ON_or_OFF = ON;
								if(mode_fan_ON_or_OFF_old == OFF){
									mode_fan_ON_or_OFF = ON;
								}else{
									mode_fan_ON_or_OFF = OFF;
								}
							}
						}else{
							flag_fan_ON_or_OFF = OFF;
						}
						
						if(mode_fan_ON_or_OFF == ON){
							calculate_fan_power_lrb(step,  getdate2.byte.r2_sw);
							fan_power_send[0] = fan_power.l;
							fan_power_send[1] = fan_power.r;
							fan_power_send[2] = fan_power.b;
						}else{
							fan_power.l = 0;
							fan_power.r = 0;
							fan_power.b = 0;
							fan_power_send[0] = 0;
							fan_power_send[1] = 0;
							fan_power_send[2] = 0;
						}
						
						mode_fan_ON_or_OFF_old = mode_fan_ON_or_OFF;
					#else
						fan_power_send[0] = 0.0;
						fan_power_send[1] = 0.0;
						fan_power_send[2] = 0.0;
					#endif
					
					
					//各タスク動作
					switch(task){
						
						/********************子供ロボット搭載********************************************/
						case STANDBY:
							//Move_all_arm(300.0 ,  0.0 ,  0.0 ,  0.0);
							Move_all_arm_2(OPERATE_ARM_1_1,  OPERATE_ARM_1_2,  OPERATE_ARM_1_3,  OPERATE_ARM_1_4,  step);
							
							if(flag_retry == ON){
								if(flag_retry_task == STANDBY){//初期状態時でのリトライ
									Move_top_arm_lift_velocity(OPERATE_ARM_1_5_0 ,step);
								}else if(flag_retry_task == TASK_SEESAW){//シーソーでのリトライ
									Move_top_arm_lift_velocity(OPERATE_ARM_1_5_1 ,step);
								}else if(flag_retry_task == TASK_SWING){//ブランコでのリトライ
									Move_top_arm_lift_velocity(OPERATE_ARM_1_5_2 ,step);
								}else if(flag_retry_task == TASK_POLE){//ポールウォークでのリトライ
									Move_top_arm_lift_velocity(OPERATE_ARM_1_5_3 ,step);
								}else if(flag_retry_task == TASK_JUNGLE_GYM){//ジャングルジムでのリトライ
									Move_top_arm_lift_velocity(OPERATE_ARM_1_5_4 ,step);
								}
							}else{
								Move_top_arm_lift_velocity(OPERATE_ARM_1_5_0 ,  step);
							}
							AR_SEESAW_PUSH = OFF;
							AR_SWING_CATCH = OFF;
							if(step == 1){
								AR_TOP_CATCH = ON;
							}else{
								AR_TOP_CATCH = OFF;
							}
							if((flag_retry == ON) && (step == 2)){//リトライしたとき
								if(getdate2.byte.l2_sw == 0){
									if(getdate2.byte.cross_sw == 0){//?ボタン→シーソー
										flag_retry = OFF;
										step = 3;
										g_x_start = g_x_c;
										g_y_start = g_y_c;
										auto_chapter_seesaw = 0;
									}else if(getdate2.byte.square_sw == 0){//□ボタン→ブランコ
										flag_retry = OFF;
										auto_chapter_swing = 0;
										step = 13;
										g_x_start = g_x_c;
										g_y_start = g_y_c;
									}else if(getdate2.byte.circle_sw == 0){//○ボタン→ポールウォーク
										//step = 22;
										step = 21;
										flag_retry = OFF;
										g_x_start = g_x_c;
										g_y_start = g_y_c;
										
									}else if(getdate2.byte.triangle_sw == 0){//△ボタン→ジャングルジム
										step = 26;
										//step = 25;
										flag_retry = OFF;
										g_x_start = g_x_c;
										g_y_start = g_y_c;
									}
								}
							}
						break;
						/***************************************************************************************/
						
						
						
						
						
						/**************************タスク選択、タスク間移動*****************************************/
						case SELECT_TASK://タスク選択
						
						//アーム動作
							//シーソーからブランコに向かうとき
							if(step == 12){
								if(g_x_c < ARM_CHANGE_POSITION_5){
									
									if(getdate2.byte.r2_sw == 1){
										Move_top_arm_lift_velocity(OPERATE_ARM_12_5_0 + adjustment_sum[0] , step);
										Move_all_arm_2(OPERATE_ARM_12_1_0 + adjustment_sum[1],  OPERATE_ARM_12_2_0 + adjustment_sum[3],  OPERATE_ARM_12_3_0 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									}else{
										Move_top_arm_lift_velocity(OPERATE_ARM_12_5_1 + adjustment_sum[0] , step);
										Move_all_arm_2(OPERATE_ARM_12_1_1 + adjustment_sum[1],  OPERATE_ARM_12_2_0 + adjustment_sum[3],  OPERATE_ARM_12_3_0 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									}
									
								}else if((g_x_c >= ARM_CHANGE_POSITION_5) && (g_x_c <= ARM_CHANGE_POSITION_6)){
									
									Move_all_arm_2(OPERATE_ARM_12_1_1 + adjustment_sum[1],  OPERATE_ARM_12_2_1 + adjustment_sum[3],  OPERATE_ARM_12_3_1 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									
									if(getdate2.byte.r2_sw == 1){
										Move_top_arm_lift_velocity(OPERATE_ARM_12_5_0 + adjustment_sum[0] , step);
									}else{
										Move_top_arm_lift_velocity(OPERATE_ARM_12_5_1 + adjustment_sum[0] , step);
									}
									//Move_top_arm_lift_velocity(OPERATE_ARM_12_5_0 + adjustment_sum[0] , step);
								}else if(g_x_c > ARM_CHANGE_POSITION_6){
								
									Move_all_arm_2(OPERATE_ARM_12_1_1 + adjustment_sum[1],  OPERATE_ARM_12_2_1 + adjustment_sum[3],  OPERATE_ARM_12_3_1 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_12_5_2, step);
								
								}
								/*if(g_x_c < ARM_CHANGE_POSITION_6){
									if(getdate2.byte.r2_sw == 1){
										Move_top_arm_lift_velocity(OPERATE_ARM_12_5_0 + adjustment_sum[0] , step);
										Move_all_arm_2(OPERATE_ARM_12_1_0 + adjustment_sum[1],  OPERATE_ARM_12_2_0 + adjustment_sum[3],  OPERATE_ARM_12_3_0 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									}else{
										Move_top_arm_lift_velocity(OPERATE_ARM_12_5_1 + adjustment_sum[0] , step);
										Move_all_arm_2(OPERATE_ARM_12_1_1 + adjustment_sum[1],  OPERATE_ARM_12_2_0 + adjustment_sum[3],  OPERATE_ARM_12_3_0 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									}
								}else{
									Move_all_arm_2(OPERATE_ARM_12_1_1 + adjustment_sum[1],  OPERATE_ARM_12_2_1 + adjustment_sum[3],  OPERATE_ARM_12_3_1 + adjustment_sum[2],  OPERATE_ARM_12_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_12_5_2, step);
								}*/
								
							//ブランコからポールに向かうとき	
							}else if(step == 21){
							//else if(step == 20){
								#if COLOR == RED
								if(g_y_c >= ARM_CHANGE_POSITION_7){
									/*if(g_flag_catch_from_swing == OFF){
										if(getdate2.byte.r2_sw == 0){
											g_flag_catch_from_swing = ON;
										}else{
											Move_top_arm_lift_velocity(OPERATE_ARM_14_5 + adjustment_sum[0],  step);
										}
									}else{
										Move_top_arm_lift_velocity(OPERATE_ARM_21_5_0,  step);
									}*/
									Move_all_arm_2(OPERATE_ARM_21_1 ,  OPERATE_ARM_21_2_0 ,  OPERATE_ARM_21_3,  OPERATE_ARM_21_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_21_5_0,  step);
								}else if(g_y_c >= ARM_CHANGE_POSITION_8 && (g_y_c < ARM_CHANGE_POSITION_7)){
									Move_all_arm_2(OPERATE_ARM_21_1 ,  OPERATE_ARM_21_2_0 ,  OPERATE_ARM_21_3,  OPERATE_ARM_21_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_21_5_1 ,  step);
								}else if(g_y_c < ARM_CHANGE_POSITION_8){
									Move_all_arm_2(OPERATE_ARM_21_1 ,  OPERATE_ARM_21_2_1 ,  OPERATE_ARM_21_3,  OPERATE_ARM_21_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_21_5_2 + adjustment_sum[0],   step);
								}
								#elif COLOR == BLUE
								if(g_y_c <= ARM_CHANGE_POSITION_7){
									Move_top_arm_lift_velocity(OPERATE_ARM_21_5_0,  step);
									Move_all_arm_2(OPERATE_ARM_21_1 ,  OPERATE_ARM_21_2_0 ,  OPERATE_ARM_21_3,  OPERATE_ARM_21_4,  step);
								}else if(g_y_c <= ARM_CHANGE_POSITION_8 && (g_y_c > ARM_CHANGE_POSITION_7)){
									Move_top_arm_lift_velocity(OPERATE_ARM_21_5_1 ,  step);
									Move_all_arm_2(OPERATE_ARM_21_1 ,  OPERATE_ARM_21_2_0 ,  OPERATE_ARM_21_3,  OPERATE_ARM_21_4,  step);
								}else if(g_y_c > ARM_CHANGE_POSITION_8){
									Move_top_arm_lift_velocity(OPERATE_ARM_21_5_2 + adjustment_sum[0],   step);
									Move_all_arm_2(OPERATE_ARM_21_1 ,  OPERATE_ARM_21_2_1 ,  OPERATE_ARM_21_3,  OPERATE_ARM_21_4,  step);
								}
								#endif
								
							}else{//ポールからジャングルジムに向かうとき
							
								#if COLOR == RED
										if(g_y_c <= ARM_CHANGE_POSITION_9){
									
											Move_all_arm_2(OPERATE_ARM_26_1_0 ,  OPERATE_ARM_26_2_0 ,  OPERATE_ARM_26_3_0,  OPERATE_ARM_26_4,  step);
											Move_top_arm_lift_velocity(OPERATE_ARM_26_5_0,  step);
								
										}else if((g_y_c >= ARM_CHANGE_POSITION_9) && (g_y_c <= ARM_CHANGE_POSITION_10)){
								
											Move_all_arm_2(OPERATE_ARM_26_1_0 ,  OPERATE_ARM_26_2_1 ,  OPERATE_ARM_26_3_0,  OPERATE_ARM_26_4,  step);
											Move_top_arm_lift_velocity(OPERATE_ARM_26_5_0,  step);
								
										}else if(g_y_c >= ARM_CHANGE_POSITION_10){						
										
											//ピッチ回転の角度に応じての高さ変更
											
											if(g_top_arm_tilt_degree >= 70){
												target_top_arm_z = OPERATE_ARM_26_5_0 + (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * (OPERATE_ARM_26_5_1 - OPERATE_ARM_26_5_0);
												target_top_arm_z = Limit_ul(OPERATE_ARM_26_5_0, OPERATE_ARM_26_5_1, target_top_arm_z);
											}else{
												target_top_arm_z = OPERATE_ARM_26_5_0 + (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * ((OPERATE_ARM_26_5_1 + 50) - OPERATE_ARM_26_5_0);
												target_top_arm_z = Limit_ul(OPERATE_ARM_26_5_0, OPERATE_ARM_26_5_1 + 50, target_top_arm_z);
											}
											//ピッチ回転の角度に応じての上アーム長さ変更
											target_top_arm_length = OPERATE_ARM_26_1_0 +  (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * (OPERATE_ARM_26_1_1 - OPERATE_ARM_26_1_0);
											target_top_arm_length = Limit_ul(OPERATE_ARM_26_1_0,  OPERATE_ARM_26_1_1,  target_top_arm_length);
									
											Move_all_arm_2(target_top_arm_length + adjustment_sum[1],  OPERATE_ARM_26_2_1 + adjustment_sum[3],  OPERATE_ARM_26_3_1 + adjustment_sum[2],  OPERATE_ARM_26_4,  step);
											Move_top_arm_lift_velocity(target_top_arm_z + adjustment_sum[0],   step);
										}
										//Move_all_arm_2(OPERATE_ARM_26_1_0  + adjustment_sum[1],  OPERATE_ARM_26_2_0  + adjustment_sum[3],  OPERATE_ARM_26_3_0 + adjustment_sum[2],  OPERATE_ARM_26_4,  step);
										//Move_top_arm_lift_velocity(OPERATE_ARM_26_5_0 + adjustment_sum[0],  step);
										
								#elif COLOR == BLUE
										if(g_y_c >= ARM_CHANGE_POSITION_9){
									
											Move_all_arm_2(OPERATE_ARM_26_1_0 ,  OPERATE_ARM_26_2_0 ,  OPERATE_ARM_26_3_0,  OPERATE_ARM_26_4,  step);
											Move_top_arm_lift_velocity(OPERATE_ARM_26_5_0,  step);
								
										}else if((g_y_c <= ARM_CHANGE_POSITION_9) && (g_y_c >= ARM_CHANGE_POSITION_10)){
								
											Move_all_arm_2(OPERATE_ARM_26_1_0 ,  OPERATE_ARM_26_2_1 ,  OPERATE_ARM_26_3_0,  OPERATE_ARM_26_4,  step);
											Move_top_arm_lift_velocity(OPERATE_ARM_26_5_0,  step);
								
										}else if(g_y_c <= ARM_CHANGE_POSITION_10){						
										
											//ピッチ回転の角度に応じての高さ変更
											//target_top_arm_z = OPERATE_ARM_26_5_0 + (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * (OPERATE_ARM_26_5_1 - OPERATE_ARM_26_5_0);
											//target_top_arm_z = Limit_ul(OPERATE_ARM_26_5_0, OPERATE_ARM_26_5_1, target_top_arm_z);
											
											if(g_top_arm_tilt_degree >= 70){
												target_top_arm_z = OPERATE_ARM_26_5_0 + (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * (OPERATE_ARM_26_5_1 - OPERATE_ARM_26_5_0);
												target_top_arm_z = Limit_ul(OPERATE_ARM_26_5_0, OPERATE_ARM_26_5_1, target_top_arm_z);
											}else{
												target_top_arm_z = OPERATE_ARM_26_5_0 + (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * ((OPERATE_ARM_26_5_1 + 50) - OPERATE_ARM_26_5_0);
												target_top_arm_z = Limit_ul(OPERATE_ARM_26_5_0, OPERATE_ARM_26_5_1 + 50, target_top_arm_z);
											}
									
											//ピッチ回転の角度に応じての上アーム長さ変更
											target_top_arm_length = OPERATE_ARM_26_1_0 +  (g_top_arm_tilt_degree / OPERATE_ARM_26_3_1) * (OPERATE_ARM_26_1_1 - OPERATE_ARM_26_1_0);
											target_top_arm_length = Limit_ul(OPERATE_ARM_26_1_0,  OPERATE_ARM_26_1_1,  target_top_arm_length);
									
											//Move_all_arm(target_top_arm_length + adjustment_sum[1],  0.0 + adjustment_sum[3],  90.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(target_top_arm_length + adjustment_sum[1],  OPERATE_ARM_26_2_1 + adjustment_sum[3],  OPERATE_ARM_26_3_1 + adjustment_sum[2],  OPERATE_ARM_26_4,  step);
											Move_top_arm_lift_velocity(target_top_arm_z + adjustment_sum[0],   step);
										}
										/*
										Move_all_arm_2(OPERATE_ARM_26_1_0  + adjustment_sum[1],  OPERATE_ARM_26_2_0  + adjustment_sum[3],  OPERATE_ARM_26_3_0 + adjustment_sum[2],  OPERATE_ARM_26_4,  step);
										Move_top_arm_lift_velocity(OPERATE_ARM_26_5_0 + adjustment_sum[0],  step);
										*/
								#endif
								
							}
							Air_all_on_off(OFF,  OFF,  OFF,  OFF);
							
							
							if((step == 12) && (step_old == 11)){//シーソー→ブランコ向かう時のフラグ立て
								flag[2] = ON;
								flag[5] = OFF;
								flag[7] = OFF;
							}else if ((step == 21) && (step_old == 20)){//ブランコ→ポール向かう時のフラグ立て
								flag[2] = OFF;
								flag[5] = ON;
								flag[7] = OFF;
							}else if((step == 26) && (step_old == 25)){//ポールからジャングルジム向かう時のフラグ立て
								flag[2] = OFF;
								flag[5] = OFF;
								flag[7] = ON;
							}
							/*else if ((step == 20) && (step_old == 19)){//ブランコ→ポール向かう時のフラグ立て
								flag[2] = OFF;
								flag[5] = ON;
								flag[7] = OFF;
							}else if((step == 25) && (step_old == 24)){//ポールからジャングルジム向かう時のフラグ立て
								flag[2] = OFF;
								flag[5] = OFF;
								flag[7] = ON;
							}*/
							
							if((flag[2] == ON) && (flag[5] == OFF) && (flag[7] == OFF)){//シーソーからブランコに向かう足回り自動化
								if(getdate2.byte.r2_sw == 0){
									
									switch(auto_chapter_to_swing){
										
										case 0:
										/*g_x_c = TARGET_TO_SWING_X_0;
										g_y_c = TARGET_TO_SWING_Y_0;
										g_degree = TARGET_TO_SWING_DEGREE_0;*/
										//information_reset(g_x_c,g_y_c,g_degree);
										g_x_start = g_x_c;
										g_y_start = g_y_c;
										result_motor_output_l = 0.0;//BRAKE;
										result_motor_output_r = 0.0;//BRAKE;
										result_motor_output_b = 0.0;//BRAKE;
										flag[1] = OFF;
										auto_chapter_to_swing ++;
										break;
										
										case 1:
										calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,   g_x_c,  g_y_c,  TARGET_TO_SWING_X_1,  TARGET_TO_SWING_Y_1,  g_degree,  A_UP_TO_SWING,  A_DOWN_TO_SWING,  MAX_VELOCITY_TO_SWING,  step);
										flag_percentage_max = get_Atlas_curve(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_SWING_X_1,  TARGET_TO_SWING_Y_1,  TARGET_TO_SWING_DIRECTION_DEGREE,  g_degree,  step);
										/*if(g_x_c <= DEGREE_CHANGE_POSITION_1){
											BUZZER = OFF;
											motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_0,  g_degree);*/
										/*if(g_x_c <= DEGREE_CHANGE_POSITION_2){
											BUZZER = ON;
											if(fabs(get_gap_degree(TARGET_TO_SWING_DEGREE_1, g_degree)) <= 3.0){
												flag[1] = ON;
											}
											if(flag[1] == ON){
												motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_1,  g_degree);
											}else{
												target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_SWING_0,  A_DOWN_OMEGA_TO_SWING_0,  TARGET_TO_SWING_DEGREE_0,  g_degree,  TARGET_TO_SWING_DEGREE_1,  MAX_OMEGA_TO_SWING_0);
												motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
											}
										}else if(g_x_c > DEGREE_CHANGE_POSITION_2){
											BUZZER = OFF;
											if(fabs(get_gap_degree(TARGET_TO_SWING_DEGREE_2, g_degree)) <= 3.0){
												flag[4] = ON;
											}
											if(flag[4] == ON){
												motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_2,  g_degree);
											}else{
												target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_SWING_1,  A_DOWN_OMEGA_TO_SWING_1,  TARGET_TO_SWING_DEGREE_1,  g_degree,  TARGET_TO_SWING_DEGREE_2,  MAX_OMEGA_TO_SWING_1);
												motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
											}
										}*/
										
										if(flag[1] == OFF){
											BUZZER = ON;
											if(fabs(get_gap_degree(TARGET_TO_SWING_DEGREE_1, g_degree)) <= 3.0){
												flag[1] = ON;
											}
											
											target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_SWING_0,  A_DOWN_OMEGA_TO_SWING_0,  TARGET_TO_SWING_DEGREE_0,  g_degree,  TARGET_TO_SWING_DEGREE_1,  MAX_OMEGA_TO_SWING_0);
											motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
											
										}else{
											BUZZER = OFF;
											if(fabs(get_gap_degree(TARGET_TO_SWING_DEGREE_2, g_degree)) <= 3.0){
												flag[4] = ON;
											}
											if(flag[4] == ON){
												motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_2,  g_degree);
											}else{
												target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_SWING_1,  A_DOWN_OMEGA_TO_SWING_1,  TARGET_TO_SWING_DEGREE_1,  g_degree,  TARGET_TO_SWING_DEGREE_2,  MAX_OMEGA_TO_SWING_1);
												motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
											}
										}
										
										if(flag_percentage_max == ON){
											auto_chapter_to_swing ++;
										}
										result_motor_output_l = motor_output_velocity.l + motor_output_distance.l + motor_output_turn;
										result_motor_output_r = motor_output_velocity.r + motor_output_distance.r + motor_output_turn;
										result_motor_output_b = motor_output_velocity.b + motor_output_distance.b + motor_output_turn;
										break;
										
										case 2:
										calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_SWING_X_1,  TARGET_TO_SWING_Y_1, g_degree,  TARGET_TO_SWING_DEGREE_2,  step);
										result_motor_output_l = motor_output_position_lock.l;
										result_motor_output_r = motor_output_position_lock.r;
										result_motor_output_b = motor_output_position_lock.b;
										break;
										/*
										case 1:
										case 2:
										
										calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,   g_x_c,  g_y_c,  TARGET_TO_SWING_X_1,  TARGET_TO_SWING_Y_1,  g_degree,  A_UP_TO_SWING,  A_DOWN_TO_SWING,  MAX_VELOCITY_TO_SWING,  step);
										
										if(auto_chapter_to_swing == 1){
											x_start_curve = g_x_start;
											y_start_curve = g_y_start;
											flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  5000,  2500,  100,  g_degree,  auto_chapter_to_swing + 10);
										}else if(auto_chapter_to_swing == 2){
											x_start_curve = 5000;
											y_start_curve = 2500;
											flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  TARGET_TO_SWING_X_1,  TARGET_TO_SWING_Y_1,  0.0,  g_degree,  auto_chapter_to_swing + 10);
										}
										
										if(g_x_c <= DEGREE_CHANGE_POSITION_1){
											motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_0,  g_degree);
										}else if((g_x_c > DEGREE_CHANGE_POSITION_1) && (g_x_c <= DEGREE_CHANGE_POSITION_2)){
											if(fabs(get_gap_degree(TARGET_TO_SWING_DEGREE_1, g_degree)) <= 3.0){
												flag[1] = ON;
											}
											if(flag[1] == ON){
												motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_1,  g_degree);
											}else{
												target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_SWING_0,  A_DOWN_OMEGA_TO_SWING_0,  TARGET_TO_SWING_DEGREE_0,  g_degree,  TARGET_TO_SWING_DEGREE_1,  MAX_OMEGA_TO_SWING_0);
												motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
											}
										}else if(g_x_c > DEGREE_CHANGE_POSITION_2){
											if(fabs(get_gap_degree(TARGET_TO_SWING_DEGREE_2, g_degree)) <= 3.0){
												flag[4] = ON;
											}
											if(flag[4] == ON){
												motor_output_turn = get_motor_output_turn(TARGET_TO_SWING_DEGREE_2,  g_degree);
											}else{
												target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_SWING_1,  A_DOWN_OMEGA_TO_SWING_1,  TARGET_TO_SWING_DEGREE_1,  g_degree,  TARGET_TO_SWING_DEGREE_2,  MAX_OMEGA_TO_SWING_1);
												motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
											}
										}
										if(flag_percentage_max == ON){
											auto_chapter_to_swing ++;
										}
										result_motor_output_l = motor_output_velocity.l + motor_output_distance.l + motor_output_turn;
										result_motor_output_r = motor_output_velocity.r + motor_output_distance.r + motor_output_turn;
										result_motor_output_b = motor_output_velocity.b + motor_output_distance.b + motor_output_turn;
										break;
										
										case 3:
										calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_SWING_X_1,  TARGET_TO_SWING_Y_1, g_degree,  TARGET_TO_SWING_DEGREE_2,  step);
										result_motor_output_l = motor_output_position_lock.l;
										result_motor_output_r = motor_output_position_lock.r;
										result_motor_output_b = motor_output_position_lock.b;
										break;
										*/
									}
								}
							}else if((flag[5] == ON) && (flag[2] == OFF) && (flag[7] == OFF)){//ブランコからポールに向かう足回り自動化
								if(getdate2.byte.r2_sw == 0){
									//BUZZER = ON;
									target_degree = g_degree;
									switch(auto_chapter_to_pole){
										
										case 0:
										/*g_x_c = TARGET_TO_POLE_X_0;
										g_y_c = TARGET_TO_POLE_Y_0;
										g_degree = TARGET_TO_POLE_DEGREE_0;*/
										//nformation_reset(g_x_c,g_y_c,g_degree);
										g_x_start = g_x_c;
										g_y_start = g_y_c;
										result_motor_output_l = 0.0;//BRAKE;
										result_motor_output_r = 0.0;//BRAKE;
										result_motor_output_b = 0.0;//BRAKE;
										flag[1] = OFF;
										auto_chapter_to_pole ++;
										break;
										
										case 1:
										case 2:
											calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_POLE_X_2  ,TARGET_TO_POLE_Y_2,  g_degree,  1500,  1200,  2000,  step);
											if(auto_chapter_to_pole == 1){
												x_start_curve = g_x_start;
												y_start_curve = g_y_start;
												flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  TARGET_TO_POLE_X_1,  TARGET_TO_POLE_Y_1,  TARGET_TO_POLE_DIRECTION_DEGREE_0,  g_degree,  auto_chapter_to_pole + 3);
												//motor_output_turn = get_motor_output_turn(90.0,  g_degree);
											}else if(auto_chapter_to_pole == 2){
												x_start_curve = TARGET_TO_POLE_X_1;
												y_start_curve = TARGET_TO_POLE_Y_1;
												flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  TARGET_TO_POLE_X_2, TARGET_TO_POLE_Y_2,  TARGET_TO_POLE_DIRECTION_DEGREE_1,  g_degree,  auto_chapter_to_pole + 3);
												/*if(fabs(get_gap_degree(0.0,  g_degree) < 3.0)){
													flag[1] = ON;
												}
												if(flag[1] == ON){
													motor_output_turn = get_motor_output_turn(0,  g_degree);
												}else{
													target_omega = get_target_omega( 2,  80,  80,  90.0,  g_degree,  0.0,  150);
													motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
												}*/
												//motor_output_turn = get_motor_output_turn(90.0,  g_degree);
											}
										
											if(flag_percentage_max == ON){
												auto_chapter_to_pole ++;
											}
										
											#if COLOR == RED
											if(g_y_c > DEGREE_CHANGE_POSITION_3){
												motor_output_turn = get_motor_output_turn(TARGET_TO_POLE_DEGREE_0,  g_degree);
											}else{
												if(fabs(get_gap_degree(TARGET_TO_POLE_DEGREE_1,  g_degree)) <= 3.0){
													flag[1] = ON;
												}
												if(flag[1] == ON){
													motor_output_turn = get_motor_output_turn(TARGET_TO_POLE_DEGREE_1,  g_degree);
												}else{
													target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_POLE,  A_DOWN_OMEGA_TO_POLE,  TARGET_TO_POLE_DEGREE_0,  g_degree,  TARGET_TO_POLE_DEGREE_1,  MAX_OMEGA_TO_POLE);
													motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
												}
											}
											#elif COLOR == BLUE
											if(g_y_c < DEGREE_CHANGE_POSITION_3){
												motor_output_turn = get_motor_output_turn(TARGET_TO_POLE_DEGREE_0,  g_degree);
											}else{
												if(fabs(get_gap_degree(TARGET_TO_POLE_DEGREE_1,  g_degree)) <= 3.0){
													flag[1] = ON;
												}
												if(flag[1] == ON){
													motor_output_turn = get_motor_output_turn(TARGET_TO_POLE_DEGREE_1,  g_degree);
												}else{
													target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_POLE,  A_DOWN_OMEGA_TO_POLE,  TARGET_TO_POLE_DEGREE_0,  g_degree,  TARGET_TO_POLE_DEGREE_1,  MAX_OMEGA_TO_POLE);
													motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
												}
											}
											#endif
											result_motor_output_l = motor_output_velocity.l + motor_output_distance.l + motor_output_turn;
											result_motor_output_r = motor_output_velocity.r + motor_output_distance.r + motor_output_turn;
											result_motor_output_b = motor_output_velocity.b + motor_output_distance.b + motor_output_turn;
										break;
										
										case 3:
										calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_POLE_X_2,  TARGET_TO_POLE_Y_2,  g_degree,  TARGET_TO_POLE_DEGREE_1,  step);
										result_motor_output_l = motor_output_position_lock.l;
										result_motor_output_r = motor_output_position_lock.r;
										result_motor_output_b = motor_output_position_lock.b;
										break;
									}
								}
							}else if((flag[7] == ON) && (flag[2] == OFF) && (flag[5] == OFF)){
								if(getdate2.byte.r2_sw == 0){
									switch(auto_chapter_to_jungle_gym){
										case 0:
											//information_reset(g_x_c,g_y_c,g_degree);
											g_x_start = g_x_c;
											g_y_start = g_y_c;
											result_motor_output_l = 0.0;//BRAKE;
											result_motor_output_r = 0.0;//BRAKE;
											result_motor_output_b = 0.0;//BRAKE;
											flag[1] = OFF;
											auto_chapter_to_jungle_gym ++;
											start_degree = g_degree;
										break;
										case 1:
										
											calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,  g_x_c,  g_y_c, TARGET_TO_JUNGLE_X,  TARGET_TO_JUNGLE_Y,  g_degree,  A_UP_TO_JUNGLE, 	A_DOWN_TO_JUNGLE,  MAX_VELOCITY_TO_JUNGLE,  step);
											flag_percentage_max = get_Atlas_curve(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_JUNGLE_X,  TARGET_TO_JUNGLE_Y,  TARGET_TO_JUNGLE_DIRECTION_DEGREE,  g_degree,  step);
											
											
											#if COLOR == RED
											if(g_y_c <= DEGREE_CHANGE_POSITION_4){
												motor_output_turn = get_motor_output_turn(start_degree,  g_degree);
											}else{
												if(fabs(get_gap_degree(TARGET_TO_JUNGLE_DEGREE,  g_degree)) <= 3.0){
														flag[1] = ON;
												}
												if(flag[1] == ON){
													motor_output_turn = get_motor_output_turn(TARGET_TO_JUNGLE_DEGREE,  g_degree);
												}else{
													target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_JUNGLE,  A_DOWN_OMEGA_TO_JUNGLE,  start_degree,  g_degree,  TARGET_TO_JUNGLE_DEGREE,  MAX_OMEGA_TO_JUNGLE);
													motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
												}
											}
											#elif COLOR == BLUE
											if(g_y_c >= DEGREE_CHANGE_POSITION_4){
												motor_output_turn = get_motor_output_turn(start_degree,  g_degree);
											}else{
												if(fabs(get_gap_degree(TARGET_TO_JUNGLE_DEGREE,  g_degree)) <= 3.0){
														flag[1] = ON;
												}
												if(flag[1] == ON){
													motor_output_turn = get_motor_output_turn(TARGET_TO_JUNGLE_DEGREE,  g_degree);
												}else{
													target_omega = get_target_omega( 2,  A_UP_OMEGA_TO_JUNGLE,  A_DOWN_OMEGA_TO_JUNGLE,  start_degree,  g_degree,  TARGET_TO_JUNGLE_DEGREE,  MAX_OMEGA_TO_JUNGLE);
													motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
												}
											}
											#endif
											
											if(flag_percentage_max == ON){
												auto_chapter_to_jungle_gym ++;
											}
											
											
											result_motor_output_l = motor_output_velocity.l + motor_output_distance.l + motor_output_turn;
											result_motor_output_r = motor_output_velocity.r + motor_output_distance.r + motor_output_turn;
											result_motor_output_b = motor_output_velocity.b + motor_output_distance.b + motor_output_turn;
											
										break;
										case 2:
										calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_JUNGLE_X,  TARGET_TO_JUNGLE_Y,  g_degree, TARGET_TO_JUNGLE_DEGREE,  step);
										result_motor_output_l = motor_output_position_lock.l;
										result_motor_output_r = motor_output_position_lock.r;
										result_motor_output_b = motor_output_position_lock.b;
										break;
									}
									BUZZER = ON;
								}else{
									BUZZER = OFF;
								}
							}
							
							
							//タスク選択
							if(getdate2.byte.l2_sw == 0){
								if(getdate2.byte.cross_sw == 0){//×ボタン→シーソー
									step = 3;
									g_x_start = g_x_c;
									g_y_start = g_y_c;
									auto_chapter_seesaw = 0;
								}else if(getdate2.byte.square_sw == 0){//□ボタン→ブランコ
									step = 13;
									g_x_start = g_x_c;
									g_y_start = g_y_c;
									auto_chapter_swing = 0;
								}else if(getdate2.byte.circle_sw == 0){//○ボタン→ポールウォーク
									step = 22;
									//step = 21;
									g_x_start = g_x_c;
									g_y_start = g_y_c;
								}/*else if(getdate2.byte.triangle_sw == 0){//△ボタン→ジャングルジム
									step = 28;
									g_x_start = g_x_c;
									g_y_start = g_y_c;
								}*/
							}
						break;
						/*********************************************************************************************/
						
						
						
						
						
						/************************シーソー**************************************************************/
						case TASK_SEESAW:
							switch(step){
								case 3:
									if(g_x_c < ARM_CHANGE_POSITION_0){
										Move_top_arm_lift_velocity(OPERATE_ARM_3_5_0 ,  step);
										Move_all_arm_2(OPERATE_ARM_3_1_0 + adjustment_sum[1] , OPERATE_ARM_3_2_0 + adjustment_sum[3], OPERATE_ARM_3_3 + adjustment_sum[2],  OPERATE_ARM_3_4,  step);
									}else if((g_x_c >= ARM_CHANGE_POSITION_0) && (g_x_c < ARM_CHANGE_POSITION_1)){
										Move_top_arm_lift_velocity(OPERATE_ARM_3_5_0 ,  step);
										Move_all_arm_2(OPERATE_ARM_3_1_0 + adjustment_sum[1] , OPERATE_ARM_3_2_1 + adjustment_sum[3], OPERATE_ARM_3_3 + adjustment_sum[2],  OPERATE_ARM_3_4,  step);
									}else{
										Move_top_arm_lift_velocity(OPERATE_ARM_3_5_1 + adjustment_sum[0]  , step);
										Move_all_arm_2(OPERATE_ARM_3_1_1 + adjustment_sum[1] , OPERATE_ARM_3_2_1 + adjustment_sum[3], OPERATE_ARM_3_3 + adjustment_sum[2],  OPERATE_ARM_3_4,  step);
									}
									
									
									//スタートゾーンからシーソーに向かう
									if(getdate2.byte.r2_sw == 0){
										if(flag[0] == OFF){
											//calculate_motor_output_lrb_velocity(TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_c,  g_y_c,  g_degree,  pick_out_atoz_value('A'),  pick_out_atoz_value('B'),  pick_out_atoz_value('C'),  step);
											//calculate_motor_output_lrb_velocity(TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_c,  g_y_c,  g_degree,  A_UP_TO_SEESAW,  A_DOWN_TO_SEESAW,  MAX_VELOCITY_TO_SEESAW,  step);
											calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_degree,  A_UP_TO_SEESAW,  A_DOWN_TO_SEESAW,  MAX_VELOCITY_TO_SEESAW,  step);
											
											//calculate_motor_output_lrb_slow_velocity( TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_c,  g_y_c,  g_degree,  10);
											
											
											switch(auto_chapter_start){
												case 0:
												x_start_curve = g_x_start;
												y_start_curve = g_y_start;
												flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  TARGET_MIDDLE_X,  TARGET_MIDDLE_Y,  TARGET_TO_SEESAW_DIRECTION_1,  g_degree,  auto_chapter_start);
												break;
												case 1:
												x_start_curve = TARGET_MIDDLE_X;
												y_start_curve = TARGET_MIDDLE_Y;
												flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  TARGET_TO_SEESAW_DIRECTION_2,  g_degree,  auto_chapter_start);
												break;
												/*default:
												//flag[0] = ON;
												//target_degree = g_degree;
												break;*/
											}
											if(flag_percentage_max == ON){
												auto_chapter_start ++;
											}
											if(g_x_c <= DEGREE_CHANGE_POSITION_0){
												motor_output_turn = get_motor_output_turn(START_DEGREE,  g_degree);
											}else{
												if(fabs(get_gap_degree(TARGET_TO_SEESAW_DEGREE , g_degree)) <= 3.0){
													flag[1] = ON;
												}
												if(flag[1] == ON){
													motor_output_turn = get_motor_output_turn(TARGET_TO_SEESAW_DEGREE,  g_degree);
												}else{
													target_omega = get_target_omega(2,  A_UP_OMEGA,  A_DOWN_OMEGA,  START_DEGREE,  g_degree,  TARGET_TO_SEESAW_DEGREE,  MAX_OMEGA);
													motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
												}
											}
											
											/*if(get_vertical_distance_func(TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_c,  g_y_c,  get_target_degree(TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_start,  g_y_start)) <= 750){
												result_motor_output_l = motor_output_slow_velocity.l;
												result_motor_output_r = motor_output_slow_velocity.r;
												result_motor_output_b = motor_output_slow_velocity.b;
												BUZZER = ON;
											}else{
												BUZZER = OFF;
												result_motor_output_l = motor_output_velocity.l + motor_output_distance.l + motor_output_turn;
												result_motor_output_r = motor_output_velocity.r + motor_output_distance.r + motor_output_turn;
												result_motor_output_b = motor_output_velocity.b + motor_output_distance.b + motor_output_turn;
											}*/
											
											result_motor_output_l = motor_output_velocity.l + motor_output_distance.l + motor_output_turn;
											result_motor_output_r = motor_output_velocity.r + motor_output_distance.r + motor_output_turn;
											result_motor_output_b = motor_output_velocity.b + motor_output_distance.b + motor_output_turn;
											
											if(get_vertical_distance_func(TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_c,  g_y_c,  get_target_degree(TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_x_start,  g_y_start)) <= 20){
													flag[0] = ON;
											}
											
										}else{
											
											calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_degree,  TARGET_TO_SEESAW_DEGREE,  step);
											result_motor_output_l = motor_output_position_lock.l;
											result_motor_output_r = motor_output_position_lock.r;
											result_motor_output_b = motor_output_position_lock.b;
											/*calculate_motor_output_lrb_brake(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_TO_SEESAW_X,  TARGET_TO_SEESAW_Y,  g_degree, 200 , TARGET_TO_SEESAW_DEGREE,  step);
											result_motor_output_l = motor_output_brake.l;
											result_motor_output_r = motor_output_brake.r;
											result_motor_output_b = motor_output_brake.b;*/
										}
									}
								break;
								case 4://子供ロボットおろす
									Move_all_arm_2(OPERATE_ARM_4_1 + adjustment_sum[1],  OPERATE_ARM_4_2 + adjustment_sum[3],  OPERATE_ARM_4_3 + adjustment_sum[2],  OPERATE_ARM_4_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_4_5 + adjustment_sum[0]  , step);
									Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								break;
								case 5://置いて押す位置に移動
									#if COLOR == RED
										if(g_y_c > ARM_CHANGE_POSITION_2){
											//Move_all_arm(450.0 + adjustment_sum[1],  -90.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(OPERATE_ARM_5_1_0 + adjustment_sum[1],   OPERATE_ARM_5_2 + adjustment_sum[3],  OPERATE_ARM_5_3_0 + adjustment_sum[2],  OPERATE_ARM_5_4_0,  step);
											Move_top_arm_lift_velocity(OPERATE_ARM_5_5_0 + adjustment_sum[0]  , step);
										}else{
											//Move_all_arm(580.0 + adjustment_sum[1],  -90.0 ,  0.0 + adjustment_sum[2],  420.0);
											Move_all_arm_2(OPERATE_ARM_5_1_1 + adjustment_sum[1],  OPERATE_ARM_5_2 ,  OPERATE_ARM_5_3_1 + adjustment_sum[2],  OPERATE_ARM_5_4_1,  step);
											Move_seesaw_arm_lift_velocity(OPERATE_ARM_5_5_1 + adjustment_sum[0], step);
										}
									#elif COLOR == BLUE
										if(g_y_c < ARM_CHANGE_POSITION_2){
											//Move_all_arm(450.0 + adjustment_sum[1],  90.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(OPERATE_ARM_5_1_0 + adjustment_sum[1], OPERATE_ARM_5_2 + adjustment_sum[3],  OPERATE_ARM_5_3_0 + adjustment_sum[2],  OPERATE_ARM_5_4_0,  step);
											Move_top_arm_lift_velocity(OPERATE_ARM_5_5_0 + adjustment_sum[0] , step);
										}else{
											//Move_all_arm(580.0 + adjustment_sum[1],  90.0 ,  0.0 + adjustment_sum[2],  420.0);
											Move_all_arm_2(OPERATE_ARM_5_1_1 + adjustment_sum[1],  OPERATE_ARM_5_2 ,  OPERATE_ARM_5_3_1 + adjustment_sum[2],  OPERATE_ARM_5_4_1,  step);
											Move_seesaw_arm_lift_velocity(OPERATE_ARM_5_5_1 + adjustment_sum[0], step);
										}
									#endif	
									Air_all_on_off(ON,  OFF,  OFF,  OFF);
									
									//足回り自動化
									if(getdate2.byte.r2_sw == 0){
										
										if(flag_auto_seesaw == OFF){
										
											if(auto_chapter_seesaw == 0){//シーソースタート地点リセット
												g_x_c = TARGET_SEESAW_X_0;//4243.0;
												g_y_c = TARGET_SEESAW_Y_0;//1650.0
												g_degree = TARGET_SEESAW_DEGREE_0;
												information_reset(g_x_c,g_y_c,g_degree);
												result_motor_output_l = 0.0;//BRAKE;
												result_motor_output_r = 0.0;//BRAKE;
												result_motor_output_b = 0.0;//BRAKE;
												auto_chapter_seesaw ++;
											}else if(auto_chapter_seesaw == 1){//シーソー周り走行(置く→押す)
												calculate_motor_output_lrb_curve(TARGET_SEESAW_X_0, TARGET_SEESAW_Y_0,  g_x_c,  g_y_c,  SEESAW_CENTER_X,  SEESAW_CENTER_Y, TARGET_SEESAW_CENTER_DEGREE_0 ,g_degree, get_distance(SEESAW_CENTER_X,SEESAW_CENTER_Y ,TARGET_SEESAW_X_0,TARGET_SEESAW_Y_0), step);
												direction_target_degree = get_target_degree(SEESAW_CENTER_X,  SEESAW_CENTER_Y,  g_x_c,  g_y_c);
												motor_output_turn = get_motor_output_turn_seesaw(direction_target_degree,  g_degree,  auto_chapter_seesaw);		
												result_motor_output_l = motor_output_seesaw_curve.l + motor_output_turn;
												result_motor_output_r = motor_output_seesaw_curve.r + motor_output_turn;
												result_motor_output_b = motor_output_seesaw_curve.b + motor_output_turn;
												target_degree = g_degree;
											
												/*if(g_y_c < 0.0){
													if(get_vertical_distance_func(TARGET_SEESAW_X_1, TARGET_SEESAW_Y_1,  g_x_c,  g_y_c,  g_degree + 90.0) <= 10.0){
														auto_chapter_seesaw ++;
													}
												}*/
											}else if(auto_chapter_seesaw == 2){
												motor_output_turn = get_motor_output_turn_seesaw(TARGET_SEESAW_DEGREE_1,  g_degree,auto_chapter_seesaw );
												result_motor_output_l = motor_output_turn;
												result_motor_output_r = motor_output_turn;
												result_motor_output_b = motor_output_turn;
												target_degree = g_degree;
											}
											
										}else{
											result_motor_output_l = 0;
											result_motor_output_r = 0;
											result_motor_output_b = 0;
										}
									}else{
										
										#if COLOR == RED
										if(g_y_c <= 0){
											flag_auto_seesaw = ON;
										}else{
											flag_auto_seesaw = OFF;
										}
										#elif COLOR == BLUE
										if(g_y_c >= 0){
											flag_auto_seesaw = ON;
										}else{
											flag_auto_seesaw = OFF;
										}
										#endif
									}
								break;
								
								case 6://シーソー押す
								case 8:
								case 10:
									flag_auto_seesaw = OFF;
									//Move_all_arm(580.0 + adjustment_sum[1],  -90.0 , 0.0 + adjustment_sum[2],  420.0);
									Move_all_arm_2(OPERATE_ARM_6_1 + adjustment_sum[1],  OPERATE_ARM_6_2 , OPERATE_ARM_6_3 + adjustment_sum[2],  OPERATE_ARM_6_4,  step);
									Move_seesaw_arm_lift_velocity(OPERATE_ARM_6_5 + adjustment_sum[0],  step);
									Air_all_on_off(ON,  ON,  OFF,  OFF);
								break;
								
								case 7://シーソー引く
								case 9:
									//Move_all_arm(580.0 + adjustment_sum[1], -90.0,  0.0 + adjustment_sum[2],  420.0);
									Move_all_arm_2(OPERATE_ARM_7_1 + adjustment_sum[1], OPERATE_ARM_7_2,  OPERATE_ARM_7_3 + adjustment_sum[2],  OPERATE_ARM_7_4,  step);
									Move_seesaw_arm_lift_velocity(OPERATE_ARM_7_5+ adjustment_sum[0],  step);
									Air_all_on_off(ON,  OFF,  OFF,  OFF);
								break;
								
								case 11://シーソー押す位置から子供ロボット回収地まで移動
									#if COLOR == RED
										if(g_y_c < ARM_CHANGE_POSITION_3){
											//Move_all_arm(580.0 + adjustment_sum[1],  -90.0 ,  10.0 + adjustment_sum[2],  420.0);
											Move_all_arm_2(OPERATE_ARM_11_1_0 + adjustment_sum[1],  OPERATE_ARM_11_2_0 ,  OPERATE_ARM_11_3 + adjustment_sum[2],  OPERATE_ARM_11_4_0,  step);
											Move_seesaw_arm_lift_velocity(OPERATE_ARM_11_5_0,  step);
										}else if((g_y_c >= ARM_CHANGE_POSITION_3) && (g_y_c < ARM_CHANGE_POSITION_4)){
											//Move_all_arm(580.0 + adjustment_sum[1],  90.0 ,  10.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(OPERATE_ARM_11_1_0 + adjustment_sum[1],  OPERATE_ARM_11_2_1 ,  OPERATE_ARM_11_3 + adjustment_sum[2],  OPERATE_ARM_11_4_1,  step);
											Move_seesaw_arm_lift_velocity(OPERATE_ARM_11_5_0,  step);
										}else if(g_y_c >= ARM_CHANGE_POSITION_4){
											//Move_all_arm(450.0 + adjustment_sum[1],  90.0 + adjustment_sum[3],  10.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(OPERATE_ARM_11_1_1 + adjustment_sum[1],  OPERATE_ARM_11_2_1 + adjustment_sum[3],  OPERATE_ARM_11_3 + adjustment_sum[2],  OPERATE_ARM_11_4_1, step);
											Move_top_arm_lift_velocity(OPERATE_ARM_11_5_1 + adjustment_sum[0] , step);
										}
									#elif COLOR == BLUE
										if(g_y_c > ARM_CHANGE_POSITION_3){
											//Move_all_arm(580.0 + adjustment_sum[1],  90.0 ,  10.0 + adjustment_sum[2],  420.0);
											Move_all_arm_2(OPERATE_ARM_11_1_0 + adjustment_sum[1],  OPERATE_ARM_11_2_0 ,  OPERATE_ARM_11_3 + adjustment_sum[2],  OPERATE_ARM_11_4_0,  step);
											Move_seesaw_arm_lift_velocity(OPERATE_ARM_11_5_0,  step);
										}else if((g_y_c <= ARM_CHANGE_POSITION_3) && (g_y_c > ARM_CHANGE_POSITION_4)){
											//Move_all_arm(580.0 + adjustment_sum[1],  -90.0 ,  10.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(OPERATE_ARM_11_1_0 + adjustment_sum[1],  OPERATE_ARM_11_2_1 ,  OPERATE_ARM_11_3 + adjustment_sum[2],  OPERATE_ARM_11_4_1,  step);
											Move_seesaw_arm_lift_velocity(OPERATE_ARM_11_5_0,  step);
										}else if(g_y_c <= ARM_CHANGE_POSITION_4){
											//Move_all_arm(450.0 + adjustment_sum[1],  -90.0 + adjustment_sum[3],  10.0 + adjustment_sum[2],  0.0);
											Move_all_arm_2(OPERATE_ARM_11_1_1 + adjustment_sum[1],  OPERATE_ARM_11_2_1 + adjustment_sum[3],  OPERATE_ARM_11_3 + adjustment_sum[2],  OPERATE_ARM_11_4_1, step);
											Move_top_arm_lift_velocity(OPERATE_ARM_11_5_1 + adjustment_sum[0] , step);
										}
									#endif
									Air_all_on_off(ON,  OFF,  OFF, OFF);
									
									//足回り自動化
									if(getdate2.byte.r2_sw == 0){
										
										if(flag_auto_seesaw == OFF){
											if(auto_chapter_seesaw <= 2){
												auto_chapter_seesaw = 2;
												/*g_x_c = TARGET_SEESAW_X_2;
												g_y_c = TARGET_SEESAW_Y_2;
												g_degree = TARGET_SEESAW_DEGREE_2;*/
												g_x_c = g_target_seesaw_x_2;
												g_y_c = g_target_seesaw_y_2;
												g_degree = g_target_seesaw_degree_2;
												information_reset(g_x_c,g_y_c,g_degree);
												result_motor_output_l = 0.0;//BRAKE;
												result_motor_output_r = 0.0;//BRAKE;
												result_motor_output_b = 0.0;//BRAKE;
												auto_chapter_seesaw ++;
											}else if(auto_chapter_seesaw == 3){
												//calculate_motor_output_lrb_curve(TARGET_SEESAW_X_2, TARGET_SEESAW_Y_2,  g_x_c,  g_y_c,  SEESAW_CENTER_X,  SEESAW_CENTER_Y, TARGET_SEESAW_CENTER_DEGREE_1 ,g_degree, get_distance(SEESAW_CENTER_X,SEESAW_CENTER_Y ,TARGET_SEESAW_X_2,TARGET_SEESAW_Y_2),step);
												calculate_motor_output_lrb_curve(g_target_seesaw_x_2, g_target_seesaw_y_2,  g_x_c,  g_y_c,  SEESAW_CENTER_X,  SEESAW_CENTER_Y, TARGET_SEESAW_CENTER_DEGREE_1 ,g_degree, get_distance(SEESAW_CENTER_X,SEESAW_CENTER_Y ,g_target_seesaw_x_2,g_target_seesaw_y_2),step);
												direction_target_degree = get_target_degree(SEESAW_CENTER_X,  SEESAW_CENTER_Y,  g_x_c,  g_y_c);
												motor_output_turn = get_motor_output_turn_seesaw(direction_target_degree,  g_degree,  auto_chapter_seesaw);		
												result_motor_output_l = motor_output_seesaw_curve.l + motor_output_turn;
												result_motor_output_r = motor_output_seesaw_curve.r + motor_output_turn;
												result_motor_output_b = motor_output_seesaw_curve.b + motor_output_turn;
												target_degree = g_degree;
												/*if(g_y_c >= 0.0){
													if(get_vertical_distance_func(TARGET_SEESAW_X_3, TARGET_SEESAW_Y_3,  g_x_c,  g_y_c,  g_degree + 90.0) <= 10.0){
														auto_chapter_seesaw ++;
													}
												}*/
											}/*else if(auto_chapter_seesaw == 4){
												motor_output_turn = get_motor_output_turn_seesaw(TARGET_SEESAW_DEGREE_3,  g_degree,step );
												result_motor_output_l =  motor_output_turn;
												result_motor_output_r = motor_output_turn;
												result_motor_output_b = motor_output_turn;
												target_degree = g_degree;
											}*/
										}else{
											result_motor_output_l = 0;
											result_motor_output_r = 0;
											result_motor_output_b = 0;
										}
									}else{
										#if COLOR == RED
										if(g_y_c >= 0){
											flag_auto_seesaw = ON;
										}else{
											flag_auto_seesaw = OFF;
										}
										#elif COLOR == BLUE
										if(g_y_c <= 0){
											flag_auto_seesaw = ON;
										}else{
											flag_auto_seesaw = OFF;
										}
										#endif
									}
										
										
										/*if(getdate2.byte.r2_sw == 0){
												if(auto_chapter_seesaw <= 2){
													auto_chapter_seesaw = 2;
													g_x_c = TARGET_SEESAW_X_2;
													g_y_c = TARGET_SEESAW_Y_2;
													g_degree = TARGET_SEESAW_DEGREE_2;
													information_reset(g_x_c,g_y_c,g_degree);
													result_motor_output_l = 0.0;//BRAKE;
													result_motor_output_r = 0.0;//BRAKE;
													result_motor_output_b = 0.0;//BRAKE;
													auto_chapter_seesaw ++;
													flag[1] = OFF;
												}else if((auto_chapter_seesaw == 3) || (auto_chapter_seesaw == 4) || (auto_chapter_seesaw == 5)){
													//calculate_motor_output_lrb_curve(TARGET_SEESAW_X_2, TARGET_SEESAW_Y_2,  g_x_c,  g_y_c,  SEESAW_CENTER_X,  SEESAW_CENTER_Y, TARGET_SEESAW_CENTER_DEGREE ,g_degree, get_distance(SEESAW_CENTER_X,SEESAW_CENTER_Y ,TARGET_SEESAW_X_2,TARGET_SEESAW_Y_2),step);
													
													calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_SEESAW_X_3,  TARGET_SEESAW_Y_3, g_degree,  2200,  2200,  2000,	step);
													
													if(auto_chapter_seesaw == 3){
														x_start_curve = g_x_start;
														y_start_curve = g_y_start;
														flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  2300,  -500.0,  -170,  g_degree,  auto_chapter_seesaw);
													
														direction_target_degree = get_target_degree(SEESAW_CENTER_X,  SEESAW_CENTER_Y,  g_x_c,  g_y_c);
														motor_output_turn = get_motor_output_turn_seesaw(direction_target_degree,  g_degree,  auto_chapter_seesaw);	
														
														start_degree = g_degree;
													}else if(auto_chapter_seesaw == 4){
														x_start_curve = 2300;
														y_start_curve = -500.0;
														flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  3000,  1400.0,  110.0,  g_degree,  auto_chapter_seesaw);
													
														
														
														//direction_target_degree = get_target_degree(SEESAW_CENTER_X,  SEESAW_CENTER_Y,  g_x_c,  g_y_c);
														//motor_output_turn = get_motor_output_turn_seesaw(direction_target_degree,  g_degree,  auto_chapter_seesaw);
													}else if(auto_chapter_seesaw == 5){
														x_start_curve = 3000;
														y_start_curve = 1400;
														flag_percentage_max = get_Atlas_curve(x_start_curve,  y_start_curve,  g_x_c,  g_y_c,  4243,  1650.0,  30.0,  g_degree,  auto_chapter_seesaw);
													
														
														//motor_output_turn = get_motor_output_turn(-90.0,  g_degree);
													}
													
													if((auto_chapter_seesaw == 4 )|| (auto_chapter_seesaw == 5)){
														if(fabs(get_gap_degree(-90 , g_degree)) <= 3.0){
															flag[1] = ON;
														}
														if(flag[1] == ON){
															motor_output_turn = get_motor_output_turn(-90,  g_degree);
														}else{
															target_omega = get_target_omega(2,  100,  100,  start_degree,  g_degree,  -90,  150);
															motor_output_turn = (target_omega - g_omega) * KP_OMEGA;
														}
													}
												
													if(flag_percentage_max == ON){
														auto_chapter_seesaw ++;
													}
												
														
													result_motor_output_l = motor_output_velocity.l + motor_output_distance.l +  motor_output_turn;
													result_motor_output_r = motor_output_velocity.r + motor_output_distance.r +  motor_output_turn;
													result_motor_output_b = motor_output_velocity.b + motor_output_distance.b +  motor_output_turn;
													target_degree = g_degree;
													
												}else if(auto_chapter_seesaw == 6){
												
													calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  4243.0,  1650,  g_degree,  -90.0,  step);
												
													result_motor_output_l =  motor_output_position_lock.l;
													result_motor_output_r = motor_output_position_lock.r;
													result_motor_output_b = motor_output_position_lock.b;
													target_degree = g_degree;
												}
										}*/
										
									
								break;
								
								//子供ロボット回収
								/*case 12:
									//Move_all_arm(450.0 + adjustment_sum[1],  90.0 + adjustment_sum[3],  10.0 + adjustment_sum[2],  0.0);
									Move_all_arm_2(450.0 + adjustment_sum[1],  TARGET_TOP_ARM_DEGREE_2 + adjustment_sum[3],  10.0 + adjustment_sum[2],  0.0,  step);
									Move_top_arm_lift_velocity(TARGET_TOP_ARM_LIFT_1 + adjustment_sum[0] + 20.0, step);
									Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								break;*/
							}
						break;
						/*****************************************************************************************************/
						
						
						
						
						
						/*******************************ブランコ***************************************************************/
						case TASK_SWING:
							switch(step){
								case 13://ブランコ上に侵入
									//Move_all_arm(610.0 + adjustment_sum[1],  0.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
									Move_all_arm_2(OPERATE_ARM_13_1 + adjustment_sum[1],  OPERATE_ARM_13_2 + adjustment_sum[3],  OPERATE_ARM_13_3 + adjustment_sum[2],  OPERATE_ARM_13_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_13_5 + adjustment_sum[0]  ,step);
									Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								break;
								case 14://子供ロボット置く
								case 20://子供ロボットつかむ
									if(step == 14){
										Move_top_arm_lift_velocity(OPERATE_ARM_14_5 + adjustment_sum[0]  ,step);
									}else{
										Move_top_arm_lift_velocity(OPERATE_ARM_14_5 + adjustment_sum[0] /*+ 30*/ ,step);
									}
									Move_all_arm_2(OPERATE_ARM_14_1 + adjustment_sum[1],  OPERATE_ARM_14_2 + adjustment_sum[3],  OPERATE_ARM_14_3 + adjustment_sum[2],  OPERATE_ARM_14_4,  step);
									
									Air_all_on_off(OFF,  OFF,  OFF,  OFF);
									
								break;
								case 15://子供ロボット離す
								case 19://子供ロボット回収高さ調整
									Move_top_arm_lift_velocity(OPERATE_ARM_15_5 + adjustment_sum[0]  ,step);
									//Move_all_arm(610.0 + adjustment_sum[1],  0.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
									Move_all_arm_2(OPERATE_ARM_15_1_0 + adjustment_sum[1],  OPERATE_ARM_15_2 + adjustment_sum[3],  OPERATE_ARM_15_3 + adjustment_sum[2],  OPERATE_ARM_15_4,  step);
									if(g_top_arm_length >= 320.0){
										Air_all_on_off(ON,  OFF,  OFF,  OFF);	
									}else{
										if(AR_TOP_ARM_LOCK == OFF){
											Air_all_on_off(OFF,  OFF,  OFF,  OFF);
										}else{
											Air_all_on_off(ON,  OFF,  OFF,  OFF);
										}
									}
									/*if(step == 15){	
										Move_all_arm_2(OPERATE_ARM_15_1_0 + adjustment_sum[1],  OPERATE_ARM_15_2 + adjustment_sum[3],  OPERATE_ARM_15_3 + adjustment_sum[2],  OPERATE_ARM_15_4,  step);
										if(g_top_arm_length >= 320.0){
											Air_all_on_off(ON,  OFF,  OFF,  OFF);	
										}else{
											if(AR_TOP_ARM_LOCK == OFF){
												Air_all_on_off(OFF,  OFF,  OFF,  OFF);
											}else{
												Air_all_on_off(ON,  OFF,  OFF,  OFF);
											}
										}
									}else{
										
										Move_all_arm_2(OPERATE_ARM_15_1_1 + adjustment_sum[1],  OPERATE_ARM_15_2 + adjustment_sum[3],  OPERATE_ARM_15_3 + adjustment_sum[2],  OPERATE_ARM_15_4,  step);
										if(g_top_arm_length >= 150.0){
											Air_all_on_off(ON,  OFF,  OFF,  OFF);	
										}else{
											if(AR_TOP_ARM_LOCK == OFF){
												Air_all_on_off(OFF,  OFF,  OFF,  OFF);
											}else{
												Air_all_on_off(ON,  OFF,  OFF,  OFF);
											}
										}
									}*/
								break;
								case 16://ブランコ引く高さ調整
									if(g_top_arm_length >= 320){
										//Move_all_arm(120.0 + adjustment_sum[1],  0.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
										Move_all_arm_2(OPERATE_ARM_16_1 + adjustment_sum[1],  OPERATE_ARM_16_2 + adjustment_sum[3],  OPERATE_ARM_16_3 + adjustment_sum[2],  OPERATE_ARM_16_4_0,  step);
										Move_top_arm_lift_velocity(OPERATE_ARM_16_5_0 + adjustment_sum[0]  ,step);
										Air_all_on_off(ON,  OFF,  OFF,  OFF);
									}else{
										//Move_all_arm(120.0 + adjustment_sum[1],  0.0,  0.0 + adjustment_sum[2],  420.0);
										
										//高さが10mm以内に収まった時のフラグ立て
										if(fabs(g_z_c_swing_arm - OPERATE_ARM_16_5_1) <= 10){
											flag_swing_arm_length = ON;
										}
											
										if(flag_swing_arm_length == ON){
											target_swing_arm_length = OPERATE_ARM_16_4_1;
										}else{
											target_swing_arm_length = (OPERATE_ARM_16_4_1 - OPERATE_ARM_16_4_0) * (((OPERATE_ARM_16_5_0 - (INIT_TOP_ARM_HIGH - INIT_SWING_ARM_HIGH) - g_z_c_swing_arm ) / (OPERATE_ARM_16_5_0 - (INIT_TOP_ARM_HIGH - INIT_SWING_ARM_HIGH) - OPERATE_ARM_16_5_1)));
										}
										
										Move_all_arm_2(OPERATE_ARM_16_1 + adjustment_sum[1],  OPERATE_ARM_16_2,  OPERATE_ARM_16_3 + adjustment_sum[2],  target_swing_arm_length,  step);
										Move_swing_arm_lift(OPERATE_ARM_16_5_1+ adjustment_sum[0]);
										Air_all_on_off(OFF,  OFF,  OFF,  OFF);
									}
								break;
							
								case 17://ブランコ引く
								//足回り自動化
								if(getdate2.byte.r2_sw == 0){
										switch(auto_chapter_swing){
										case 0:
											g_x_c = TARGET_SWING_X_0;
											g_y_c = TARGET_SWING_Y_0;
											g_degree = TARGET_SWING_DEGREE;
											information_reset(g_x_c,g_y_c,g_degree);
											target_degree = g_degree;
											auto_chapter_swing ++;
											
											flag[3] ++;
											result_motor_output_l = 0.0;//BRAKE;
											result_motor_output_r = 0.0;//BRAKE;
											result_motor_output_b = 0.0;//BRAKE;
										break;
										case 1:
											calculate_motor_output_lrb_velocity(g_x_start,  g_y_start,    g_x_c,  g_y_c,  TARGET_SWING_X_1,  TARGET_SWING_Y_1,  g_degree,  A_UP_SWING,  A_DOWN_SWING,  MAX_VELOCITY_SWING, flag[3] + 4);
											calculate_motor_output_lrb_horizontal(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_SWING_X_1,  TARGET_SWING_Y_1,  g_degree,  flag[3] + 4);
											motor_output_turn = get_motor_output_turn(TARGET_SWING_DEGREE,  g_degree);
											result_motor_output_l = motor_output_velocity.l + motor_output_horizontal.l + motor_output_turn;
											result_motor_output_r = motor_output_velocity.r + motor_output_horizontal.r +  motor_output_turn;
											result_motor_output_b = motor_output_velocity.b + motor_output_horizontal.b + motor_output_turn;
										
											if(get_vertical_distance_func(TARGET_SWING_X_1,  TARGET_SWING_Y_1,  g_x_c,  g_y_c, get_target_degree(TARGET_SWING_X_1,  TARGET_SWING_Y_1,  g_x_start, g_y_start)) <= 10.0){
												auto_chapter_swing ++;
											}
										break;
										case 2:
											//calculate_motor_output_lrb_distance(TARGET_SWING_X_1,  TARGET_SWING_Y_1,  g_x_c,  g_y_c,  g_degree, flag[3] + 4);
											calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  TARGET_SWING_X_1,  TARGET_SWING_Y_1,  g_degree, TARGET_SWING_DEGREE,  step);
											//motor_output_turn = get_motor_output_turn(TARGET_SWING_DEGREE,  g_degree);
											result_motor_output_l = motor_output_position_lock.l;
											result_motor_output_r = motor_output_position_lock.r;
											result_motor_output_b = motor_output_position_lock.b;
										break;
										}
									}
									
									if(g_z_c_swing_arm >= (OPERATE_ARM_17_5_0 + 20 + adjustment_sum[0])){
										//Move_all_arm(120.0 + adjustment_sum[1],  0.0 ,  0.0 + adjustment_sum[2],  230.0 - 45);
										Move_all_arm_2(OPERATE_ARM_17_1 + adjustment_sum[1],  OPERATE_ARM_17_2 ,  OPERATE_ARM_17_3 + adjustment_sum[2],  OPERATE_ARM_17_4_1 + adjustment_sum[4],  step);
									}else{
										//Move_all_arm(120.0 + adjustment_sum[1],  0.0 ,  0.0 + adjustment_sum[2],  420.0);
										Move_all_arm_2(OPERATE_ARM_17_1 + adjustment_sum[1],  OPERATE_ARM_17_2 ,  OPERATE_ARM_17_3 + adjustment_sum[2],  OPERATE_ARM_17_4_0,  step);
									}
									//Move_all_arm(150.0 + adjustment_sum[1],  0.0,  0.0 + adjustment_sum[2],  420.0);
									
									if(auto_chapter_swing == 0){
										target_swing_arm_z = OPERATE_ARM_17_5_0;
									}else if((auto_chapter_swing == 1) || (auto_chapter_swing == 2)){
										if(g_z_c_swing_arm >= (OPERATE_ARM_17_5_0 + 20 + adjustment_sum[0])){
											target_swing_arm_z =  (OPERATE_ARM_17_5_1 - OPERATE_ARM_17_5_0) * ((OPERATE_ARM_17_4_0 - g_seesaw_arm_length) / (OPERATE_ARM_17_4_0 - OPERATE_ARM_17_4_1)) + OPERATE_ARM_17_5_0;
											BUZZER = ON;
										}else{
											target_swing_arm_z =  (OPERATE_ARM_17_5_1 - OPERATE_ARM_17_5_0) * (1.0 - (get_distance(TARGET_SWING_X_1,TARGET_SWING_Y_1,g_x_c,g_y_c) / get_distance(TARGET_SWING_X_1,TARGET_SWING_Y_1,g_x_start,g_y_start))) + OPERATE_ARM_17_5_0;
											BUZZER = OFF;
										}
										//target_swing_arm_z =  (TARGET_SWING_ARM_LIFT_2- TARGET_SWING_ARM_LIFT_1) * (1.0 - (get_distance(TARGET_SWING_X_1,TARGET_SWING_Y_1,g_x_c,g_y_c) / get_distance(TARGET_SWING_X_1,TARGET_SWING_Y_1,g_x_start,g_y_start))) + TARGET_SWING_ARM_LIFT_1;
										target_swing_arm_z = Limit_ul(940.0,  OPERATE_ARM_17_5_0,  target_swing_arm_z);
									}
									
									Move_swing_arm_lift(target_swing_arm_z + adjustment_sum[0]);
									
									Air_all_on_off(OFF,  OFF,  ON,  OFF);
								break;
								
								//ブランコを放す
								case 18:
									//flag[0] = ON;
									//Move_all_arm(120.0 + adjustment_sum[1],  0.0,  0.0 + adjustment_sum[2],  230.0 - 45);
									Move_all_arm_2(OPERATE_ARM_18_1 + adjustment_sum[1],  OPERATE_ARM_18_2,  OPERATE_ARM_18_3 + adjustment_sum[2],  OPERATE_ARM_18_4 + adjustment_sum[4],  step);
									Move_swing_arm_lift(target_swing_arm_z + adjustment_sum[0]);
									Air_all_on_off(OFF,  OFF,  OFF,  ON);
								break;
							}
						break;
						/***********************************************************************************************************/
						
						
						
						
						
						/*************************ポールウォーク**********************************************************************/
						case TASK_POLE:
							switch(step){
								case 22://ディスクに挟む高さ侵入
								//case 21:
								Move_all_arm_2(OPERATE_ARM_22_1 + adjustment_sum[1],  OPERATE_ARM_22_2 + adjustment_sum[3],  OPERATE_ARM_22_3 + adjustment_sum[2],  OPERATE_ARM_22_4,  step);
								Move_top_arm_lift_velocity(OPERATE_ARM_22_5 + adjustment_sum[0] ,   step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								break;
								//case 23://ディスクに挟む高さ完了
								case 23://置く
								case 24://角度調整
								case 25://掴む
								/*case 22:
								case 23:
								case 24:*/
								/*if(step == 23){
									//Move_all_arm(580.0 + adjustment_sum[1],  90.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
									Move_all_arm_2(OPERATE_ARM_23_1_0 + adjustment_sum[1],  OPERATE_ARM_23_2_0 + adjustment_sum[3],  OPERATE_ARM_23_3 + adjustment_sum[2],  OPERATE_ARM_23_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_23_5_0 + adjustment_sum[0],   step);
								}*/
								if(step == 23){
								//if(step == 22){	
									Move_all_arm_2(OPERATE_ARM_23_1_0 + adjustment_sum[1],  OPERATE_ARM_23_2_0 + adjustment_sum[3],  OPERATE_ARM_23_3 + adjustment_sum[2],  OPERATE_ARM_23_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_23_5_1 + adjustment_sum[0],   step);
								}else{
									//Move_all_arm(580.0 + adjustment_sum[1],  60.0 + adjustment_sum[3],  0.0 + adjustment_sum[2],  0.0);
									Move_all_arm_2(OPERATE_ARM_23_1_1 + adjustment_sum[1],  OPERATE_ARM_23_2_1 + adjustment_sum[3],  OPERATE_ARM_23_3 + adjustment_sum[2],  OPERATE_ARM_23_4,  step);
									Move_top_arm_lift_velocity(OPERATE_ARM_23_5_2 + adjustment_sum[0],   step);
								}
								
								if((step == 23) || (step == 24)){
								//if((step == 22) || (step == 23)){
									Air_all_on_off(ON,  OFF,  OFF,  OFF);
								}else{
									Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								}
								break;
							}
						break;
						/*******************************************************************************************************/
						
						
						
						
						
						/*************************ジャングルジム******************************************************************/
						case TASK_JUNGLE_GYM:
							switch(step){
								/*case 28://子供ロボット70度傾ける
								target_top_arm_z = OPERATE_ARM_28_5_0 + (g_top_arm_tilt_degree / OPERATE_ARM_28_3) * (OPERATE_ARM_28_5_1 - OPERATE_ARM_28_5_0);
								target_top_arm_z = Limit_ul(OPERATE_ARM_28_5_0, OPERATE_ARM_28_5_1, target_top_arm_z);
								target_top_arm_length = OPERATE_ARM_28_1_0 +  (g_top_arm_tilt_degree / OPERATE_ARM_28_3) * (OPERATE_ARM_28_1_1 - OPERATE_ARM_28_1_0);
								target_top_arm_length = Limit_ul(OPERATE_ARM_28_1_0,  OPERATE_ARM_28_1_1,  target_top_arm_length);
								//Move_all_arm(target_top_arm_length + adjustment_sum[1],  0.0 + adjustment_sum[3],  90.0 + adjustment_sum[2],  0.0);
								Move_all_arm_2(target_top_arm_length + adjustment_sum[1],  OPERATE_ARM_28_2 + adjustment_sum[3],  OPERATE_ARM_28_3 + adjustment_sum[2],  OPERATE_ARM_28_4,  step);
								Move_top_arm_lift_velocity(target_top_arm_z + adjustment_sum[0],   step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								break;*/
								/*case 28://爪の高さ合わせる
								//Move_all_arm(150.0 + adjustment_sum[1],  0.0 + adjustment_sum[3] ,  90.0 + adjustment_sum[2],  0.0);
								Move_all_arm_2(OPERATE_ARM_28_1 + adjustment_sum[1],  OPERATE_ARM_28_2 + adjustment_sum[3] ,  OPERATE_ARM_28_3 + adjustment_sum[2],  OPERATE_ARM_28_4,  step);
								Move_top_arm_lift_velocity(OPERATE_ARM_28_5 + adjustment_sum[0] ,   step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								break;*/
								case 27://子供ロボット置く
								//case 26:
								//Move_all_arm(150.0 + adjustment_sum[1],  0.0 + adjustment_sum[3] ,  73.0 + adjustment_sum[2],  0.0);
								Move_all_arm_2(OPERATE_ARM_27_1 + adjustment_sum[1],  OPERATE_ARM_27_2 + adjustment_sum[3] ,  OPERATE_ARM_27_3 + adjustment_sum[2],  OPERATE_ARM_27_4,  step);
								Move_top_arm_lift_velocity(OPERATE_ARM_27_5 + adjustment_sum[0] ,   step);
								Air_all_on_off(ON,  OFF,  OFF,  OFF);
								break;
								case 28://ピッチを回す
								Move_all_arm_2(OPERATE_ARM_28_1 + adjustment_sum[1],  OPERATE_ARM_28_2 + adjustment_sum[3] ,  OPERATE_ARM_28_3 + adjustment_sum[2],  OPERATE_ARM_28_4,  step);
								Move_top_arm_lift_velocity(Limit_ul(800,	OPERATE_ARM_28_5,	OPERATE_ARM_28_5 + adjustment_sum[0]) ,   step);
								Air_all_on_off(ON,  OFF,  OFF,  OFF);
								break;
								/*case 32:
								Move_all_arm_2(150.0 + adjustment_sum[1],  -90.0 + adjustment_sum[3],  73.0 + adjustment_sum[2],  0.0,  step);
								Move_top_arm_lift_velocity(501.2+ adjustment_sum[0] , step);
								Air_all_on_off(ON,  OFF,  OFF,  OFF);
								break;*/
							}
						break;
						/*******************************************************************************************************************/
						
						
						/******************リトライ時、アーム初期化*****************************************************************************/
						case RETRY://リトライ時(子供ロボット保持なし)
							//Move_all_arm_2(INIT_TOP_ARM_LENGTH,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
							
							//Air_all_on_off(OFF,  OFF,  OFF,  OFF);
							
							/*if(flag_retry == ON){
								if((step_old >= 0) && (step_old <= 2)){
									flag_retry_task = STANDBY;
								}else if((step_old >= 3) && (step_old <= 11)){
									flag_retry_task = TASK_SEESAW;
								}else if((step_old >= 12) && (step_old <= 20)){
									flag_retry_task = TASK_SWING;
								}else if((step_old >= 21) && (step_old <= 26)){
									flag_retry_task = TASK_POLE;
								}else if(step_old >= 27){
									flag_retry_task = TASK_JUNGLE_GYM;
								}
							}else{
								Move_top_arm_lift_velocity(OPERATE_ARM_0_5_0 ,step);
							}*/
							
							if(flag_retry_task == STANDBY){
								Move_all_arm_2(INIT_TOP_ARM_LENGTH,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
								Move_top_arm_lift_velocity(OPERATE_ARM_0_5_0 ,step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
							}else if(flag_retry_task == TASK_SEESAW){
								Move_top_arm_lift_velocity(OPERATE_ARM_0_5_1 ,step);
								
								if(g_seesaw_arm_length >= 300){
									Motor_top_arm(BRAKE);
									Motor_top_arm_turn(BRAKE);
									Move_top_arm_tilt(INIT_TOP_ARM_TILT_DEGREE);
									Move_seesaw_arm_length(INIT_SEESAW_ARM_LENGTH);
									Air_all_on_off(ON,  OFF,  OFF,  OFF);
								}else{
									Move_all_arm_2(INIT_TOP_ARM_LENGTH,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
									Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								}
								
							}else if(flag_retry_task == TASK_SWING){
								Move_all_arm_2(INIT_TOP_ARM_LENGTH,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								Move_top_arm_lift_velocity(OPERATE_ARM_0_5_2 ,step);
							}else if(flag_retry_task == TASK_POLE){
								Move_all_arm_2(INIT_TOP_ARM_LENGTH,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								Move_top_arm_lift_velocity(OPERATE_ARM_0_5_3 ,step);
							}else if(flag_retry_task == TASK_JUNGLE_GYM){
								
								Move_all_arm_2(OPERATE_ARM_1_1,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
								Air_all_on_off(OFF,  OFF,  OFF,  OFF);
								Move_top_arm_lift_velocity(OPERATE_ARM_0_5_4 ,step);
							}
							
						break;
						/*******************************************************************************************************************/
						
						default:
						break;
					}
				}
				
				
				//手動モード
				if(TOGGLE_MANUAL_MODE == ON){
					
					//リフトアーム
					if((getdate2.byte.cross_sw == 0) && (getdate2.byte.l1_sw == 0)){//アーム上移動
						motor_output_lift = MANUAL_LIFT_ARM_UP;//60.0;
						target_lock_lift = g_z_c_seesaw_arm;
						count_auto_lift = 0;
						Motor_lift_arm(motor_output_lift);
					}else	if((getdate2.byte.cross_sw == 0) && (getdate2.byte.l2_sw == 0)){//アーム下移動
						motor_output_lift = (-1) * MANUAL_LIFT_ARM_DOWN;//-60.0;
						target_lock_lift = g_z_c_seesaw_arm;
						count_auto_lift = 0;
						Motor_lift_arm(motor_output_lift);
					}else{//落ちないようにする
						if(count_auto_lift == 1){
							//Move_seesaw_arm_lift(TARGET_SEESAW_ARM_LIFT_3);
							Move_seesaw_arm_lift_velocity(TARGET_SEESAW_ARM_LIFT_3,  count_auto_lift);
						}else if(count_auto_lift == 2){
							Move_seesaw_arm_lift_velocity(TARGET_SEESAW_ARM_LIFT_1,  count_auto_lift);
							//Move_seesaw_arm_lift(TARGET_SEESAW_ARM_LIFT_1);
						}else{
							count_auto_lift = 0;	
							gap_lift_arm_now = target_lock_lift - g_z_c_seesaw_arm;
							motor_output_lift = gap_lift_arm_now * KP_LIFT_ARM_LOCK + ((gap_lift_arm_now - gap_lift_arm_old) * KD_LIFT_ARM_LOCK);
							gap_lift_arm_old = gap_lift_arm_now;
							Motor_lift_arm(motor_output_lift);
						}
					}
					//シーソーアーム
					if((getdate2.byte.circle_sw == 0) && (getdate1.byte.left_sw == 0)){
						motor_output_seesaw = MANUAL_SEESAW_ARM_PUSH;//30.0;//シーソー・ブランコアーム反時計回転
					}else if((getdate2.byte.circle_sw == 0) && (getdate1.byte.right_sw == 0)){
						motor_output_seesaw = (-1) * MANUAL_SEESAW_ARM_PULL;//シーソー・ブランコアーム時計回転
					}else{
						motor_output_seesaw = BRAKE;
					}
					//上アーム前後
					if((getdate2.byte.triangle_sw == 0) && (getdate2.byte.l1_sw == 0)){//上アーム前移動
						motor_output_top = MANUAL_TOP_ARM_FRONT;
						target_lock_top_arm_length = g_top_arm_length;
					}else	if((getdate2.byte.triangle_sw == 0) && (getdate2.byte.l2_sw == 0)){//上アーム後移動
						motor_output_top = (-1) * MANUAL_TOP_ARM_BACK;
						target_lock_top_arm_length = g_top_arm_length;
					}else{
						motor_output_top = BRAKE;
						/*gap_top_arm_now = target_lock_top_arm_length - g_top_arm_length;
						motor_output_top = (gap_top_arm_now * KP_TOP_ARM_LENGTH_LOCK) + (KD_TOP_ARM_LENGTH_LOCK * (gap_top_arm_now - gap_top_arm_old));
						gap_top_arm_old = gap_top_arm_now;*/
					}
					//上アーム回転
					if((getdate2.byte.triangle_sw == 0) && (getdate1.byte.left_sw == 0)){//上アーム時計回転
						motor_output_top_turn = MANUAL_TOP_ARM_CW;
						target_lock_top_arm_degree = g_top_arm_degree;
					}else	if((getdate2.byte.triangle_sw == 0) && (getdate1.byte.right_sw == 0)){//上アーム反時計回転
						motor_output_top_turn = (-1) * MANUAL_TOP_ARM_CCW;
						target_lock_top_arm_degree = g_top_arm_degree;
					}else{
						//motor_output_top_turn = BRAKE;
						gap_top_arm_turn_now = target_lock_top_arm_degree - g_top_arm_degree;
						motor_output_top_turn = (gap_top_arm_turn_now * 0.1) + (3.0 * (gap_top_arm_turn_now - gap_top_arm_turn_old));
						gap_top_arm_turn_old = gap_top_arm_turn_now;
						if(fabs(target_lock_top_arm_degree - g_top_arm_degree) <= 5.0){
							motor_output_top_turn = BRAKE;
						}
					}
				
					//シーソーエアー
					if((getdate2.byte.circle_sw == 0) && (getdate2.byte.r2_sw == 0)){//シーソー押す
						if(flag_circle_r2 == OFF){
							flag_circle_r2 = ON;
							AR_SEESAW_PUSH =~ AR_SEESAW_PUSH;
							count_auto_lift ++;
							if(count_auto_lift == 3){
								count_auto_lift = 1;
								}
							}
					}else{
						flag_circle_r2 = OFF;
					}
					//ブランコエアー
					if((getdate2.byte.circle_sw == 0) && (getdate2.byte.l2_sw == 0)){
						if(flag_circle_l2 == OFF){
							flag_circle_l2  = ON;
							AR_SWING_CATCH =~ AR_SWING_CATCH;
						}
					}else{
						flag_circle_l2 = OFF;
					}		
					//上アーム自動機掴む
					if((getdate2.byte.triangle_sw == 0) && (getdate2.byte.r1_sw == 0)){
						if(flag_triangle_l1== OFF){
							flag_triangle_l1 = ON;
								AR_TOP_CATCH =~ AR_TOP_CATCH;
							}
					}else{
						flag_triangle_l1 = OFF;
					}
					
					//モータ駆動
					Motor_seesaw_arm(motor_output_seesaw);
					Motor_top_arm(motor_output_top);
					Motor_top_arm_turn(motor_output_top_turn);
					
				}
				
				//足回り手動操縦
				if((getdate2.byte.r2_sw == 1) || (TOGGLE_MANUAL_MODE == ON)){	
					
					//スティックによるｘ、ｙ方向の出力決め
					//x方向
					if( getdate3.byte.left_stick_high >=  0xBF){
						Motor_output_x = ( -1 ) * fabs( ( (float)getdate3.byte.left_stick_high - ( nutral_x + STICK_NO_MOVE_RANGE ) ) * ( pwm_percent / ( nutral_x - STICK_NO_MOVE_RANGE + 1) ));
					}else if( getdate3.byte.left_stick_high <=  0x3F){
						Motor_output_x = (( nutral_x - STICK_NO_MOVE_RANGE ) - (float)getdate3.byte.left_stick_high ) * ( pwm_percent / ( nutral_x - STICK_NO_MOVE_RANGE ) );	
					}else{
						Motor_output_x = 0.0;
					}
					//y方向
					if( getdate2.byte.left_stick_wide >= 0xBF ){
						Motor_output_y = ( -1 ) * fabs( ( (float)getdate2.byte.left_stick_wide - ( nutral_y + STICK_NO_MOVE_RANGE ) ) * ( pwm_percent / ( nutral_y - STICK_NO_MOVE_RANGE + 1) ) );
					}else if( getdate2.byte.left_stick_wide <= 0x3F ){
						Motor_output_y = ( ( nutral_y - STICK_NO_MOVE_RANGE ) - (float)getdate2.byte.left_stick_wide ) * ( pwm_percent / ( nutral_y - STICK_NO_MOVE_RANGE ) );	
					}else{
						Motor_output_y = 0.0;
					}
					
					
					if( ( Motor_output_x == 0 ) && ( Motor_output_y == 0 )){//左スティック操作していないとき
						/*result_motor_output_l = BRAKE;
						result_motor_output_r = BRAKE;
						result_motor_output_b = BRAKE;*/
						
						if(position_lock_count == position_lock_count_old){
							position_lock_count ++;
						}
						
						#if COLOR == RED
						
							//ブランコから回収時のポジションロック
							if(((step == 19) || (step == 20) || ((step == 21)  && (g_y_c >= 500)) || (((step == 25) || (step == 26)) && ( (g_y_c >= -750) && (g_y_c <= 750))) ) && ((getdate2.byte.l2_sw == 0) && (getdate2.byte.cross_sw == 1))){
							//if(((step == 19) || ((step == 20) && (g_y_c <= -500)) || (((step == 25) || (step == 26)) && ( (g_y_c >= -750) && (g_y_c <= 750))) ) && ((getdate2.byte.l2_sw == 0) && (getdate2.byte.cross_sw == 1)) ){
								switch(swing_lock_chapter){
									case 0:
										g_x_start = g_x_c;
										g_y_start = g_y_c;
										//target_degree = g_degree;
										swing_lock_chapter ++;
										flag[6] ++;
									break;
									case 1:
										//calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  g_x_start,  g_y_start,  g_degree,  target_degree,  flag[6] + 500);
										calculate_motor_output_lrb_horizontal(g_x_start,  g_y_start,  g_x_c,  g_y_c,  g_x_start,  g_y_start,  g_degree,  flag[6] + 100);
										calculate_motor_output_lrb_vertical(g_x_start,  g_y_start,  g_x_c,  g_y_c,  g_x_start,  g_y_start,  g_degree,  flag[6] + 100);
										manual_motor_output_l = motor_output_horizontal.l + motor_output_vertical.l;
										manual_motor_output_r = motor_output_horizontal.r + motor_output_vertical.r;
										manual_motor_output_b = motor_output_horizontal.b + motor_output_vertical.b;
									break;
									default:
									break;
									}
								//calculate_motor_output_lrb_horizontal(position_x_old ,  position_y_old,  g_x_c,  g_y_c,  position_x_old,  position_y_old,  g_degree,  position_lock_count + 100);
								//calculate_motor_output_lrb_vertical(position_x_old ,  position_y_old,  g_x_c,  g_y_c,  position_x_old,  position_y_old,  g_degree,  position_lock_count + 100);
								//manual_motor_output_l = motor_output_horizontal.l + motor_output_vertical.l;
								//manual_motor_output_r = motor_output_horizontal.r + motor_output_vertical.r;
								//manual_motor_output_b = motor_output_horizontal.b + motor_output_vertical.b;
							}else{
								calculate_motor_output_lrb_distance(position_x_old,  position_y_old,  g_x_c,  g_y_c,  g_degree,  position_lock_count + 10);
								manual_motor_output_l = g_motor_output_l;
								manual_motor_output_r = g_motor_output_r;
								manual_motor_output_b = g_motor_output_b;
								swing_lock_chapter = 0;
							}
						
						#elif COLOR == BLUE
						
							if(((step == 19) || (step == 20) || ((step == 21) && (g_y_c <= -500)) || (((step == 25) || (step == 26)) && ( (g_y_c >= -750) && (g_y_c <= 750))) ) && ((getdate2.byte.l2_sw == 0) && (getdate2.byte.cross_sw == 1)) ){
								//if(((step == 19) || ((step == 20) && (g_y_c <= -500)) || (((step == 25) || (step == 26)) && ( (g_y_c >= -750) && (g_y_c <= 750))) ) && ((getdate2.byte.l2_sw == 0) && (getdate2.byte.cross_sw == 1)) ){
								switch(swing_lock_chapter){
									case 0:
										g_x_start = g_x_c;
										g_y_start = g_y_c;
										//target_degree = g_degree;
										swing_lock_chapter ++;
										flag[6] ++;
									break;
									case 1:
										//calculate_motor_output_lrb_position_lock(g_x_start,  g_y_start,  g_x_c,  g_y_c,  g_x_start,  g_y_start,  g_degree,  target_degree,  flag[6] + 500);
										calculate_motor_output_lrb_horizontal(g_x_start,  g_y_start,  g_x_c,  g_y_c,  g_x_start,  g_y_start,  g_degree,  flag[6] + 100);
										calculate_motor_output_lrb_vertical(g_x_start,  g_y_start,  g_x_c,  g_y_c,  g_x_start,  g_y_start,  g_degree,  flag[6] + 100);
										manual_motor_output_l = motor_output_horizontal.l + motor_output_vertical.l;
										manual_motor_output_r = motor_output_horizontal.r + motor_output_vertical.r;
										manual_motor_output_b = motor_output_horizontal.b + motor_output_vertical.b;
									break;
									default:
									break;
									}
								
								//calculate_motor_output_lrb_horizontal(position_x_old ,  position_y_old,  g_x_c,  g_y_c,  position_x_old,  position_y_old,  g_degree,  position_lock_count + 100);
								//calculate_motor_output_lrb_vertical(position_x_old ,  position_y_old,  g_x_c,  g_y_c,  position_x_old,  position_y_old,  g_degree,  position_lock_count + 100);
								//manual_motor_output_l = motor_output_horizontal.l + motor_output_vertical.l;
								//manual_motor_output_r = motor_output_horizontal.r + motor_output_vertical.r;
								//manual_motor_output_b = motor_output_horizontal.b + motor_output_vertical.b;
							}else{
								calculate_motor_output_lrb_distance(position_x_old,  position_y_old,  g_x_c,  g_y_c,  g_degree,  position_lock_count + 10);
								manual_motor_output_l = g_motor_output_l;
								manual_motor_output_r = g_motor_output_r;
								manual_motor_output_b = g_motor_output_b;
								swing_lock_chapter = 0;
							}
						#endif
						
						
						/*calculate_motor_output_lrb_distance(position_x_old,  position_y_old,  g_x_c,  g_y_c,  g_degree,  position_lock_count + 10);
						manual_motor_output_l = g_motor_output_l;
						manual_motor_output_r = g_motor_output_r;
						manual_motor_output_b = g_motor_output_b;
						*/
						
					}else{
						position_x_old = g_x_c;
						position_y_old = g_y_c;
						position_lock_count_old = position_lock_count;
						
						manual_motor_output_l = get_motor_output_l( Motor_output_x, Motor_output_y, 0.0 );
						manual_motor_output_r = get_motor_output_r( Motor_output_x, Motor_output_y, 0.0 );
						manual_motor_output_b = get_motor_output_b( Motor_output_x, Motor_output_y, 0.0 );
					}
							
					//車体角度操作
					
					if((getdate2.byte.right_stick_wide  > 0x3F) && (getdate2.byte.right_stick_wide < 0xBF)){//角度操作していないとき
						#if COLOR == RED
						if( (step == 11) && (step_old == 10) && ((g_y_c >= 1400) && (g_y_c <= 2000)) ){
							target_degree = -90.0;
						}
						#elif COLOR == BLUE
						if( (step == 11) && (step_old == 10) && ((g_y_c <= -1400) && (g_y_c >= -2000)) ){
							target_degree = 90.0;
						}
						#endif
						motor_output_turn = get_motor_output_turn(target_degree,g_degree);
					}else{
						target_degree = g_degree;
						
						if(getdate2.byte.right_stick_wide >= 0xBF ){
							motor_output_turn = (-1) * ( (float)getdate2.byte.right_stick_wide - ( nutral_y + STICK_NO_MOVE_RANGE ) ) * ( (pwm_percent_turn) / ( nutral_y - STICK_NO_MOVE_RANGE + 1) );
						}else if(getdate2.byte.right_stick_wide <= 0x3F ){
							motor_output_turn = ( ( nutral_y - STICK_NO_MOVE_RANGE ) - (float)getdate2.byte.right_stick_wide ) * ( (pwm_percent_turn) / ( nutral_y - STICK_NO_MOVE_RANGE ) );	
						}
					}
					#if ENCODER_CALIBRATION_MODE == OFF
							result_motor_output_l = manual_motor_output_l + motor_output_turn;
							result_motor_output_r = manual_motor_output_r + motor_output_turn;
							result_motor_output_b =manual_motor_output_b + motor_output_turn;
					#else
							result_motor_output_l = motor_output_turn;
							result_motor_output_r = motor_output_turn;
							result_motor_output_b = motor_output_turn;
					#endif
					
					
									
					/*if((fabs(Motor_output_x - stick_x_old) >= 80) || (fabs(Motor_output_y - stick_y_old) >= 80)){
						BUZZER = ON;
					}else{
						BUZZER = OFF;
					}*/
					
					stick_x_old = Motor_output_x;
					stick_y_old = Motor_output_y;
					//BUZZER = OFF;
				}else{//自動走行時
					//BUZZER = ON;
					//常にポジションロック更新
					position_x_old = g_x_c;
					position_y_old = g_y_c;
					position_lock_count_old = position_lock_count;
					target_degree = g_degree;
				}
				
				if( (getdate1.byte.model_number == 0x41) || (LIMIT_SW_LIFT_ARM_HIGH == ON) || (LIMIT_SW_LIFT_ARM_LOW == ON)){//デジタルモードのとき
					
					if(getdate1.byte.model_number == 0x41){
						Buzzer_period(50,	0);
					}else if( (LIMIT_SW_LIFT_ARM_HIGH == ON) || (LIMIT_SW_LIFT_ARM_LOW == ON)){
						Buzzer_period(100,	  1);
					}
					
					/*timer ++;
					
					if((timer >= 0) && (timer < 50)){
						g_buzzer_io = ON;
						#if COLOR == RED
						LED_BLUE = ON;
						#elif	COLOR == BLUE
						LED_RED = ON;
						#endif
					}else if((timer >= 50) && (timer < 100)){
						g_buzzer_io =  OFF;
						#if COLOR == RED
						LED_BLUE = OFF;
						#elif	COLOR == BLUE
						LED_RED = OFF;
						#endif
					}else{
						timer = 0;
					}*/
					
				
				}else{
					
					Buzzer_period(0,	  0);
					Buzzer_period(0,	  1);
					#if COLOR == RED
						LED_BLUE = OFF;
					#elif COLOR == BLUE
						LED_RED  = OFF;
					#endif 
				}
					
				if(getdate1.byte.model_number == 0x41 ){
					result_motor_output_l = 0.0;
					result_motor_output_r = 0.0;
					result_motor_output_b = 0.0;
				}
				
				//安全装置
				if(g_flag_safety == ON){
					result_motor_output_l = 0.0;
					result_motor_output_r = 0.0;
					result_motor_output_b = 0.0;
					Deadtime_lift_arm();
					Deadtime_top_arm();
					Deadtime_top_arm_turn();
					Deadtime_top_arm_tilt();
					Deadtime_seesaw_arm();
					fan_power_send[0] = 0;
					fan_power_send[1] = 0;
					fan_power_send[2] = 0;
					g_buzzer_io = ON;
					//BUZZER = ON;
				}
				
				if(g_buzzer_io == ON){
					BUZZER = ON;
				}else{
					BUZZER = OFF;
				}
				
				//足回り駆動
				Move(  result_motor_output_l,  result_motor_output_r,  result_motor_output_b);
			}
			
			
			
			//アームテスト用
			#elif MODE_ARM_TEST == ON
			
			//初期高さ調整
			if(getdate1.byte.start_sw == 0){//STARTボタン
				if(flag_start == OFF){
					flag_start = ON;
					if(LIMIT_SW_LIFT_ARM_LOW == OFF){//リフト
						flag_lift_set_start = ON;
					}else{
						flag_lift_set_start = OFF;
						flag_lift_arm_set = ON;
					}
					if(LIMIT_SW_TOP_ARM_FRONT == OFF){//上アーム
						flag_top_arm_set_start = ON;
					}else{
						flag_top_arm_set_start = OFF;
						flag_top_arm_set = ON;
					}
					if(LIMIT_SW_SEESAW_ARM_FRONT == OFF){//シーソーアーム
						flag_seesaw_arm_set_start = ON;
					}else{
						flag_seesaw_arm_set_start = OFF;
						flag_seesaw_arm_set = ON;
					}
				}
			}else{
				flag_start = OFF;
			}
			
			//リフト
			if(flag_lift_set_start == ON){
				if(LIMIT_SW_LIFT_ARM_LOW == OFF){//上リミットスイッチに触れていないとき
					flag_lift_arm_set = OFF;
					count_k = 0;
				}else{
					count_k ++;
				}
				Motor_lift_arm(-30.0);
			}
			if(count_k >= 30){
				count_k = 0;
				Motor_lift_arm(BRAKE);
				flag_lift_set_start = OFF;
				flag_lift_arm_set = ON;
				target_lock_lift = g_z_c_seesaw_arm;
			}
			
			//上アーム
			if(flag_top_arm_set_start == ON){
				if(LIMIT_SW_TOP_ARM_FRONT == OFF){//上アーム前リミットスイッチに触れていないとき
					flag_top_arm_set = OFF;
					count_l = 0;
				}else{
					count_l ++;
				}
				Motor_top_arm(-40.0);
			}
			if(count_l >= 10){
				count_l = 0;
				Motor_top_arm(BRAKE);
				flag_top_arm_set_start = OFF;
				flag_top_arm_set = ON;
			}
			
			//シーソーアーム
			if(flag_seesaw_arm_set_start == ON){
				if(LIMIT_SW_SEESAW_ARM_FRONT == OFF){//シーソーアーム前リミットスイッチに触れていないとき
					flag_seesaw_arm_set = OFF;
					count_m = 0;
				}else{
					count_m ++;
				}
				Motor_seesaw_arm(-30.0);
			}
			if(count_m >= 30){
				count_m = 0;
				Motor_seesaw_arm(BRAKE);
				flag_seesaw_arm_set_start = OFF;
				flag_seesaw_arm_set = ON;
			}
			
			if(flag_lift_arm_set == ON && flag_top_arm_set == ON && flag_seesaw_arm_set == ON){
				
				
				
				switch(step){
					case 0:
					Move_top_arm_lift_velocity(800,  step);

					if(fabs(800 - g_z_c_top_arm) < 5){
						step ++;
					}
					break;

					case 1:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					if(fabs(500 - g_top_arm_length) < 20){
						step ++;
					}
					break;

					case 2:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(90);
					if(fabs(get_gap_degree(90 , g_top_arm_degree)) < 10){
						step ++;
					}
					break;

					case 3:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(0);
					if(fabs(get_gap_degree(0 , g_top_arm_degree)) < 10){
						step ++;
					}
					break;

					case 4:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(0);
					Move_top_arm_tilt(90);
					if(fabs(get_gap_degree(90 , g_top_arm_tilt_degree)) < 5){
						step ++;
					}
					break;

					case 5:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(0);
					Move_top_arm_tilt(0);
					if(fabs(get_gap_degree(0 , g_top_arm_tilt_degree)) < 5){
						step ++;
					}
					break;

					case 6:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(0);
					Move_top_arm_tilt(0);
					Move_seesaw_arm_length(300);
					if(fabs(300 - g_seesaw_arm_length) < 20){
						step ++;
					}
					break;

					case 7:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(0);
					Move_top_arm_tilt(0);
					Move_seesaw_arm_length(300);
					Air_all_on_off(ON,  ON,  ON,  OFF);
					if(flag[0] == OFF){
						timer ++;
						if(timer >= 300){
							timer = 0;
							step ++;
						}
					}
					break;

					case 8:
					Move_top_arm_lift_velocity(800,  step);
					Move_top_arm_length(500);
					Move_top_arm_turn(0);
					Move_top_arm_tilt(0);
					Move_seesaw_arm_length(300);
					Air_all_on_off(OFF,  OFF,  OFF,  OFF);
					if(flag[0] == OFF){
						timer ++;
						if(timer >= 100){
							timer = 0;
							step ++;
						}
					}
					break;

					case 9:
					Move_top_arm_lift_velocity(800,  step);
					Move_all_arm_2(INIT_TOP_ARM_LENGTH,  INIT_TOP_ARM_DEGREE,  INIT_TOP_ARM_TILT_DEGREE,  INIT_SEESAW_ARM_LENGTH,  step);
					Air_all_on_off(OFF,  OFF,  OFF,  OFF);
					break;

				}
				
				if(step != step_old){
					flag[0] = ON;
				}
				if(flag[0] == ON){
					BUZZER = ON;
					timer ++;
					if(timer >= 100){
						timer = 0;
						flag[0] = OFF;
						BUZZER = OFF;
					}
				}
				
			}
			
			#endif 
			
			
			//シリアル通信
			#if MODE_SEND_TO_MBED == OFF
				#if BLUETOOTH_MODE == OFF
					//座標データ
					/*g_sci1 = g_x_c;
					g_sci2 = g_y_c;
					g_sci3 = g_degree;*/
					
					//g_sci2 = count_auto_lift;
					//g_sci3 = getdate2.byte.r2_sw;
					//足回り出力

					/*g_sci1 = result_motor_output_l;
					g_sci2 = result_motor_output_r;
					g_sci3 = result_motor_output_b;*/
					//g_sci1 = getdate2.byte.left_stick_wide;

					g_sci1 = result_motor_output_l;
					g_sci2 = result_motor_output_r;
					g_sci3 = result_motor_output_b;
					/*g_sci1 = getdate2.byte.left_stick_wide;

					g_sci2 = getdate3.byte.left_stick_high;
					g_sci3 = result_motor_output_l;
					g_sci4 = result_motor_output_r;
					g_sci5 = result_motor_output_b;
					
					//g_sci3 = getdate2.byte.right_stick_wide;
					//g_sci4 = getdate2.byte.right_stick_high;

					/*g_sci1 = g_motor_output_l;
					g_sci2 = g_motor_output_r;
					g_sci3 = g_motor_output_b;*/
					//g_sci4 = auto_chapter_to_swing;
					//g_sci5 = step;
					//g_sci4 = g_flag_safety;
					//g_sci4 = target_degree;
					//アーム出力
					//g_sci1 = motor_output_top;
					//g_sci4 = target_swing_arm_z;
					//g_sci5 = step;
					//各アーム高さ
					//g_sci1 = g_z_c_top_arm;
					//g_sci2 = g_z_c_swing_arm;
					//g_sci3 = g_z_c_seesaw_arm;
					/*g_sci5 = flag_lift_set;
					g_sci6 = get_encorder_MTU8();*/
					
					//モード
					/*g_sci1 = mode_AUTO_or_MANUAL;
					g_sci2 = mode_ar_seesaw;
					g_sci3 = mode_ar_swing;
					g_sci4 = mode_ar_top;
					g_sci5 = mode_ar_under;
					g_sci6 = mode_ar_top_arm_release;
					g_sci7 = mode_ar_under_arm_release;*/
					
					//ポテンショメータ
					/*g_sci1 = get_Ad(4);
					g_sci2 = get_Ad(0);
					g_sci3 = get_Ad(6);
					g_sci4 = get_Ad(2);*/
					/*g_sci1 = g_now_ad[0];
					g_sci2 = g_now_ad[1];
					g_sci3 = g_now_ad[2];
					g_sci4 = g_now_ad[3];*/
					/*g_sci1 = g_ad_att[0];
					g_sci2 = g_ad_att[1];
					g_sci3 = g_ad_att[2];
					g_sci4 = g_ad_att[3];
					g_sci5 = g_ad_att[4];
					g_sci6 = g_ad_att[5];
					g_sci7 = g_ad_att[6];
					g_sci8 = g_ad_att[7];*/
					/*g_sci1 = g_top_arm_length;
					g_sci2 = g_top_arm_degree;
					g_sci3 = g_top_arm_tilt_degree;
					g_sci4 = g_seesaw_arm_length;*/
					//g_sci1 = g_top_arm_turn_omega;
					//g_sci4 = g_under_arm_length;*/
					//g_sci5 = flag[0];*/
					//g_sci5 = count_average;
					//g_sci1 = g_z_c_top_arm;
					//g_sci2 = g_top_arm_tilt_degree;
					//g_sci1 = g_x_c_top_arm;
					//g_sci2 = g_y_c_top_arm;
					//g_sci3 = g_top_arm_velocity_x;
					//g_sci4 = g_top_arm_velocity_y;
					//足回りエンコーダ
					/*g_sci1 = get_encorder_MTU1();
					g_sci2 = get_encorder_MTU2();
					g_sci3 = get_encorder_MTU7();
					g_sci4 = result_motor_output_l;
					g_sci5 = g_flag_safety;*/
					//g_sci4 = g_degree;
					
					//フェイズ
					//g_sci1 = getdate2.byte.cross_sw;
					//g_sci2 = g_flag;
					//受信した値
					//g_sci1 = pick_out_atoz_value('o');
					//g_sci2 = pick_out_atoz_value('p');
					/*g_sci3 = g_c_value;
					g_sci4 = g_d_value;
					g_sci5 = g_e_value;
					g_sci6 = g_s_value;*/
					
					//g_sci1 = pick_out_atoz_value('o');
					//g_sci2 = pick_out_atoz_value('p');
					//g_sci2 = g_AtoZ_value[0];
					//g_sci1 = auto_chapter_swing;
					//PCにデータ送信
					//g_sci1 = count_while;
					
					/*g_sci1 = g_top_arm_length;
					g_sci2 = g_seesaw_arm_length;
					g_sci3 = g_z_c_top_arm;
					g_sci4 = flag_top_arm_set;
					g_sci5 = flag_seesaw_arm_set;
					g_sci6 = flag_lift_arm_set;*/
					
					/*g_sci1 = adjustment_sum[0];
					g_sci2 = adjustment_sum[1];
					g_sci3 = adjustment_sum[2];
					g_sci4 = adjustment_sum[3];*/
					sci_transformer();
				#endif
			#else
			//mbedにデータ送信
				if(TOGGLE_DEBUG_MODE == OFF){
					switch(i){
						case 0:
						sprintf(str1,"s%d#",step);
						i ++;	break;
						case 1:
						sprintf(str1,"x%.0f#",g_x_c);
						i ++;	break;
						case 2:
						sprintf(str1,"y%.0f#",g_y_c);
						i ++;	break;
						case 3:
						sprintf(str1,"w%.0f#",g_degree);
						i++;break;
						case 4:
						//sprintf(str1,"v%.0f#",g_velocity);
						sprintf(str1,"j%d#", (int)(g_timer_all / 1000));
						i ++;	break;
						case 5:
						sprintf(str1, "k%.0f#",		fan_power_send[0]);
						i ++;	break;
						case 6:
						sprintf(str1, "l%.0f#",		fan_power_send[1]);
						i ++;	break;
						case 7:
						sprintf(str1, "m%.0f#",	fan_power_send[2]);
						i ++;	break;
						case 8:
						sprintf(str1,  "n%d#",  0);
						i ++;	break;
						case 9:
						sprintf(str1,  "o%d#",  0);
						i = 0;	break;
						default:
						i = 0;break;
					}
					String_2(str1);
				}else{
					switch(i){
						case 0:
						sprintf(str2,"a%.0f#",g_now_ad[0]);
						i ++;	break;
						case 1:
						sprintf(str2,"b%.0f#",g_now_ad[1]);
						i ++;	break;
						case 2:
						sprintf(str2,"c%.0f#",g_now_ad[2]);
						i ++;	break;
						case 3:
						sprintf(str2,"d%.0f#",g_now_ad[3]);
						i ++; break;
						case 4:
						sprintf(str2,"e%.0f#",get_encorder_MTU1());
						i ++;	break;
						case 5:
						sprintf(str2,"f%.0f#",get_encorder_MTU2());
						i ++;	break;
						case 6:
						sprintf(str2,"g%.0f#",get_encorder_MTU7());
						i ++;	break;
						case 7:
						sprintf(str2,"h%.0f#",get_encorder_MTU8());
						i ++;	break;
						case 8:
						sprintf(str2,"i%d#",LIMIT_SW_SEESAW_ARM_FRONT + LIMIT_SW_SEESAW_ARM_BACK + LIMIT_SW_LIFT_ARM_HIGH + LIMIT_SW_LIFT_ARM_LOW + LIMIT_SW_TOP_ARM_FRONT + LIMIT_SW_TOP_ARM_BACK);
						//sprintf(str2,"i%d#",i);
						i ++;	break;
						case 9:
						//sprintf(str2,"j%d#", (int)(g_timer_all / 100));
						sprintf(str2,"v%.0f#",g_velocity);
						//sprintf(str2,"j%d#",i);
						i = 0;break;
					}
					String_2(str2);
				}
					
			#endif
			step_old = step;
			count_average = count_while; 
			count_while = 0;
			}
	}
}
/******************************************************************************
*	タイトル ： タイマ0.001秒ごとの割り込み
*	  関数名 ： wait_interruput
*	  戻り値 ： void型
*	    引数 ： なし
*	  作成者 ： 坂下文彦
*	  作成日 ： 2013/10/14
******************************************************************************/
void wait_interrupt(void)
{
	IR(CMT0,CMI0) = OFF;
	
	g_interrupt_timer_count ++;
	//g_interrupt_timer_count_2 ++;
	g_left_motor_timer_count ++;
	g_right_motor_timer_count ++;
	g_back_motor_timer_count ++;
	g_timer_all ++;
}
#ifdef __cplusplus
void abort(void)
{

}
#endif
